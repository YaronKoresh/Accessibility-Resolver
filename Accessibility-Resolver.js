const AR_CONFIG = {
	MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX: 24,
	MINIMUM_TOUCH_TARGET_SPACING_PX: 8,
	CONTRAST_RATIO_AA_NORMAL_TEXT: 4.5,
	CONTRAST_RATIO_AA_LARGE_TEXT: 3,
	CONTRAST_RATIO_AAA_NORMAL_TEXT: 7,
	CONTRAST_RATIO_AAA_LARGE_TEXT: 4.5,
	NON_TEXT_CONTRAST_RATIO_AA: 3,
	LARGE_TEXT_FONT_SIZE_PX: 24,
	LARGE_TEXT_FONT_SIZE_BOLD_PX: 18.66,
	MINIMUM_BODY_TEXT_FONT_SIZE_PX: 13,
	MAX_CHARS_FOR_WALL_OF_TEXT_DETECTION: 600,
	MAX_REPETITIONS_FOR_GENERIC_LINK_TEXT: 2,
	MUTATION_OBSERVER_DEBOUNCE_MILLISECONDS: 750,
	MAX_CHAR_LENGTH_FOR_HEADINGS: 90,
	MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT: 3,
	MAX_SIBLING_SEARCH_DEPTH_FOR_ARIA_RELATIONSHIP: 4,
	MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL: 120,
	MIN_CONTRAST_FOR_PDF_ICON: 2.5,
	MIN_CHAR_LENGTH_FOR_REDUNDANT_TITLE_CHECK: 4,
	MAX_WORDS_FROM_CONTEXT_FOR_GENERIC_LINK_ARIA_LABEL: 12,
	ACCESSIBILITY_MENU_BUTTON_ID: 'accessibility-resolver-menu-toggle-button',
	ACCESSIBILITY_MENU_PANEL_ID: 'accessibility-resolver-menu-panel',
	DEFAULT_FONT_SIZE_ADJUSTMENT_INCREMENT: 0.1,
	MAX_FONT_SIZE_ADJUSTMENT_MULTIPLIER: 3,
	MIN_FONT_SIZE_ADJUSTMENT_MULTIPLIER: 0.6,
	READING_MASK_ELEMENT_ID: 'accessibility-resolver-reading-mask',
	READING_LINE_ELEMENT_ID: 'accessibility-resolver-reading-line',
	DYSLEXIA_FRIENDLY_FONT_CLASS_NAME: 'accessibility-resolver-dyslexia-font',
	DYSLEXIA_FRIENDLY_FONT_STYLESHEET_URL: 'https://cdn.jsdelivr.net/gh/OpenDyslexic/opendyslexic@master/compiled/opendyslexic.css',
	SATURATION_FILTER_CLASS_NAME: 'accessibility-resolver-saturation-filter',
	TEXT_ALIGNMENT_CLASS_NAME_PREFIX: 'accessibility-resolver-text-align-',
	INCREASED_LETTER_SPACING_CLASS_NAME: 'accessibility-resolver-increased-letter-spacing',
	INCREASED_WORD_SPACING_CLASS_NAME: 'accessibility-resolver-increased-word-spacing',
	INCREASED_LINE_HEIGHT_CLASS_NAME: 'accessibility-resolver-increased-line-height',
	ANIMATIONS_STOPPED_CLASS_NAME: 'accessibility-resolver-animations-stopped',
	HIGHLIGHTED_LINKS_CLASS_NAME: 'accessibility-resolver-highlight-links',
	HIGHLIGHTED_HEADINGS_CLASS_NAME: 'accessibility-resolver-highlight-headings',
	HIGH_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-high',
	INVERTED_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-inverted',
	GRAYSCALE_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-grayscale',
	LOW_SATURATION_CLASS_NAME: 'accessibility-resolver-saturation-low',
	AVATAR_KEYWORDS: [
		'avatar',
		'profile',
		'usericon',
		'dp',
		'user-img',
		'user_image'
	],
	FILENAME_CLEANUP_REGEX: /[-_]/g,
	COMMON_ICON_CLASS_PREFIXES: [
		'fa-',
		'fas',
		'far',
		'fal',
		'fad',
		'fab',
		'glyphicon-',
		'icon-',
		'material-icons',
		'mdi-',
		'bi-',
		'icofont-'
	],
	MENU_ICON_COLOR: '#455a64',
	MENU_ICON_ACTIVE_COLOR: '#ffffff',
	MENU_TEXT_ACTIVE_COLOR: '#ffffff',
	PLACEHOLDER_IMAGE_URL: 'https://placehold.co/{width}x{height}/E0E0E0/BDBDBD?text={text}',
	CONTRAST_ADJUSTMENT_STEPS: 10,
	CONTRAST_ADJUSTMENT_AMOUNT: 0.1,
	AGGRESSIVE_CONTRAST_BG_ADJUST_MAX_DELTA: 0.25
};
const AR_SELECTOR_STRINGS = {
	INTERACTIVE_ELEMENTS: 'button, a[href], input:not([type="hidden"]), select, textarea, [role="button"], [role="link"], [role="checkbox"], [role="radio"], [role="option"], [role="menuitem"], [role="tab"], [role="treeitem"], [role="slider"], [role="spinbutton"], [role="switch"], [tabindex]:not([tabindex="-1"])',
	HEADING_ELEMENTS: 'h1, h2, h3, h4, h5, h6',
	TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU: `p, li, dt, dd, figcaption, blockquote, pre, code, summary, h1, h2, h3, h4, h5, h6, article, section, main, header, footer, nav, aside, div:not(#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }):not(#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID }):not([role="toolbar"]):not([role="menubar"]):not([class*="toast"]):not([class*="modal"]):not([class*="popup"]), span:not(#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } *):not(#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID } *), td, th, caption, label, legend, em, strong, b, i, small, sub, sup, mark, ins, del, q, cite`.replace(/\s+/g, ' ').trim(),
	FORM_CONTROL_ELEMENTS: 'input:not([type="hidden"]), select, textarea',
	LANDMARK_ROLES_ARRAY: [
		'main',
		'banner',
		'contentinfo',
		'navigation',
		'complementary',
		'form',
		'region',
		'search'
	],
	LANDMARK_HTML_TAGS_ARRAY: [
		'main',
		'header',
		'footer',
		'nav',
		'aside',
		'form',
		'section'
	],
	MEDIA_ELEMENTS: 'img, svg, canvas, iframe, audio, video',
	MAIN_CONTENT_TARGET_SELECTORS: 'main, [role="main"], #main, #content, .main, .page-content, article, #main-content, [data-main-content], .container, .wrapper, #page-wrapper, div[class*="content-area" i], section[class*="main-content" i]',
	NATIVE_INTERACTIVE_TAGS: 'button, a, input, select, textarea',
	COMMON_HEADER_SELECTORS: 'body > header, body > div[id*="header" i], body > div[class*="header" i], body > div[id*="banner" i], body > div[class*="banner" i], body > .site-header, body > #site-header, body > #masthead',
	COMMON_FOOTER_SELECTORS: 'body > footer, body > div[id*="footer" i], body > div[class*="footer" i], body > div[id*="colophon" i], body > .site-footer, body > #site-footer',
	COMMON_NAV_SELECTORS: 'body > nav, body > div[id*="nav" i], body > div[class*="nav" i], body > ul[class*="nav" i], body > div[id*="menu" i], body > ul[id*="menu" i], body > .main-nav, body > #main-nav, body > .primary-navigation'
};
let ar_accessibilityIssuesLog = [];
let ar_totalScannedIssuesCounter = 0;
let ar_totalAutoFixedIssuesCounter = 0;
const ar_generatedUniqueElementIds = new Set();
const ar_detectedLandmarkRoleCounts = {};
let ar_mainMutationObserverDebounceTimeout;
const ar_originalElementStylesMap = new Map();
let ar_activeReadingGuideType = null;
const ar_loggedIssuesTracker = new Set();
function ar_getLogMeta(severity, isAutofixed) {
	const styles = {
		'Critical': {
			p: '\u274C Critical:',
			s: 'color:white;background:#d32f2f;border-left:4px solid #b71c1c;'
		},
		'Moderate': {
			p: '\u26A0ï¸ Moderate:',
			s: 'color:black;background:#ffb300;border-left:4px solid #e65100;'
		},
		'Minor': {
			p: '\uD83D\uDCA1 Minor:',
			s: 'color:black;background:#64b5f6;border-left:4px solid #1976d2;'
		},
		'Info': {
			p: 'â„¹ï¸ Info:',
			s: 'color:#37474f;background:#eceff1;border-left:4px solid #90a4ae;'
		}
	};
	const fixStyle = {
		p: '\u2705 Auto-Fixed:',
		s: 'color:darkgreen;background:#c8e6c9;border-left:4px solid #388e3c;'
	};
	return isAutofixed ? fixStyle : styles[severity] || styles.Info
}
function ar_logIssueDetails(element, recommendation, wcagPrinciple, wcagGuideline, wcagLevel, isAutofixed, severity) {
	if (element instanceof HTMLElement)
		console.log('%cElement:', 'font-weight:bold;color:#424242;margin-left:15px;', element);
	else if (typeof element === 'string')
		console.log(`%cContext: %c${ element }`, 'font-weight:bold;color:#424242;margin-left:15px;', 'color:#424242;');
	if (recommendation && (!isAutofixed || severity === 'Critical' || severity === 'Moderate'))
		console.log(`%cRecommendation: %c${ recommendation }`, 'font-weight:bold;color:#0d47a1;margin-left:15px;padding-left:8px;border-left:3px solid #bbdefb;', 'color:#1565c0;');
	if (wcagGuideline)
		console.log(`%cWCAG: %c${ wcagGuideline } (${ wcagLevel }) - ${ wcagPrinciple }`, 'font-weight:bold;color:#4a148c;margin-left:15px;padding-left:8px;border-left:3px solid #e1bee7;', 'color:#6a1b9a;')
}
function ar_logAccessibilityIssue(severity, message, element = null, recommendation = '', wcagPrinciple = '', wcagGuideline = '', isAutofixed = false, wcagLevel = 'A') {
	let elId = 'global', elSig = '';
	if (element instanceof HTMLElement) {
		elId = element.id || element.dataset.arGeneratedId || (element.dataset.arGeneratedId = ar_generateUniqueElementId('el-tracked-'));
		if (wcagGuideline === '1.4.3 Contrast (Minimum)') {
			const style = window.getComputedStyle(element);
			const fg = style.color;
			const bg = ar_getEffectiveBackgroundColorOfElement(element).join(',');
			elSig = `::${ fg }-${ bg }`
		}
	}
	const baseMsgKey = message.substring(0, 40).replace(/\s+/g, '_').replace(/[^\w-]/g, '');
	let issueKey = `${ elId }::${ wcagGuideline || baseMsgKey }${ elSig }::${ severity }`;
	if (message.toLowerCase().includes('autofix attempt failed') && wcagGuideline === '1.4.3 Contrast (Minimum)') {
		const origKey = `${ elId }::${ wcagGuideline }${ elSig }::Critical`;
		if (ar_loggedIssuesTracker.has(origKey))
			return;
		issueKey = origKey
	}
	if (ar_loggedIssuesTracker.has(issueKey) && !isAutofixed)
		return;
	ar_loggedIssuesTracker.add(issueKey);
	ar_totalScannedIssuesCounter++;
	ar_accessibilityIssuesLog.push({
		id: `ar-issue-${ ar_totalScannedIssuesCounter }`,
		severity,
		message,
		element,
		recommendation,
		wcagPrinciple,
		wcagGuideline,
		isAutofixed,
		wcagLevel
	});
	const logMeta = ar_getLogMeta(severity, isAutofixed);
	console.groupCollapsed(`%c${ logMeta.p } %c${ message }`, `${ logMeta.s }font-weight:bold;padding:4px 8px;border-radius:4px 0 0 4px;`, 'font-weight:normal;padding:4px 8px;');
	ar_logIssueDetails(element, recommendation, wcagPrinciple, wcagGuideline, wcagLevel, isAutofixed, severity);
	console.groupEnd();
	if (isAutofixed)
		ar_totalAutoFixedIssuesCounter++
}
function ar_logSection(title) {
	console.groupCollapsed(`%cðŸ”Ž ${ title } %c`, 'background-color:#e8f0fe;color:#174ea6;font-weight:bold;padding:6px 12px;border-radius:5px;border:1px solid #d0d8e0;margin-bottom:5px;display:inline-block;', '')
}
function ar_generateUniqueElementId(prefix = 'ar-uid') {
	let newId;
	let attempts = 0;
	do {
		newId = `${ prefix }-${ Math.random().toString(36).substring(2, 9) }${ attempts > 0 ? '-' + attempts : '' }`;
		attempts++
	} while (document.getElementById(newId) || ar_generatedUniqueElementIds.has(newId));
	ar_generatedUniqueElementIds.add(newId);
	return newId
}
function ar_hasAriaLabel(el) {
	return el.getAttribute('aria-label') && el.getAttribute('aria-label').trim()
}
function ar_hasAriaLabelledby(el) {
	const labelledbyAttr = el.getAttribute('aria-labelledby');
	if (!labelledbyAttr)
		return false;
	return labelledbyAttr.split(/\s+/).some(id => {
		const lblEl = document.getElementById(id);
		return lblEl && (lblEl.textContent || '').trim()
	})
}
function ar_hasTextOrValue(el) {
	return (el.textContent || '').trim() || (el.value || '').trim()
}
function ar_hasImageWithAltInAnchor(el) {
	const img = el.querySelector('img[alt]');
	return img && (img.alt || '').trim()
}
function ar_hasImageAlt(el) {
	return (el.alt || '').trim()
}
function ar_hasFigcaption(el) {
	const figcaption = el.querySelector('figcaption');
	return figcaption && (figcaption.textContent || '').trim()
}
function ar_hasExplicitLabel(el) {
	if (!el.id)
		return false;
	const labels = document.querySelectorAll(`label[for="${ el.id }"]`);
	return Array.from(labels).some(lbl => (lbl.textContent || '').trim() || lbl.querySelector('img[alt]'))
}
function ar_hasParentLabel(el) {
	const parentLbl = el.closest('label');
	return parentLbl && (parentLbl.textContent || '').trim() && (!parentLbl.htmlFor || parentLbl.htmlFor === el.id)
}
function ar_hasTitleAttr(el) {
	return !!(el.getAttribute('title') && el.getAttribute('title').trim())
}
function ar_hasAccessibleNameForElement(element) {
	if (!element)
		return false;
	if (ar_hasAriaLabel(element) || ar_hasAriaLabelledby(element))
		return true;
	const tagName = element.tagName.toUpperCase();
	if ((tagName === 'BUTTON' || tagName === 'INPUT' && [
			'submit',
			'reset',
			'button'
		].includes(element.type)) && ar_hasTextOrValue(element))
		return true;
	if (tagName === 'A' && (ar_hasTextOrValue(element) || ar_hasImageWithAltInAnchor(element)))
		return true;
	if (tagName === 'IMG' && ar_hasImageAlt(element))
		return true;
	if (tagName === 'INPUT' && element.type === 'image' && ar_hasImageAlt(element))
		return true;
	if (tagName === 'FIGURE' && ar_hasFigcaption(element))
		return true;
	if ([
			'INPUT',
			'SELECT',
			'TEXTAREA'
		].includes(tagName) && (ar_hasExplicitLabel(element) || ar_hasParentLabel(element)))
		return true;
	return ar_hasTitleAttr(element)
}
function ar_parseCssColorString(colorString) {
	if (!colorString || typeof colorString !== 'string')
		return [
			0,
			0,
			0,
			0
		];
	const div = document.createElement('div');
	Object.assign(div.style, {
		color: 'transparent',
		backgroundColor: 'transparent',
		display: 'none'
	});
	if (!document.body)
		return [
			0,
			0,
			0,
			0
		];
	document.body.appendChild(div);
	try {
		div.style.color = colorString;
		const compColor = window.getComputedStyle(div).color;
		const match = compColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
		if (match)
			return [
				+match[1],
				+match[2],
				+match[3],
				match[4] !== undefined ? parseFloat(match[4]) : 1
			]
	} catch (e) {
	} finally {
		div.remove()
	}
	return [
		0,
		0,
		0,
		0
	]
}
function ar_getLuminanceFromRgb(rgbArray) {
	const a = rgbArray.slice(0, 3).map(v => {
		v /= 255;
		return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)
	});
	return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722
}
function ar_getContrastRatioBetweenColors(rgba1, rgba2) {
	const lum1 = ar_getLuminanceFromRgb(rgba1);
	const lum2 = ar_getLuminanceFromRgb(rgba2);
	return (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05)
}
function ar_blendColors(fgRgba, bgRgba) {
	const alpha = fgRgba[3];
	if (alpha === 1)
		return fgRgba;
	const r = Math.round((1 - alpha) * bgRgba[0] + alpha * fgRgba[0]);
	const g = Math.round((1 - alpha) * bgRgba[1] + alpha * fgRgba[1]);
	const b = Math.round((1 - alpha) * bgRgba[2] + alpha * fgRgba[2]);
	return [
		r,
		g,
		b,
		1
	]
}
function ar_getEffectiveBackgroundColorOfElement(element) {
	let currentEl = element;
	while (currentEl && currentEl !== document.documentElement) {
		const style = window.getComputedStyle(currentEl);
		const bgColor = style.backgroundColor;
		if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
			const rgba = ar_parseCssColorString(bgColor);
			if (rgba[3] === 1)
				return rgba
		}
		if (currentEl === document.body || !currentEl.parentElement)
			break;
		currentEl = currentEl.parentElement
	}
	const bodyBg = ar_parseCssColorString(window.getComputedStyle(document.body).backgroundColor);
	return bodyBg[3] === 1 ? bodyBg : [
		255,
		255,
		255,
		1
	]
}
function ar_isTextLargeForWCAG(element) {
	const style = window.getComputedStyle(element);
	const fontSize = parseFloat(style.fontSize);
	const fontWeight = style.fontWeight;
	return fontSize >= AR_CONFIG.LARGE_TEXT_FONT_SIZE_PX || fontSize >= AR_CONFIG.LARGE_TEXT_FONT_SIZE_BOLD_PX && (parseInt(fontWeight) >= 700 || fontWeight === 'bold' || fontWeight === 'bolder')
}
function ar_setAttributeAndLog(el, attr, val, sev, msg, rec, princ, guide, level = 'A') {
	try {
		if (attr === 'textContent')
			el.textContent = val;
		else
			el.setAttribute(attr, val);
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1
	} catch (e) {
		console.error(`setAttribute Error: ${ attr }=${ val } on`, el, e);
		return 0
	}
}
function ar_removeAttributeAndLog(el, attr, sev, msg, rec, princ, guide, level = 'A') {
	try {
		el.removeAttribute(attr);
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1
	} catch (e) {
		console.error(`removeAttribute Error: ${ attr } on`, el, e);
		return 0
	}
}
function ar_applyStylesAndLog(el, styles, sev, msg, rec, princ, guide, level = 'A') {
	try {
		for (const prop in styles)
			el.style.setProperty(prop, styles[prop], 'important');
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1
	} catch (e) {
		console.error('applyStyles Error:', el, styles, e);
		return 0
	}
}
function ar_isVisuallyHidden(element) {
	if (!element)
		return true;
	const style = window.getComputedStyle(element);
	return style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0' || element.offsetWidth === 0 || element.offsetHeight === 0
}
function ar_rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	const max = Math.max(r, g, b), min = Math.min(r, g, b);
	let h, s, l = (max + min) / 2;
	if (max === min)
		h = s = 0;
	else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
		case r:
			h = (g - b) / d + (g < b ? 6 : 0);
			break;
		case g:
			h = (b - r) / d + 2;
			break;
		case b:
			h = (r - g) / d + 4;
			break
		}
		h /= 6
	}
	return [
		h,
		s,
		l
	]
}
function ar_hslToRgb(h, s, l) {
	let r, g, b;
	if (s === 0)
		r = g = b = l;
	else {
		const hue2rgb = (p, q, t) => {
			if (t < 0)
				t += 1;
			if (t > 1)
				t -= 1;
			if (t < 1 / 6)
				return p + (q - p) * 6 * t;
			if (t < 1 / 2)
				return q;
			if (t < 2 / 3)
				return p + (q - p) * (2 / 3 - t) * 6;
			return p
		};
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3)
	}
	return [
		Math.round(r * 255),
		Math.round(g * 255),
		Math.round(b * 255)
	]
}
const AR_AccessibilityMenu = {
	isOpen: false,
	readingGuideLineElement: null,
	readingMaskTopElement: null,
	readingMaskBottomElement: null,
	currentFontSizeMultiplier: 1,
	activeContrastModeClassName: 'default',
	isDyslexiaFontActive: false,
	init: function () {
		this.injectStyles();
		this.createMenuButton();
		this.createMenuPanel();
		this.attachEventListeners();
		console.log('Accessibility Menu Initialized.')
	},
	injectStyles: function () {
		const styleId = 'ar-menu-styles';
		if (document.getElementById(styleId))
			return;
		const css = `/* ... CSS from previous version, ensuring active button contrast ... */ #${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID }{position:fixed;bottom:20px;z-index:2147483647;background-color:#0056b3;color:${ AR_CONFIG.MENU_ICON_ACTIVE_COLOR }!important;border:none;border-radius:50%;width:60px;height:60px;font-size:28px;cursor:pointer;box-shadow:0 4px 15px rgba(0,0,0,0.25);display:flex;align-items:center;justify-content:center;transition:background-color .3s,transform .2s,box-shadow .2s;}#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID } .ar-menu-icon svg{fill:${ AR_CONFIG.MENU_ICON_ACTIVE_COLOR }!important;}#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID }:hover,#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID }:focus-visible{background-color:#003d82;color:${ AR_CONFIG.MENU_ICON_ACTIVE_COLOR }!important;outline:3px solid #70a1ff;outline-offset:2px;transform:scale(1.08);box-shadow:0 6px 20px rgba(0,0,0,0.3);}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }{display:none;position:fixed;bottom:90px;width:350px;max-height:calc(100vh - 120px);overflow-y:auto;background-color:#fff;border:1px solid #bdbdbd;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.15);z-index:2147483646;padding:20px;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;font-size:15px;color:#212121;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }.ar-menu-open{display:block;animation:ar-slide-up .3s ease-out;}@keyframes ar-slide-up{from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } fieldset.ar-menu-group{border:1px solid #e0e0e0;padding:12px 18px 18px;margin-bottom:18px;border-radius:8px;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } legend{font-size:1.15em;font-weight:600;color:#004a99;padding:0 8px;margin-left:8px;display:flex;align-items:center;gap:6px;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } legend .ar-menu-icon{width:20px;height:20px;fill:${ AR_CONFIG.MENU_ICON_COLOR };}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-button-row{display:flex;flex-wrap:wrap;margin:0 -3px;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } button{display:flex;align-items:center;justify-content:center;gap:8px;flex:1 1 calc(50% - 6px);min-width:calc(50% - 6px);padding:10px 8px;margin:3px;border:1px solid #ccc;border-radius:6px;background-color:#f5f5f5;cursor:pointer;font-size:14px;transition:background-color .2s,transform .1s,box-shadow .2s,color .2s,border-color .2s;color:${ AR_CONFIG.MENU_ICON_COLOR }!important;line-height:1.2;text-align:center;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } button .ar-menu-icon{display:inline-block;width:18px;height:18px;fill:currentColor;vertical-align:middle;transition:fill .2s;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } button .ar-menu-text{vertical-align:middle;flex-grow:1;text-align:center;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } button:hover,#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } button:focus-visible{background-color:#e0e0e0;border-color:#0056b3;outline:2px solid transparent;box-shadow:0 1px 3px rgba(0,0,0,0.1);}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } button:focus-visible{outline:2px solid #0056b3;outline-offset:1px;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-menu-fullwidth-btn{width:calc(100% - 6px);flex-basis:calc(100% - 6px);}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-menu-reset-btn{background-color:#e6ffed;border-color:#a3d4b7;font-weight:500;color:#1e4620!important;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-menu-reset-btn .ar-menu-icon{fill:#1e4620!important;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-menu-reset-btn:hover,#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-menu-reset-btn:focus-visible{background-color:#c8f0d3;border-color:#4caf50;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-menu-btn-active{background-color:#0056b3!important;color:${ AR_CONFIG.MENU_TEXT_ACTIVE_COLOR }!important;border-color:#003d82!important;font-weight:bold;}#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } .ar-menu-btn-active .ar-menu-icon{fill:${ AR_CONFIG.MENU_ICON_ACTIVE_COLOR }!important;}#ar-menu-close-button{background-color:#f8d7da;border-color:#f5c6cb;color:#721c24!important;margin-top:10px;}#ar-menu-close-button:hover,#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } #ar-menu-close-button:focus-visible{background-color:#f1b0b7;border-color:#e08890;}#ar-menu-close-button .ar-menu-icon{fill:#721c24!important;}`;
		const styleEl = document.createElement('style');
		styleEl.id = styleId;
		styleEl.textContent = css;
		document.head.appendChild(styleEl)
	},
	createMenuButton: function () {
		if (document.getElementById(AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID))
			return;
		const btn = document.createElement('button');
		btn.id = AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID;
		btn.setAttribute('aria-label', 'Accessibility Menu');
		btn.setAttribute('aria-expanded', 'false');
		btn.setAttribute('aria-controls', AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID);
		btn.innerHTML = `<svg class="ar-menu-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="32px" height="32px"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"/></svg>`;
		const docDir = document.documentElement.dir || window.getComputedStyle(document.documentElement).direction;
		if (docDir === 'rtl') {
			btn.style.left = '20px';
			btn.style.right = 'auto'
		} else {
			btn.style.right = '20px';
			btn.style.left = 'auto'
		}
		document.body.appendChild(btn)
	},
	createMenuPanel: function () {
		if (document.getElementById(AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID))
			return;
		const p = document.createElement('div');
		p.id = AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID;
		p.setAttribute('role', 'dialog');
		p.setAttribute('aria-labelledby', 'ar-menu-title');
		p.setAttribute('aria-hidden', 'true');
		p.style.display = 'none';
		const docDir = document.documentElement.dir || window.getComputedStyle(document.documentElement).direction;
		if (docDir === 'rtl') {
			p.style.left = '20px';
			p.style.right = 'auto'
		} else {
			p.style.right = '20px';
			p.style.left = 'auto'
		}
		const icon = (pathData, altText = '') => `<span class="ar-menu-icon" role="img" aria-label="${ altText }"><svg viewBox="0 0 24 24">${ pathData }</svg></span>`;
		const ICONS = {
			fontSize: icon('<path d="M9.93 13.5h4.14L12 7.98zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4.05 11.89h-1.6L12.7 8.33h1.6l1.65 7.56zM6.25 8.33l1.65 7.56h-1.6L4.65 8.33h1.6z"/>', 'Font size'),
			contrast: icon('<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18V4c4.41 0 8 3.59 8 8s-3.59 8-8 8z"/>', 'Contrast'),
			spacing: icon('<path d="M6 17h12v2H6zm8-4H6v2h8zm-4-4H6v2h4zm0-4H6v2h4zm10 0v10h2V5zM4 5H2v10h2z"/>', 'Spacing'),
			alignLeft: icon('<path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/>', 'Align left'),
			alignCenter: icon('<path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/>', 'Align center'),
			highlight: icon('<path d="m17.68 8.47-2.12-2.12c-.2-.2-.51-.2-.71 0l-8.35 8.35-1.06 3.18c-.1.3.12.61.42.72l3.18-1.06 8.35-8.35c.2-.2.2-.51 0-.72zm-9.24 7.09L7 14.12l6.56-6.56 1.44 1.44-6.56 6.56zM4 20h16v-2H4v2z"/>', 'Highlight'),
			readingAid: icon('<path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-1 2v.01L12 13 4 8.01V8h16zm0 8H4v-2.01L12 11l8 4.99V16z"/>', 'Reading aid'),
			fontStyle: icon('<path d="M9.25 4v1.5H6.75V4h-1.5v1.5H2.75V4H1.25v10.5h1.5V16h2.5v-1.5h-2.5V5.5h2.5V7h1.5V5.5h2.5v8.25c0 .93.53 1.74 1.32 2.13.23.11.48.17.73.17.83 0 1.5-.67 1.5-1.5V4h-1.5zm8.5 0v1.5h-2.5V4h-1.5v1.5h-2.5V4H7.25v10.5h1.5V16h2.5v-1.5H8.75V5.5h2.5V7h1.5V5.5h2.5v8.25c0 .93.53 1.74 1.32 2.13.23.11.48.17.73.17.83 0 1.5-.67 1.5-1.5V4h-1.5z"/>', 'Font style'),
			animation: icon('<path d="M8 5v14l11-7z"/>', 'Animation'),
			reset: icon('<path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>', 'Reset'),
			close: icon('<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>', 'Close'),
			textIncrease: icon('<path d="M14.5 16.5h-1.25l-2.6-7h1.25l1.98 5.58L15.85 9.5h1.3l-2.65 7zm5-11H4.5c-.83 0-1.5.67-1.5 1.5v9c0 .83.67 1.5 1.5 1.5h15c.83 0 1.5-.67 1.5-1.5v-9c0-.83-.67-1.5-1.5-1.5zm0 10.5H4.5v-9h15v9zM10 12.5H7.5v-1h2.5v-1H7.5v-1h2.5V8.5H6.25v5h3.75z"/>', 'Increase text'),
			textDecrease: icon('<path d="M14.5 16.5h-1.25l-2.6-7h1.25l1.98 5.58L15.85 9.5h1.3l-2.65 7zm5-11H4.5c-.83 0-1.5.67-1.5 1.5v9c0 .83.67 1.5 1.5 1.5h15c.83 0 1.5-.67 1.5-1.5v-9c0-.83-.67-1.5-1.5-1.5zm0 10.5H4.5v-9h15v9zM10 10.5H6.25v1h3.75z"/>', 'Decrease text')
		};
		p.innerHTML = `<h3 id="ar-menu-title">Accessibility Tools</h3><fieldset class="ar-menu-group"><legend>${ ICONS.fontSize }<span class="ar-menu-text">Text Size</span></legend><div class="ar-button-row"><button data-action="increase-font" aria-label="Increase font size">${ ICONS.textIncrease }<span class="ar-menu-text">Increase</span></button><button data-action="decrease-font" aria-label="Decrease font size">${ ICONS.textDecrease }<span class="ar-menu-text">Decrease</span></button><button data-action="reset-font" class="ar-menu-fullwidth-btn ar-menu-reset-btn">${ ICONS.reset }<span class="ar-menu-text">Reset Font</span></button></div></fieldset><fieldset class="ar-menu-group"><legend>${ ICONS.contrast }<span class="ar-menu-text">Contrast & Color</span></legend><div class="ar-button-row"><button data-action="contrast-high">${ ICONS.contrast }<span class="ar-menu-text">High</span></button><button data-action="contrast-inverted">${ ICONS.contrast }<span class="ar-menu-text">Invert</span></button><button data-action="contrast-grayscale">${ ICONS.contrast }<span class="ar-menu-text">Grayscale</span></button><button data-action="saturation-low">${ ICONS.contrast }<span class="ar-menu-text">Low Saturation</span></button><button data-action="reset-contrast" class="ar-menu-fullwidth-btn ar-menu-reset-btn">${ ICONS.reset }<span class="ar-menu-text">Reset Visuals</span></button></div></fieldset><fieldset class="ar-menu-group"><legend>${ ICONS.spacing }<span class="ar-menu-text">Text Spacing</span></legend><div class="ar-button-row"><button data-action="text-spacing-letter">${ ICONS.spacing }<span class="ar-menu-text">Letter</span></button><button data-action="text-spacing-word">${ ICONS.spacing }<span class="ar-menu-text">Word</span></button><button data-action="text-spacing-line">${ ICONS.spacing }<span class="ar-menu-text">Line</span></button><button data-action="text-spacing-reset" class="ar-menu-fullwidth-btn ar-menu-reset-btn">${ ICONS.reset }<span class="ar-menu-text">Reset Spacing</span></button></div></fieldset><fieldset class="ar-menu-group"><legend>${ ICONS.alignLeft }<span class="ar-menu-text">Text Alignment</span></legend><div class="ar-button-row"><button data-action="text-align-left">${ ICONS.alignLeft }<span class="ar-menu-text">Align Left</span></button><button data-action="text-align-center">${ ICONS.alignCenter }<span class="ar-menu-text">Align Center</span></button><button data-action="text-align-reset" class="ar-menu-fullwidth-btn ar-menu-reset-btn">${ ICONS.reset }<span class="ar-menu-text">Reset Alignment</span></button></div></fieldset><fieldset class="ar-menu-group"><legend>${ ICONS.highlight }<span class="ar-menu-text">Highlight Content</span></legend><div class="ar-button-row"><button data-action="highlight-links">${ ICONS.highlight }<span class="ar-menu-text">Links</span></button><button data-action="highlight-headings">${ ICONS.highlight }<span class="ar-menu-text">Headings</span></button><button data-action="reset-highlights" class="ar-menu-fullwidth-btn ar-menu-reset-btn">${ ICONS.reset }<span class="ar-menu-text">Reset Highlights</span></button></div></fieldset><fieldset class="ar-menu-group"><legend>${ ICONS.readingAid }<span class="ar-menu-text">Reading Aids</span></legend><div class="ar-button-row"><button data-action="toggle-reading-line">${ ICONS.readingAid }<span class="ar-menu-text">Reading Line</span></button><button data-action="toggle-reading-mask">${ ICONS.readingAid }<span class="ar-menu-text">Reading Mask</span></button></div></fieldset><fieldset class="ar-menu-group"><legend>${ ICONS.fontStyle }<span class="ar-menu-text">Font Style</span></legend><div class="ar-button-row"><button data-action="toggle-dyslexia-font" class="ar-menu-fullwidth-btn">${ ICONS.fontStyle }<span class="ar-menu-text">Dyslexia Friendly Font</span></button></div></fieldset><fieldset class="ar-menu-group"><legend>${ ICONS.animation }<span class="ar-menu-text">Animations & Motion</span></legend><div class="ar-button-row"><button data-action="stop-animations" class="ar-menu-fullwidth-btn">${ ICONS.animation }<span class="ar-menu-text">Stop Animations</span></button></div></fieldset><fieldset class="ar-menu-group"><div class="ar-button-row"><button data-action="reset-all-menu" class="ar-menu-fullwidth-btn ar-menu-reset-btn">${ ICONS.reset }<span class="ar-menu-text">Reset All Menu Settings</span></button><button id="ar-menu-close-button" data-action="close-menu" class="ar-menu-fullwidth-btn">${ ICONS.close }<span class="ar-menu-text">Close Menu</span></button></div></fieldset>`;
		document.body.appendChild(p)
	},
	_toggleFeature: function (bodyClassName, buttonElement, logMessageBase) {
		const body = document.body;
		body.classList.toggle(bodyClassName);
		const isActive = body.classList.contains(bodyClassName);
		buttonElement.classList.toggle('ar-menu-btn-active', isActive);
		this.logMenuChange(logMessageBase, isActive);
		const parentFieldset = buttonElement.closest('fieldset.ar-menu-group');
		if (isActive && parentFieldset && !buttonElement.classList.contains('ar-menu-reset-btn')) {
			Array.from(parentFieldset.querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(btn => {
				if (btn !== buttonElement && ![
						'text-spacing-letter',
						'text-spacing-word',
						'text-spacing-line',
						'highlight-links',
						'highlight-headings'
					].includes(buttonElement.dataset.action))
					btn.classList.remove('ar-menu-btn-active')
			})
		}
	},
	handleAction: function (action, targetButton) {
		if (action === 'close-menu') {
			this.toggleMenu();
			return
		}
		const elementsForFontAdjust = getElementsForMenuTextStyleAdjustments();
		if (action === 'increase-font') {
			this.currentFontSizeMultiplier = Math.min(AR_CONFIG.MAX_FONT_SIZE_ADJUSTMENT_MULTIPLIER, this.currentFontSizeMultiplier + AR_CONFIG.DEFAULT_FONT_SIZE_ADJUSTMENT_INCREMENT);
			this.applyFontSize(elementsForFontAdjust)
		} else if (action === 'decrease-font') {
			this.currentFontSizeMultiplier = Math.max(AR_CONFIG.MIN_FONT_SIZE_ADJUSTMENT_MULTIPLIER, this.currentFontSizeMultiplier - AR_CONFIG.DEFAULT_FONT_SIZE_ADJUSTMENT_INCREMENT);
			this.applyFontSize(elementsForFontAdjust)
		} else if (action === 'reset-font') {
			this.currentFontSizeMultiplier = 1;
			this.applyFontSize(elementsForFontAdjust, true);
			const pf = targetButton.closest('fieldset');
			if (pf)
				Array.from(pf.querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(b => b.classList.remove('ar-menu-btn-active'))
		} else {
			const bodyEl = document.body;
			const pf = targetButton.closest('fieldset.ar-menu-group');
			const setActive = btnEl => {
				if (pf)
					Array.from(pf.querySelectorAll('button:not(.ar-menu-reset-btn):not(.ar-menu-fullwidth-btn)')).forEach(b => b.classList.remove('ar-menu-btn-active'));
				if (btnEl && !btnEl.classList.contains('ar-menu-reset-btn') && !btnEl.classList.contains('ar-menu-fullwidth-btn'))
					btnEl.classList.add('ar-menu-btn-active')
			};
			switch (action) {
			case 'contrast-high':
				this.applyContrastMode(AR_CONFIG.HIGH_CONTRAST_MODE_CLASS_NAME, targetButton);
				setActive(targetButton);
				break;
			case 'contrast-inverted':
				this.applyContrastMode(AR_CONFIG.INVERTED_CONTRAST_MODE_CLASS_NAME, targetButton);
				setActive(targetButton);
				break;
			case 'contrast-grayscale':
				this.applyContrastMode(AR_CONFIG.GRAYSCALE_CONTRAST_MODE_CLASS_NAME, targetButton);
				setActive(targetButton);
				break;
			case 'saturation-low':
				this.applySaturation(AR_CONFIG.SATURATION_FILTER_CLASS_NAME, targetButton);
				setActive(targetButton);
				break;
			case 'reset-contrast':
				this.applyContrastMode('default', targetButton);
				this.applySaturation('default', targetButton);
				if (pf)
					Array.from(pf.querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(b => b.classList.remove('ar-menu-btn-active'));
				break;
			case 'text-spacing-letter':
				this._toggleFeature(AR_CONFIG.INCREASED_LETTER_SPACING_CLASS_NAME, targetButton, 'Letter spacing');
				break;
			case 'text-spacing-word':
				this._toggleFeature(AR_CONFIG.INCREASED_WORD_SPACING_CLASS_NAME, targetButton, 'Word spacing');
				break;
			case 'text-spacing-line':
				this._toggleFeature(AR_CONFIG.INCREASED_LINE_HEIGHT_CLASS_NAME, targetButton, 'Line height');
				break;
			case 'text-spacing-reset':
				bodyEl.classList.remove(AR_CONFIG.INCREASED_LETTER_SPACING_CLASS_NAME, AR_CONFIG.INCREASED_WORD_SPACING_CLASS_NAME, AR_CONFIG.INCREASED_LINE_HEIGHT_CLASS_NAME);
				if (pf)
					Array.from(pf.querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(b => b.classList.remove('ar-menu-btn-active'));
				this.logMenuChange('Text spacing reset', true);
				break;
			case 'text-align-left':
				this.applyTextAlign('left', targetButton);
				setActive(targetButton);
				break;
			case 'text-align-center':
				this.applyTextAlign('center', targetButton);
				setActive(targetButton);
				break;
			case 'text-align-reset':
				this.applyTextAlign('reset', targetButton);
				if (pf)
					Array.from(pf.querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(b => b.classList.remove('ar-menu-btn-active'));
				break;
			case 'highlight-links':
				this._toggleFeature(AR_CONFIG.HIGHLIGHTED_LINKS_CLASS_NAME, targetButton, 'Highlight links');
				break;
			case 'highlight-headings':
				this._toggleFeature(AR_CONFIG.HIGHLIGHTED_HEADINGS_CLASS_NAME, targetButton, 'Highlight headings');
				break;
			case 'reset-highlights':
				bodyEl.classList.remove(AR_CONFIG.HIGHLIGHTED_LINKS_CLASS_NAME, AR_CONFIG.HIGHLIGHTED_HEADINGS_CLASS_NAME);
				if (pf)
					Array.from(pf.querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(b => b.classList.remove('ar-menu-btn-active'));
				this.logMenuChange('Highlight reset', true);
				break;
			case 'toggle-reading-line':
				this.toggleReadingGuide('line', targetButton);
				break;
			case 'toggle-reading-mask':
				this.toggleReadingGuide('mask', targetButton);
				break;
			case 'toggle-dyslexia-font':
				this.toggleDyslexiaFont(targetButton);
				break;
			case 'stop-animations':
				this.toggleAnimations(targetButton);
				break;
			case 'reset-all-menu':
				this.handleAction('reset-font', document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="reset-font"]`));
				this.handleAction('reset-contrast', document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="reset-contrast"]`));
				this.handleAction('text-spacing-reset', document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="text-spacing-reset"]`));
				this.handleAction('text-align-reset', document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="text-align-reset"]`));
				this.handleAction('reset-highlights', document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="reset-highlights"]`));
				if (ar_activeReadingGuideType)
					this.toggleReadingGuide(ar_activeReadingGuideType, document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action^="toggle-reading-"]`));
				if (this.isDyslexiaFontActive)
					this.toggleDyslexiaFont(document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="toggle-dyslexia-font"]`));
				if (bodyEl.classList.contains(AR_CONFIG.ANIMATIONS_STOPPED_CLASS_NAME))
					this.toggleAnimations(document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="stop-animations"]`));
				Array.from(document.querySelectorAll(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } button.ar-menu-btn-active`)).forEach(btn => btn.classList.remove('ar-menu-btn-active'));
				this.logMenuChange('Reset all menu settings', true);
				break
			}
		}
	},
	toggleMenu: function () {
		const p = document.getElementById(AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID), btn = document.getElementById(AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID);
		if (!p || !btn)
			return;
		this.isOpen = !this.isOpen;
		p.style.display = this.isOpen ? 'block' : 'none';
		p.classList.toggle('ar-menu-open', this.isOpen);
		p.setAttribute('aria-hidden', String(!this.isOpen));
		btn.setAttribute('aria-expanded', String(this.isOpen));
		if (this.isOpen) {
			const firstFocusableButton = p.querySelector('button:not([disabled])');
			if (firstFocusableButton)
				firstFocusableButton.focus()
		} else {
			btn.focus()
		}
	},
	applyFontSize: function (elements, reset) {
		elements.forEach(el => {
			const styleProp = 'font-size';
			if (reset) {
				ar_restoreOriginalInlineStyle(el, styleProp)
			} else {
				if (!ar_originalElementStylesMap.has(el) || !ar_originalElementStylesMap.get(el).hasOwnProperty(styleProp)) {
					ar_storeOriginalInlineStyle(el, styleProp)
				}
				const originalInlineStyle = ar_originalElementStylesMap.get(el) ? ar_originalElementStylesMap.get(el)[styleProp] : null;
				let baseSize = originalInlineStyle && parseFloat(originalInlineStyle) ? parseFloat(originalInlineStyle) : parseFloat(window.getComputedStyle(el).fontSize);
				if (!isNaN(baseSize))
					el.style.setProperty(styleProp, `${ baseSize * this.currentFontSizeMultiplier }px`, 'important')
			}
		});
		this.logMenuChange(`Font size ${ reset ? 'reset.' : `adjusted by ${ this.currentFontSizeMultiplier.toFixed(1) }x.` }`, !reset)
	},
	applyContrastMode: function (modeClass, button) {
		document.body.classList.remove(AR_CONFIG.HIGH_CONTRAST_MODE_CLASS_NAME, AR_CONFIG.INVERTED_CONTRAST_MODE_CLASS_NAME, AR_CONFIG.GRAYSCALE_CONTRAST_MODE_CLASS_NAME);
		if (modeClass !== 'default')
			document.body.classList.add(modeClass);
		this.activeContrastModeClassName = modeClass;
		if (button && button.closest('fieldset')) {
			Array.from(button.closest('fieldset').querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(btn => btn.classList.remove('ar-menu-btn-active'));
			if (modeClass !== 'default' && !button.classList.contains('ar-menu-reset-btn'))
				button.classList.add('ar-menu-btn-active')
		}
		this.logMenuChange(`Contrast mode to ${ modeClass }`, modeClass !== 'default')
	},
	applySaturation: function (modeClass, button) {
		document.body.classList.remove(AR_CONFIG.SATURATION_FILTER_CLASS_NAME);
		if (modeClass !== 'default')
			document.body.classList.add(modeClass);
		if (button && button.closest('fieldset')) {
			Array.from(button.closest('fieldset').querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(btn => btn.classList.remove('ar-menu-btn-active'));
			if (modeClass !== 'default' && !button.classList.contains('ar-menu-reset-btn') && button.dataset.action === 'saturation-low')
				button.classList.add('ar-menu-btn-active')
		}
		this.logMenuChange(`Saturation to ${ modeClass }`, modeClass !== 'default')
	},
	applyTextAlign: function (align, button) {
		const body = document.body;
		[
			'left',
			'center'
		].forEach(a => body.classList.remove(`${ AR_CONFIG.TEXT_ALIGNMENT_CLASS_NAME_PREFIX }${ a }`));
		if (align !== 'reset') {
			body.classList.add(`${ AR_CONFIG.TEXT_ALIGNMENT_CLASS_NAME_PREFIX }${ align }`);
			if (button && button.closest('fieldset')) {
				Array.from(button.closest('fieldset').querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(btn => btn.classList.remove('ar-menu-btn-active'));
				button.classList.add('ar-menu-btn-active')
			}
		} else {
			if (button && button.closest('fieldset')) {
				Array.from(button.closest('fieldset').querySelectorAll('button:not(.ar-menu-reset-btn)')).forEach(btn => btn.classList.remove('ar-menu-btn-active'))
			}
		}
		this.logMenuChange(`Text align to ${ align }`, align !== 'reset')
	},
	toggleReadingGuide: function (type, button) {
		const otherButtonType = type === 'line' ? 'mask' : 'line';
		const otherButton = document.querySelector(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } [data-action="toggle-reading-${ otherButtonType }"]`);
		if (ar_activeReadingGuideType === type) {
			if (type === 'line' && this.readingGuideLineElement) {
				this.readingGuideLineElement.remove();
				this.readingGuideLineElement = null;
				document.removeEventListener('mousemove', this.updateReadingGuideLineBound)
			} else if (type === 'mask' && this.readingMaskTopElement) {
				this.readingMaskTopElement.remove();
				this.readingMaskBottomElement.remove();
				this.readingMaskTopElement = null;
				this.readingMaskBottomElement = null;
				document.removeEventListener('mousemove', this.updateReadingMaskBound)
			}
			if (button)
				button.classList.remove('ar-menu-btn-active');
			ar_activeReadingGuideType = null
		} else {
			if (ar_activeReadingGuideType)
				this.toggleReadingGuide(ar_activeReadingGuideType, otherButton);
			if (type === 'line') {
				this.readingGuideLineElement = document.createElement('div');
				this.readingGuideLineElement.id = AR_CONFIG.READING_LINE_ELEMENT_ID;
				document.body.appendChild(this.readingGuideLineElement);
				this.updateReadingGuideLineBound = this.updateReadingGuide.bind(this, 'line');
				document.addEventListener('mousemove', this.updateReadingGuideLineBound)
			} else if (type === 'mask') {
				this.readingMaskTopElement = document.createElement('div');
				this.readingMaskTopElement.id = 'ar-reading-mask-top';
				this.readingMaskTopElement.className = AR_CONFIG.READING_MASK_ELEMENT_ID;
				this.readingMaskBottomElement = document.createElement('div');
				this.readingMaskBottomElement.id = 'ar-reading-mask-bottom';
				this.readingMaskBottomElement.className = AR_CONFIG.READING_MASK_ELEMENT_ID;
				document.body.appendChild(this.readingMaskTopElement);
				document.body.appendChild(this.readingMaskBottomElement);
				this.updateReadingMaskBound = this.updateReadingGuide.bind(this, 'mask');
				document.addEventListener('mousemove', this.updateReadingMaskBound)
			}
			if (button)
				button.classList.add('ar-menu-btn-active');
			ar_activeReadingGuideType = type
		}
		this.logMenuChange(`Reading guide (${ type })`, ar_activeReadingGuideType === type)
	},
	updateReadingGuide: function (type, e) {
		if (type === 'line' && this.readingGuideLineElement) {
			this.readingGuideLineElement.style.top = `${ e.clientY - Math.round(parseFloat(window.getComputedStyle(this.readingGuideLineElement).height) / 2) }px`
		} else if (type === 'mask' && this.readingMaskTopElement && this.readingMaskBottomElement) {
			const maskHeight = Math.max(30, Math.round(window.innerHeight * 0.1));
			this.readingMaskTopElement.style.height = `${ e.clientY - maskHeight / 2 }px`;
			this.readingMaskBottomElement.style.height = `${ window.innerHeight - (e.clientY + maskHeight / 2) }px`
		}
	},
	toggleDyslexiaFont: function (button) {
		const body = document.body;
		this.isDyslexiaFontActive = !this.isDyslexiaFontActive;
		if (this.isDyslexiaFontActive) {
			if (!document.getElementById('ar-dyslexia-font-stylesheet')) {
				const fontLink = document.createElement('link');
				fontLink.id = 'ar-dyslexia-font-stylesheet';
				fontLink.rel = 'stylesheet';
				fontLink.href = AR_CONFIG.DYSLEXIA_FRIENDLY_FONT_STYLESHEET_URL;
				document.head.appendChild(fontLink)
			}
			body.classList.add(AR_CONFIG.DYSLEXIA_FRIENDLY_FONT_CLASS_NAME);
			if (button)
				button.classList.add('ar-menu-btn-active')
		} else {
			body.classList.remove(AR_CONFIG.DYSLEXIA_FRIENDLY_FONT_CLASS_NAME);
			if (button)
				button.classList.remove('ar-menu-btn-active')
		}
		this.logMenuChange('Dyslexia friendly font', this.isDyslexiaFontActive)
	},
	toggleAnimations: function (button) {
		const stoppedClass = AR_CONFIG.ANIMATIONS_STOPPED_CLASS_NAME;
		const currentlyStopped = document.body.classList.contains(stoppedClass);
		document.body.classList.toggle(stoppedClass);
		if (button)
			button.classList.toggle('ar-menu-btn-active', !currentlyStopped);
		const gifs = document.querySelectorAll('img[src$=".gif"]');
		gifs.forEach(gif => {
			if (!currentlyStopped) {
				if (!gif.dataset.originalSrc && gif.src.endsWith('.gif')) {
					const canvas = document.createElement('canvas');
					try {
						if (gif.complete && gif.naturalWidth > 0 && gif.naturalHeight > 0) {
							canvas.width = gif.naturalWidth;
							canvas.height = gif.naturalHeight;
							const ctx = canvas.getContext('2d');
							if (ctx)
								ctx.drawImage(gif, 0, 0, canvas.width, canvas.height);
							gif.dataset.originalSrc = gif.src;
							gif.src = canvas.toDataURL('image/png')
						} else if (gif.width > 0 && gif.height > 0) {
							canvas.width = gif.width;
							canvas.height = gif.height;
							const ctx = canvas.getContext('2d');
							if (ctx)
								ctx.drawImage(gif, 0, 0, canvas.width, canvas.height);
							gif.dataset.originalSrc = gif.src;
							gif.src = canvas.toDataURL('image/png')
						}
					} catch (e) {
						console.warn('Could not pause GIF:', gif.src, e)
					}
				}
			} else {
				if (gif.dataset.originalSrc) {
					gif.src = gif.dataset.originalSrc;
					delete gif.dataset.originalSrc
				}
			}
		});
		this.logMenuChange(`Animations ${ document.body.classList.contains(stoppedClass) ? 'stopped/paused.' : 'resumed.' }`, true)
	},
	attachEventListeners: function () {
		const btn = document.getElementById(AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID), pnl = document.getElementById(AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID);
		if (btn)
			btn.addEventListener('click', this.toggleMenu.bind(this));
		if (pnl) {
			pnl.addEventListener('click', e => {
				const target = e.target.closest('button');
				if (target && target.dataset.action)
					this.handleAction(target.dataset.action, target)
			});
			pnl.addEventListener('keydown', e => {
				if (e.key === 'Escape' && this.isOpen)
					this.toggleMenu()
			})
		}
	},
	logMenuChange: function (actionDescription, isActive) {
		ar_logAccessibilityIssue('Info', `Accessibility Menu: ${ actionDescription }${ typeof isActive === 'boolean' ? isActive ? ' enabled.' : ' disabled.' : '.' }`, null, '', 'Operable', 'User Interface Customization', true, 'User')
	}
};
function ar_storeOriginalInlineStyle(element, cssProperty) {
	if (!ar_originalElementStylesMap.has(element))
		ar_originalElementStylesMap.set(element, {});
	const elementOriginalStyles = ar_originalElementStylesMap.get(element);
	if (elementOriginalStyles[cssProperty] === undefined)
		elementOriginalStyles[cssProperty] = element.style.getPropertyValue(cssProperty)
}
function ar_restoreOriginalInlineStyle(element, cssProperty) {
	if (ar_originalElementStylesMap.has(element)) {
		const elementOriginalStyles = ar_originalElementStylesMap.get(element);
		if (elementOriginalStyles[cssProperty] !== undefined)
			element.style.setProperty(cssProperty, elementOriginalStyles[cssProperty]);
		else
			element.style.removeProperty(cssProperty)
	}
}
function ar_getElementsForMenuTextStyleAdjustments() {
	return Array.from(document.querySelectorAll(AR_SELECTOR_STRINGS.TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU))
}
const AR_CheckModules = {
	checkContentStructure: function (globalState) {
		ar_logSection('Structure and Relationships');
		document.querySelectorAll('div, span, p').forEach(el => {
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const style = window.getComputedStyle(el);
				const fontSize = parseFloat(style.fontSize);
				const fontWeight = style.fontWeight;
				const isSemanticallyHeading = [
					'H1',
					'H2',
					'H3',
					'H4',
					'H5',
					'H6'
				].includes(el.tagName);
				const hasHeadingRole = el.getAttribute('role') === 'heading';
				if (fontSize >= 20 && (parseInt(fontWeight) >= 600 || fontWeight === 'bold' || fontWeight === 'bolder') && !isSemanticallyHeading && el.textContent.trim().length > 0) {
					if (!hasHeadingRole) {
						let level = 2;
						const h1 = document.querySelector('h1');
						if (h1) {
							const h1FontSize = parseFloat(window.getComputedStyle(h1).fontSize);
							if (fontSize > h1FontSize * 0.85)
								level = 1;
							else if (fontSize < h1FontSize * 0.6)
								level = 3
						}
						ar_setAttributeAndLog(el, 'role', 'heading', 'Moderate', 'Visually strong text not semantic heading. Auto-added role="heading".', 'Use H1-H6 or ensure correct aria-level.', 'Operable', '2.4.6 Headings and Labels', 'AA');
						ar_setAttributeAndLog(el, 'aria-level', level.toString(), 'Info', `Auto-set aria-level="${ level }". Review.`, 'Ensure aria-level matches visual hierarchy.', 'Operable', '2.4.6 Headings and Labels', 'AA')
					} else if (hasHeadingRole && !el.hasAttribute('aria-level')) {
						ar_setAttributeAndLog(el, 'aria-level', '2', 'Minor', 'role="heading" without aria-level. Auto-set to "2".', 'Provide aria-level.', 'Operable', '2.4.6 Headings and Labels', 'AA')
					}
				}
				const textContent = (el.textContent || '').trim();
				if ((textContent.startsWith('\u2022 ') || textContent.startsWith('- ') || /^\d+\.\s/.test(textContent)) && !el.closest('ul, ol, dl')) {
					let nextSibling = el.nextElementSibling;
					let similarSiblings = [el];
					while (nextSibling && ((nextSibling.textContent || '').trim().startsWith('\u2022 ') || (nextSibling.textContent || '').trim().startsWith('- ') || /^\d+\.\s/.test((nextSibling.textContent || '').trim())) && !nextSibling.closest('ul,ol,dl')) {
						similarSiblings.push(nextSibling);
						nextSibling = nextSibling.nextElementSibling
					}
					if (similarSiblings.length > 1) {
						const listType = /^\d+\.\s/.test(textContent) ? 'ol' : 'ul';
						const newList = document.createElement(listType);
						const parent = el.parentNode;
						parent.insertBefore(newList, el);
						similarSiblings.forEach(sibling => {
							const listItem = document.createElement('li');
							listItem.appendChild(sibling);
							newList.appendChild(listItem)
						});
						ar_logAccessibilityIssue('Moderate', `Wrapped ${ similarSiblings.length } pseudo-list items in <${ listType }>.`, newList, 'Review auto-generated list.', 'Perceivable', '1.3.1 Info and Relationships', true, 'A')
					}
				}
				if (el.tagName === 'P' && el.children.length === 1 && el.children[0].tagName === 'IMG') {
					const img = el.children[0];
					if (((img.alt || '').trim() === '' || img.getAttribute('role') === 'presentation') && !ar_hasAccessibleNameForElement(img))
						ar_setAttributeAndLog(el, 'role', 'presentation', 'Minor', 'Paragraph with only decorative image. Added role="presentation".', 'If P is purely decorative container, role="presentation" is ok.', 'Perceivable', '1.3.1', true, 'A')
				}
			} catch (e) {
				console.error('Error: ContentStructure:', e, el)
			}
		});
		console.groupEnd()
	},
	checkMediaIntegrity: function () {
		ar_logSection('Media Integrity (Images, Links)');
		document.querySelectorAll('img').forEach(img => {
			try {
				if (ar_isVisuallyHidden(img) && !img.hasAttribute('alt')) {
					ar_setAttributeAndLog(img, 'alt', '', 'Info', 'Hidden image missing alt. Auto-set alt="".', 'Ensure decorative hidden images have empty alt.', 'Perceivable', '1.1.1', 'A');
					return
				}
				if (!img.complete || img.naturalWidth === 0) {
					const originalSrc = img.src;
					const altText = (img.alt || 'Broken Image').trim();
					const placeholderSrc = AR_CONFIG.PLACEHOLDER_IMAGE_URL.replace('{width}', Math.max(50, img.width || 150).toString()).replace('{height}', Math.max(50, img.height || 100).toString()).replace('{text}', encodeURIComponent(altText.substring(0, 50)));
					img.setAttribute('data-original-src', originalSrc);
					img.src = placeholderSrc;
					ar_logAccessibilityIssue('Critical', 'Broken image. Replaced with placeholder.', img, `Original src: ${ originalSrc }. Verify src or ensure alt is sufficient.`, 'Perceivable', '1.1.1', true, 'A')
				}
			} catch (e) {
				console.error('Error: MediaIntegrity Images:', e, img)
			}
		});
		document.querySelectorAll('a[href]').forEach(a => {
			try {
				if (ar_isVisuallyHidden(a))
					return;
				const href = a.getAttribute('href');
				if (!ar_hasAccessibleNameForElement(a) && (href === '#' || href === '' || !href)) {
					const titleAttr = a.getAttribute('title');
					if (titleAttr && titleAttr.trim().length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT) {
						ar_setAttributeAndLog(a, 'aria-label', titleAttr.trim(), 'Minor', 'Empty link auto-labeled from title.', 'Review auto-label.', 'Perceivable', '2.4.4 Link Purpose', 'A')
					} else {
						const rect = a.getBoundingClientRect();
						if (rect.width < 10 && rect.height < 10 && rect.width > 0 && rect.height > 0)
							ar_setAttributeAndLog(a, 'aria-hidden', 'true', 'Minor', 'Small, empty, non-functional link auto-hidden.', 'Remove or provide name if functional.', 'Perceivable', '2.4.4', true, 'A');
						else
							ar_setAttributeAndLog(a, 'aria-label', 'Link - Description Needed', 'Critical', 'Empty link, auto-added generic aria-label.', 'Provide descriptive name.', 'Perceivable', '2.4.4', true, 'A')
					}
				}
			} catch (e) {
				console.error('Error: MediaIntegrity Links:', e, a)
			}
		});
		console.groupEnd()
	},
	checkImageAltText: function () {
		ar_logSection('Image Alternative Text');
		document.querySelectorAll('img').forEach(img => {
			try {
				if (ar_isVisuallyHidden(img) && !img.hasAttribute('alt'))
					return;
				if (img.complete && img.naturalWidth === 0 && !img.src.startsWith('data:image/svg+xml') && !img.src.startsWith('https://placehold.co'))
					return;
				if (!img.hasAttribute('alt')) {
					let altText = 'Image (description needed)';
					const src = (img.src || '').toLowerCase();
					const className = (img.className || '').toLowerCase();
					if (AR_CONFIG.AVATAR_KEYWORDS.some(kw => src.includes(kw) || className.includes(kw)))
						altText = 'User avatar';
					else {
						const fnMatch = src.match(/[^/\\&\?]+\.\w{3,4}(?=([\?&].*$|$))/);
						if (fnMatch) {
							const fn = fnMatch[0].substring(0, fnMatch[0].lastIndexOf('.')).replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
							if (fn.length > 3 && fn.length < 50 && !/\d{4,}/.test(fn))
								altText = fn.charAt(0).toUpperCase() + fn.slice(1)
						}
					}
					ar_setAttributeAndLog(img, 'alt', altText, 'Critical', `Image missing alt. Auto-set to "${ altText }".`, '**Manual review required.**', 'Perceivable', '1.1.1', 'A')
				} else if (img.alt.trim() === '') {
					const src = (img.src || '').toLowerCase();
					if (/(chart|graph|diagram|stats|figure)/.test(src) && (img.offsetWidth > 50 || img.offsetHeight > 50))
						ar_setAttributeAndLog(img, 'alt', 'Image (description needed, was decorative)', 'Moderate', `alt="" but src suggests informative. Auto-set placeholder.`, 'Verify if decorative.', 'Perceivable', '1.1.1', 'A');
					if (/(spacer|1x1)\.(gif|png|jpg)/i.test(src) && img.getAttribute('role') !== 'presentation')
						ar_setAttributeAndLog(img, 'role', 'presentation', 'Minor', 'Spacer image with alt="". Auto-added role="presentation".', 'Spacers: alt="" and role="presentation".', 'Perceivable', '1.1.1', true, 'A')
				} else {
					const alt = img.alt.trim();
					const filename = (img.src || '').split('/').pop().split('.')[0].replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
					if (alt.toLowerCase() === filename.toLowerCase() && alt.length > 3)
						ar_setAttributeAndLog(img, 'alt', `Image: ${ alt } (description needed)`, 'Minor', `Alt is filename "${ alt }". Auto-updated.`, 'Replace filename with description.', 'Perceivable', '1.1.1', 'A')
				}
			} catch (e) {
				console.error('Error: ImageAltText:', e, img)
			}
		});
		console.groupEnd()
	},
	checkIframeTitles: function () {
		ar_logSection('Iframe Titles');
		document.querySelectorAll('iframe').forEach(iframe => {
			try {
				if (!iframe.title || iframe.title.trim() === '') {
					let title = 'Embedded content';
					if (iframe.src) {
						try {
							const url = new URL(iframe.src);
							if (url.hostname.includes('youtube.com') || url.hostname.includes('youtu.be'))
								title = 'YouTube video player';
							else if (url.hostname.includes('vimeo.com'))
								title = 'Vimeo video player';
							else if (url.hostname.includes('maps.google') || url.hostname.includes('google.com/maps'))
								title = 'Google Maps embed';
							else
								title = `Embedded content from ${ url.hostname }`
						} catch (e) {
						}
					}
					ar_setAttributeAndLog(iframe, 'title', title, 'Critical', `Iframe missing title. Auto-set to "${ title }".`, '**Manual review required.**', 'Operable', '2.4.1, 4.1.2', 'A')
				}
			} catch (e) {
				console.error('Error: IframeTitles:', e, iframe)
			}
		});
		console.groupEnd()
	},
	checkTableAccessibility: function () {
		ar_logSection('Table Accessibility');
		document.querySelectorAll('table').forEach(table => {
			try {
				if (ar_isVisuallyHidden(table))
					return;
				if (!table.querySelector('caption') && table.querySelectorAll('th').length > 0 && table.getAttribute('role') !== 'presentation' && table.getAttribute('role') !== 'none') {
					const cap = document.createElement('caption');
					cap.textContent = 'Table data (auto-caption)';
					Object.assign(cap.style, {
						position: 'absolute',
						left: '-9999px'
					});
					table.prepend(cap);
					ar_logAccessibilityIssue('Moderate', 'Data table missing <caption>. Auto-added generic hidden caption.', table, '**Manual review required.**', 'Perceivable', '1.3.1', true, 'A')
				}
				const th = table.querySelectorAll('th').length;
				const td = table.querySelectorAll('td').length;
				const border = table.getAttribute('border');
				if (th === 0 && td > 0 && (border === '0' || !border) && !table.hasAttribute('role') && !table.hasAttribute('summary') && !table.querySelector('caption')) {
					if (table.rows.length < 5 && Array.from(table.rows).every(r => r.cells.length < 5))
						ar_setAttributeAndLog(table, 'role', 'presentation', 'Minor', 'Table appears for layout. Auto-added role="presentation".', 'If data table, remove role & add semantics.', 'Perceivable', '1.3.1', true, 'A')
				}
				table.querySelectorAll('thead th').forEach(thEl => {
					if (!thEl.hasAttribute('scope'))
						ar_setAttributeAndLog(thEl, 'scope', 'col', 'Minor', '<th> in <thead> missing scope. Auto-set "col".', 'Add scope="col".', 'Perceivable', '1.3.1', 'A')
				});
				table.querySelectorAll('tbody tr > th:first-child, tfoot tr > th:first-child').forEach(thEl => {
					if (!thEl.hasAttribute('scope'))
						ar_setAttributeAndLog(thEl, 'scope', 'row', 'Minor', 'First <th> in row missing scope. Auto-set "row".', 'Add scope="row".', 'Perceivable', '1.3.1', 'A')
				})
			} catch (e) {
				console.error('Error: TableAccessibility:', e, table)
			}
		});
		console.groupEnd()
	},
	checkOverlayFocusBlocking: function () {
		ar_logSection('Overlapping Elements (Modals/Popups)');
		document.querySelectorAll('body > div, body > section, body > aside, [role="dialog"], [role="alertdialog"]').forEach(el => {
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const style = window.getComputedStyle(el);
				const rect = el.getBoundingClientRect();
				const isOverlay = (style.position === 'fixed' || style.position === 'absolute') && (rect.width >= window.innerWidth * 0.8 || rect.height >= window.innerHeight * 0.8) && parseFloat(style.zIndex) > 0 && style.display !== 'none' && style.visibility !== 'hidden';
				if (isOverlay) {
					if (el.getAttribute('aria-modal') !== 'true')
						ar_setAttributeAndLog(el, 'aria-modal', 'true', 'Critical', 'Potential modal lacks aria-modal="true". Auto-fixed.', 'Ensure focus trap & ESC.', 'Operable', '4.1.2', 'A');
					if (el.getAttribute('role') !== 'dialog' && el.getAttribute('role') !== 'alertdialog')
						ar_setAttributeAndLog(el, 'role', 'dialog', 'Critical', 'Potential modal lacks role="dialog/alertdialog". Auto-fixed.', 'Use role="dialog" or "alertdialog".', 'Operable', '4.1.2', 'A');
					if (el.getAttribute('aria-modal') === 'true') {
						let hidden = 0;
						Array.from(document.body.children).forEach(child => {
							if (child !== el && !el.contains(child) && ![
									'SCRIPT',
									'STYLE',
									'LINK'
								].includes(child.tagName) && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID) {
								if (child.getAttribute('aria-hidden') !== 'true') {
									child.setAttribute('data-ar-hidden-by-modal', child.getAttribute('aria-hidden') || 'false');
									child.setAttribute('aria-hidden', 'true');
									hidden++
								}
							}
						});
						if (hidden > 0)
							ar_logAccessibilityIssue('Info', `Modal: ${ hidden } background elements auto-set aria-hidden="true".`, el, 'Ensure undone on modal close.', 'Operable', '2.4.3', true, 'A')
					}
				}
			} catch (e) {
				console.error('Error: OverlayFocusBlocking:', e, el)
			}
		});
		console.groupEnd()
	},
	checkInteractiveElementSize: function () {
		ar_logSection('Interactive Element Size');
		document.querySelectorAll(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS).forEach(el => {
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const rect = el.getBoundingClientRect();
				if (rect.width > 0 && rect.height > 0 && (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX || rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX)) {
					const styles = {};
					const cStyle = window.getComputedStyle(el);
					if (cStyle.display === 'inline')
						styles['display'] = 'inline-block';
					if (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX)
						styles['min-width'] = `${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px`;
					if (rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX)
						styles['min-height'] = `${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px`;
					const padV = parseFloat(cStyle.paddingTop) + parseFloat(cStyle.paddingBottom);
					const padH = parseFloat(cStyle.paddingLeft) + parseFloat(cStyle.paddingRight);
					if (rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX && padV < 4)
						styles['padding-top'] = styles['padding-bottom'] = '0.3em';
					if (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX && padH < 8)
						styles['padding-left'] = styles['padding-right'] = '0.5em';
					ar_applyStylesAndLog(el, styles, 'Moderate', `Interactive element too small. Auto-adjusted.`, `Increase area to ${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }x${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px.`, 'Operable', '2.5.5 Target Size', 'AAA')
				}
			} catch (e) {
				console.error('Error: InteractiveElementSize:', e, el)
			}
		});
		console.groupEnd()
	},
	checkHoverFocusContent: function () {
		ar_logSection('Content on Hover/Focus (ARIA Attributes)');
		document.querySelectorAll('button, a[href], [role="button"], [role="link"], [role="menuitem"]').forEach(el => {
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const hasPopup = el.hasAttribute('aria-haspopup');
				const isExp = el.getAttribute('aria-expanded');
				const ctrlId = el.getAttribute('aria-controls');
				if (hasPopup) {
					const pv = el.getAttribute('aria-haspopup').toLowerCase();
					if (![
							'menu',
							'listbox',
							'tree',
							'grid',
							'dialog',
							'true'
						].includes(pv))
						ar_setAttributeAndLog(el, 'aria-haspopup', 'true', 'Moderate', `Invalid aria-haspopup. Auto-set "true".`, 'Use valid values.', 'Operable', '4.1.2', 'A')
				}
				if (ctrlId) {
					const ctrlEl = document.getElementById(ctrlId);
					if (ctrlEl) {
						const isCtrlVis = !ar_isVisuallyHidden(ctrlEl);
						if (isExp === null)
							ar_setAttributeAndLog(el, 'aria-expanded', isCtrlVis.toString(), 'Minor', `aria-controls w/o aria-expanded. Auto-fixed.`, 'Add & update aria-expanded.', 'Operable', '4.1.2', 'A');
						else if (isExp === 'true' && !isCtrlVis || isExp === 'false' && isCtrlVis)
							ar_setAttributeAndLog(el, 'aria-expanded', isCtrlVis.toString(), 'Minor', `aria-expanded mismatch. Auto-corrected.`, 'Ensure aria-expanded reflects state.', 'Operable', '4.1.2', 'A')
					} else if (isExp !== null)
						ar_logAccessibilityIssue('Moderate', `aria-controls to non-existent ID "${ ctrlId }".`, el, 'Ensure valid ID.', 'Robust', '4.1.2', false, 'A')
				} else if (isExp !== null)
					ar_logAccessibilityIssue('Minor', `aria-expanded w/o aria-controls.`, el, 'Add aria-controls if content controlled.', 'Operable', '4.1.2', false, 'A')
			} catch (e) {
				console.error('Error: HoverFocusContent:', e, el)
			}
		});
		console.log('\n\uD83D\uDCA1 Manual Verification for WCAG 1.4.13 (Content on Hover/Focus) is CRUCIAL: Dismissible, Hoverable, Persistent.');
		console.groupEnd()
	},
	checkAutoFormSubmission: function () {
		ar_logSection('Automatic Form Submission');
		document.querySelectorAll('form, input:not([type="hidden"]), select, textarea').forEach(el => {
			try {
				if (ar_isVisuallyHidden(el))
					return;
				[
					'onfocus',
					'onchange'
				].forEach(attr => {
					const val = el.getAttribute(attr);
					if (val && val.toLowerCase().includes('submit()'))
						ar_removeAttributeAndLog(el, attr, 'Minor', `${ el.tagName } with ${ attr } auto-submits. Auto-removed.`, 'Use explicit submit.', 'Operable', '3.2.2', 'A')
				})
			} catch (e) {
				console.error('Error: AutoFormSubmission:', e, el)
			}
		});
		console.groupEnd()
	},
	checkDuplicateIds: function (globalState) {
		ar_logSection('Duplicate IDs');
		document.querySelectorAll('[id]').forEach(el => {
			try {
				const id = el.id;
				if (!id)
					return;
				if (globalState.seenIds.has(id)) {
					const origEl = globalState.seenIds.get(id);
					let newId = ar_generateUniqueElementId(`dup-${ id }`);
					ar_setAttributeAndLog(el, 'id', newId, 'Critical', `Duplicate ID "#${ id }". Auto-fixed to "#${ newId }".`, `Original element:`, 'Robust', '4.1.1', 'A');
					console.warn('    Original element with ID:', origEl)
				} else {
					globalState.seenIds.set(id, el)
				}
			} catch (e) {
				console.error('Error: DuplicateIds:', e, el)
			}
		});
		console.groupEnd()
	},
	checkAccessibleNames: function () {
		ar_logSection('Accessible Names for Interactive Elements');
		document.querySelectorAll(`${ AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS }, [role="img"]`).forEach(el => {
			try {
				if (ar_isVisuallyHidden(el) || ar_hasAccessibleNameForElement(el))
					return;
				let label = '';
				const tn = el.tagName.toLowerCase();
				const type = (el.type || '').toLowerCase();
				if (el.placeholder && el.placeholder.trim())
					label = el.placeholder.trim();
				else if (el.title && el.title.trim())
					label = el.title.trim();
				else if (tn === 'input' && [
						'button',
						'submit',
						'reset'
					].includes(type) && el.value && el.value.trim())
					label = el.value.trim();
				else if (tn === 'input' && type === 'image' && el.src) {
					const fn = el.src.split('/').pop().split('.')[0].replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
					label = fn.length > 3 && fn.length < 30 ? `Submit ${ fn }` : 'Submit query';
					ar_setAttributeAndLog(el, 'alt', label, 'Moderate', `Input type="image" missing alt. Auto-set.`, '**Manual review.**', 'Perceivable', '1.1.1', 'A');
					return
				} else if (tn === 'img')
					label = 'Image (description needed)';
				else if (tn === 'a') {
					const txt = (el.textContent || '').trim();
					label = txt.length > 2 && txt.length < 50 ? `Link: ${ txt }` : 'Link - Description Needed'
				} else if (tn === 'button') {
					const txt = (el.textContent || '').trim();
					if (txt.length > 2 && txt.length < 50)
						label = txt;
					else {
						let iLbl = '';
						for (const p of AR_CONFIG.COMMON_ICON_CLASS_PREFIXES) {
							for (const c of Array.from(el.classList)) {
								if (c.startsWith(p)) {
									const pLbl = c.substring(p.length).replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ').trim();
									if (pLbl.length > 2) {
										iLbl = pLbl + ' button';
										break
									}
								}
							}
							if (iLbl)
								break
						}
						label = iLbl || 'Button - Action Needed'
					}
				}
				if (!label || label.startsWith('Unnamed'))
					label = `${ el.getAttribute('role') || tn } - Description Needed`;
				if (label.length > AR_CONFIG.MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL)
					label = label.substring(0, AR_CONFIG.MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL - 3) + '...';
				ar_setAttributeAndLog(el, 'aria-label', label, 'Moderate', `Lacked accessible name. Auto-fixed with aria-label.`, '**Manual review required.**', 'Perceivable', '2.4.4, 4.1.2', 'A')
			} catch (e) {
				console.error('Error: AccessibleNames:', e, el)
			}
		});
		console.groupEnd()
	},
	checkLangAttribute: function () {
		ar_logSection('Language Attribute (HTML)');
		const htmlEl = document.documentElement;
		if (!htmlEl.lang || !htmlEl.lang.trim())
			ar_setAttributeAndLog(htmlEl, 'lang', 'en', 'Critical', '<html> missing lang. Auto-set to "en".', 'Add lang. **Verify "en" is correct.**', 'Understandable', '3.1.1 Language of Page', 'A');
		console.groupEnd()
	},
	checkTabindexUsage: function () {
		ar_logSection('Tabindex Usage');
		document.querySelectorAll('[tabindex]').forEach(el => {
			try {
				const tabindex = parseInt(el.getAttribute('tabindex'), 10);
				if (tabindex > 0)
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Moderate', `Positive tabindex="${ tabindex }". Auto-fixed to "0".`, 'Avoid positive tabindex.', 'Operable', '2.4.3', 'A');
				const role = el.getAttribute('role');
				const isNative = el.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS);
				const intRoles = [
					'button',
					'link',
					'menuitem',
					'tab',
					'checkbox',
					'radio',
					'option',
					'switch',
					'slider',
					'treeitem'
				];
				if (role && intRoles.includes(role) && !isNative && tabindex < 0)
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Minor', `Custom control [role="${ role }"] not focusable. Auto-added tabindex="0".`, 'Ensure custom controls focusable.', 'Operable', '2.1.1', 'A');
				if (role && intRoles.includes(role) && tabindex === -1 && !el.disabled && !el.hasAttribute('aria-disabled'))
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Minor', `Active custom control [role="${ role }"] tabindex="-1". Auto-set to "0".`, 'Ensure active controls in tab order.', 'Operable', '2.1.1', 'A')
			} catch (e) {
				console.error('Error: TabindexUsage:', e, el)
			}
		});
		console.groupEnd()
	},
	checkAriaMisuse: function () {
		ar_logSection('ARIA Misuse');
		document.querySelectorAll('[aria-hidden="true"]').forEach(el => {
			try {
				const isFocusable = el.tabIndex >= 0 || el.matches(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS);
				const hasFocusableDesc = el.querySelector(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS.split(',').map(s => s.trim() + ':not([tabindex="-1"])').join(',')) !== null;
				if (isFocusable || hasFocusableDesc)
					ar_removeAttributeAndLog(el, 'aria-hidden', 'Critical', '`aria-hidden="true"` on focusable. Auto-removed.', 'Do not use on focusable.', 'Perceivable', '4.1.2', 'A')
			} catch (e) {
				console.error('Error: AriaMisuse hidden:', e, el)
			}
		});
		document.querySelectorAll('[role]').forEach(el => {
			try {
				const role = el.getAttribute('role').toLowerCase();
				const tn = el.tagName.toLowerCase();
				const map = {
					'button': 'button',
					'a': 'link',
					'input[type=button]': 'button',
					'input[type=checkbox]': 'checkbox',
					'input[type=radio]': 'radio',
					'img': 'img',
					'select': 'listbox'
				};
				let native = map[tn] || (tn.startsWith('h') && tn.length === 2 ? 'heading' : null);
				if (tn === 'input' && el.type)
					native = map[`input[type=${ el.type.toLowerCase() }]`] || native;
				if (native === role && !(tn === 'img' && role === 'presentation' && (el.alt || '').trim() !== ''))
					ar_removeAttributeAndLog(el, 'role', 'Minor', `Redundant ARIA role="${ role }" on <${ tn }>. Auto-removed.`, 'Native tag implies role.', 'Robust', '4.1.2', 'A');
				if (role === 'text' && el.matches(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS))
					ar_removeAttributeAndLog(el, 'role', 'Critical', 'Interactive element `role="text"`. Auto-removed.', 'Remove role="text".', 'Robust', '4.1.2', 'A');
				if ((role === 'presentation' || role === 'none') && (el.tabIndex >= 0 || el.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS)))
					ar_removeAttributeAndLog(el, 'role', 'Moderate', `Focusable element role="${ role }". Auto-removed.`, `Focusable elements should not have role="presentation" or "none".`, 'Robust', '4.1.2', 'A')
			} catch (e) {
				console.error('Error: AriaMisuse roles:', e, el)
			}
		});
		[
			'aria-labelledby',
			'aria-describedby'
		].forEach(attr => {
			document.querySelectorAll(`[${ attr }]`).forEach(el => {
				try {
					const ids = el.getAttribute(attr).split(/\s+/);
					const vIds = ids.filter(id => document.getElementById(id));
					if (vIds.length !== ids.length) {
						if (vIds.length > 0)
							ar_setAttributeAndLog(el, attr, vIds.join(' '), 'Minor', `${ attr } has invalid ID(s). Auto-removed invalid.`, `Ensure ${ attr } points to valid IDs.`, 'Robust', '4.1.2', 'A');
						else
							ar_removeAttributeAndLog(el, attr, 'Minor', `${ attr } only invalid ID(s). Auto-removed attr.`, `Ensure ${ attr } points to valid IDs.`, 'Robust', '4.1.2', 'A')
					}
				} catch (e) {
					console.error(`Error: AriaMisuse ${ attr }:`, e, el)
				}
			})
		});
		console.groupEnd()
	},
	checkContrastRatioForAllElements: function (targetElement = null) {
		if (!targetElement)
			ar_logSection('Text Contrast Ratios');
		const elements = targetElement ? [targetElement] : Array.from(document.querySelectorAll(AR_SELECTOR_STRINGS.TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU));
		elements.forEach(el => {
			try {
				if (ar_isVisuallyHidden(el) || el.textContent.trim().length === 0 || el.offsetWidth === 0 || el.offsetHeight === 0 || el.closest(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }`))
					return;
				const style = window.getComputedStyle(el);
				const fgOriginalRgba = ar_parseCssColorString(style.color);
				if (fgOriginalRgba[3] === 0)
					return;
				const bgRgba = ar_getEffectiveBackgroundColorOfElement(el);
				const perceivedFgRgba = ar_blendColors(fgOriginalRgba, bgRgba);
				const currentContrast = ar_getContrastRatioBetweenColors(perceivedFgRgba, bgRgba);
				const requiredContrast = ar_isTextLargeForWCAG(el) ? AR_CONFIG.CONTRAST_RATIO_AA_LARGE_TEXT : AR_CONFIG.CONTRAST_RATIO_AA_NORMAL_TEXT;
				const originalFgColorString = `rgb(${ fgOriginalRgba.slice(0, 3).join(',') }${ fgOriginalRgba[3] < 1 ? `, ${ fgOriginalRgba[3] }` : '' })`;
				const originalBgColorString = `rgb(${ bgRgba.slice(0, 3).join(',') })`;
				const initialFailureKey = `${ el.id || el.dataset.arGeneratedId || ar_generateUniqueElementId('contrast-el-') }::CONTRAST_FAILURE_INITIAL::${ originalFgColorString }-${ originalBgColorString }`;
				if (currentContrast < requiredContrast) {
					console.groupCollapsed(`DEBUG: Low contrast detected for element: ${ el.tagName } (Contrast: ${ currentContrast.toFixed(2) }:1, Required: ${ requiredContrast }:1)`);
					console.log(`Element:`, el);
					console.log(`Element Tag: ${ el.tagName }, ID: ${ el.id || 'N/A' }, Class: ${ el.className || 'N/A' }`);
					console.log(`Element outerHTML:`, el.outerHTML);
					console.log(`Element textContent: "${ el.textContent.trim().substring(0, 100) }..."`);
					console.log(`Element inline style.color: ${ el.style.color || 'N/A' }`);
					console.log(`Element inline style.cssText: "${ el.style.cssText || 'N/A' }"`);
					console.log(`Computed FG (from getComputedStyle): ${ style.color }`);
					console.log(`Computed BG (from getComputedStyle): ${ window.getComputedStyle(el).backgroundColor }`);
					console.log(`Effective BG (from ar_getEffectiveBackgroundColorOfElement): rgb(${ bgRgba.slice(0, 3).join(',') })`);
					console.log(`Perceived FG (after blending with BG): rgb(${ perceivedFgRgba.slice(0, 3).join(',') })`);
					console.groupEnd();
					if (!ar_loggedIssuesTracker.has(initialFailureKey)) {
						ar_logAccessibilityIssue('Critical', `Low contrast ${ currentContrast.toFixed(2) }:1 (req ${ requiredContrast }:1).`, el, `Original: ${ originalFgColorString } on ${ originalBgColorString }. Attempting autofix.`, 'Perceivable', '1.4.3 Contrast (Minimum)', false, 'AA')
					}
					let newFgColorString = `rgb(${ fgOriginalRgba.slice(0, 3).join(',') })`;
					let fixedContrast = ar_getContrastRatioBetweenColors(ar_parseCssColorString(newFgColorString), bgRgba);
					let fixStrategy = 'force_opaque_text';
					let successfullyFixed = false;
					if (fgOriginalRgba[3] < 1 || fixedContrast < requiredContrast) {
						ar_applyStylesAndLog(el, { 'color': newFgColorString }, 'Info', `Autofix attempt 1: Forcing text color to opaque ${ newFgColorString }.`, `Original: ${ originalFgColorString }.`, 'Perceivable', '1.4.3', 'AA');
						let reEvaluatedFgRgba = ar_parseCssColorString(window.getComputedStyle(el).color);
						fixedContrast = ar_getContrastRatioBetweenColors(reEvaluatedFgRgba, bgRgba);
						if (fixedContrast >= requiredContrast) {
							successfullyFixed = true;
							ar_loggedIssuesTracker.add(initialFailureKey)
						}
					}
					if (!successfullyFixed) {
						newFgColorString = ar_getLuminanceFromRgb(bgRgba) < 0.5 ? 'rgb(255,255,255)' : 'rgb(0,0,0)';
						fixedContrast = ar_getContrastRatioBetweenColors(ar_parseCssColorString(newFgColorString), bgRgba);
						fixStrategy = 'simple_bw_text';
						ar_applyStylesAndLog(el, { 'color': newFgColorString }, 'Info', `Autofix attempt 2: Setting text color to ${ newFgColorString } with !important.`, `Original: ${ originalFgColorString }.`, 'Perceivable', '1.4.3', 'AA');
						let reEvaluatedFgRgba = ar_parseCssColorString(window.getComputedStyle(el).color);
						fixedContrast = ar_getContrastRatioBetweenColors(reEvaluatedFgRgba, bgRgba);
						if (fixedContrast >= requiredContrast) {
							successfullyFixed = true;
							ar_loggedIssuesTracker.add(initialFailureKey)
						}
					}
					if (!successfullyFixed) {
						fixStrategy = 'iterative_text_hsl';
						let adjRgb = [...fgOriginalRgba.slice(0, 3)];
						const isBgDark = ar_getLuminanceFromRgb(bgRgba) < 0.5;
						for (let i = 0; i < AR_CONFIG.CONTRAST_ADJUSTMENT_STEPS; i++) {
							let [h, s, l] = ar_rgbToHsl(...adjRgb);
							l = isBgDark ? Math.min(1, l + AR_CONFIG.CONTRAST_ADJUSTMENT_AMOUNT * (i / 3 + 1)) : Math.max(0, l - AR_CONFIG.CONTRAST_ADJUSTMENT_AMOUNT * (i / 3 + 1));
							adjRgb = ar_hslToRgb(h, s, l);
							newFgColorString = `rgb(${ adjRgb.join(',') })`;
							el.style.setProperty('color', newFgColorString, 'important');
							let reEvaluatedFgRgba = ar_parseCssColorString(window.getComputedStyle(el).color);
							fixedContrast = ar_getContrastRatioBetweenColors(reEvaluatedFgRgba, bgRgba);
							if (fixedContrast >= requiredContrast) {
								successfullyFixed = true;
								break
							}
						}
					}
					if (successfullyFixed) {
						ar_logAccessibilityIssue('Info', `Low contrast auto-fixed text to ${ newFgColorString } (strategy: ${ fixStrategy }). New: ${ fixedContrast.toFixed(2) }:1.`, el, `Original: ${ originalFgColorString }.`, 'Perceivable', '1.4.3', 'AA')
					} else if (el.tagName !== 'BODY' && ![
							'MAIN',
							'HEADER',
							'FOOTER',
							'NAV',
							'ASIDE'
						].includes(el.tagName)) {
						fixStrategy += '+iterative_bg_hsl';
						let adjBgRgb = [...bgRgba.slice(0, 3)];
						const isTextDark = ar_getLuminanceFromRgb(fgOriginalRgba) < 0.5;
						for (let i = 0; i < AR_CONFIG.CONTRAST_ADJUSTMENT_STEPS; i++) {
							let [h, s, l] = ar_rgbToHsl(...adjBgRgb);
							const delta = AR_CONFIG.CONTRAST_ADJUSTMENT_AMOUNT * (i / 3 + 1);
							if (delta > AR_CONFIG.AGGRESSIVE_CONTRAST_BG_ADJUST_MAX_DELTA)
								break;
							l = isTextDark ? Math.min(1, l + delta) : Math.max(0, l - delta);
							adjBgRgb = ar_hslToRgb(h, s, l);
							const newBgCssString = `rgb(${ adjBgRgb.join(',') })`;
							el.style.setProperty('background-color', newBgCssString, 'important');
							const reEvaluatedBgRgba = ar_getEffectiveBackgroundColorOfElement(el);
							fixedContrast = ar_getContrastRatioBetweenColors(fgOriginalRgba, reEvaluatedBgRgba);
							if (fixedContrast >= requiredContrast) {
								successfullyFixed = true;
								ar_logAccessibilityIssue('Info', `Low contrast. Auto-adjusted BG to ${ newBgCssString } for text "${ originalFgColorString }". New: ${ fixedContrast.toFixed(2) }:1.`, `Original BG: ${ originalBgColorString }. Strategy: ${ fixStrategy }. WARNING: BG changed.`, 'Perceivable', '1.4.3', 'AA');
								break
							}
						}
					}
					if (!successfullyFixed) {
						const failKey = `${ initialFailureKey }::AUTOFIX_FAILED`;
						if (!ar_loggedIssuesTracker.has(failKey)) {
							ar_logAccessibilityIssue('Critical', `Low contrast ${ currentContrast.toFixed(2) }:1 (req ${ requiredContrast }:1). All autofix attempts failed. Best: ${ fixedContrast.toFixed(2) }:1.`, el, `Original: ${ originalFgColorString } on ${ originalBgColorString }. Manually adjust.`, 'Perceivable', '1.4.3', false, 'AA');
							ar_loggedIssuesTracker.add(failKey)
						}
					}
				}
			} catch (e) {
				console.error('Error: ContrastRatio:', e, el)
			}
		});
		if (!targetElement)
			console.groupEnd()
	},
	checkFormFieldLabels: function () {
		ar_logSection('Form Field Labels');
		document.querySelectorAll('input:not([type="hidden"]):not([type="submit"]):not([type="reset"]):not([type="button"]), select, textarea').forEach(field => {
			try {
				if (ar_isVisuallyHidden(field) || ar_hasAccessibleNameForElement(field))
					return;
				const id = field.id || ar_generateUniqueElementId('field-');
				if (!field.id)
					field.id = id;
				let labelText = (field.getAttribute('title') || '').trim() || (field.placeholder || '').trim();
				if ((field.type === 'radio' || field.type === 'checkbox') && field.nextSibling && field.nextSibling.nodeType === Node.TEXT_NODE && (field.nextSibling.textContent || '').trim().length > 0) {
					const textNode = field.nextSibling;
					const newLabel = document.createElement('label');
					newLabel.htmlFor = id;
					newLabel.appendChild(document.createTextNode((textNode.textContent || '').trim()));
					textNode.parentNode.insertBefore(newLabel, textNode.nextSibling);
					textNode.parentNode.removeChild(textNode);
					ar_logAccessibilityIssue('Moderate', `Radio/checkbox missing label. Auto-wrapped adjacent text.`, field, '**Manual review required.**', 'Perceivable', '3.3.2', true, 'A');
					return
				}
				if (labelText)
					ar_setAttributeAndLog(field, 'aria-label', labelText, 'Moderate', `Field missing label. Auto-set aria-label from title/placeholder.`, '**Manual review required.** Prefer visible <label>.', 'Perceivable', '3.3.2', 'A');
				else {
					const newLabel = document.createElement('label');
					newLabel.htmlFor = id;
					newLabel.textContent = field.name ? `Label for ${ field.name }` : `Label for field ${ id }`;
					if (field.parentElement) {
						field.parentElement.insertBefore(newLabel, field);
						ar_logAccessibilityIssue('Critical', `Field missing label. Auto-added <label>.`, field, '**Manual review required.**', 'Perceivable', '3.3.2', true, 'A')
					} else
						ar_logAccessibilityIssue('Critical', `Field missing label. Could not auto-add <label>.`, field, 'Provide label.', 'Perceivable', '3.3.2', false, 'A')
				}
			} catch (e) {
				console.error('Error: FormFieldLabels:', e, field)
			}
		});
		console.groupEnd()
	},
	checkFormValidationAria: function () {
		ar_logSection('Form Validation ARIA');
		document.querySelectorAll('input:not([type="hidden"]), select, textarea').forEach(el => {
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const prevSiblingText = el.previousSibling && el.previousSibling.nodeType === Node.TEXT_NODE ? el.previousSibling.textContent.trim() : '';
				const pLabel = el.closest('label');
				const labelText = pLabel ? (pLabel.textContent || '').trim() : '';
				if ((prevSiblingText.endsWith('*') || labelText.endsWith('*') || el.nextSibling && el.nextSibling.nodeType === Node.TEXT_NODE && (el.nextSibling.textContent || '').trim().startsWith('*')) && !el.hasAttribute('required') && !el.hasAttribute('aria-required')) {
					ar_setAttributeAndLog(el, 'required', '', 'Minor', 'Field visually marked required ("*") but missing `required`. Auto-added.', 'Ensure `required` and `aria-required="true"`.', 'Robust', '3.3.2', 'A')
				}
				if (el.hasAttribute('required') && el.getAttribute('aria-required') !== 'true')
					ar_setAttributeAndLog(el, 'aria-required', 'true', 'Moderate', 'Required field missing aria-required="true". Auto-fixed.', 'Add aria-required="true".', 'Robust', '4.1.2', 'A');
				const ariaInvalid = el.getAttribute('aria-invalid');
				if (ariaInvalid && ![
						'true',
						'false'
					].includes(ariaInvalid))
					ar_setAttributeAndLog(el, 'aria-invalid', 'false', 'Minor', 'aria-invalid invalid value. Auto-set to "false".', 'Use "true" or "false".', 'Robust', '4.1.2', 'A');
				if (el.getAttribute('aria-invalid') === 'true' && !el.hasAttribute('aria-describedby')) {
					let errorMsgEl = null;
					const potentialErrorSibling = el.nextElementSibling;
					if (potentialErrorSibling && ((potentialErrorSibling.className || '').toLowerCase().includes('error') || (potentialErrorSibling.className || '').toLowerCase().includes('invalid') || potentialErrorSibling.getAttribute('role') === 'alert')) {
						errorMsgEl = potentialErrorSibling
					} else {
						errorMsgEl = document.createElement('span');
						errorMsgEl.id = ar_generateUniqueElementId('error-msg-');
						errorMsgEl.textContent = 'Invalid input.';
						errorMsgEl.style.cssText = 'position:absolute; left:-9999px;';
						errorMsgEl.setAttribute('role', 'alert');
						el.parentNode.insertBefore(errorMsgEl, el.nextSibling)
					}
					if (errorMsgEl && errorMsgEl.id) {
						ar_setAttributeAndLog(el, 'aria-describedby', errorMsgEl.id, 'Minor', `Input with aria-invalid="true" missing aria-describedby. Auto-linked/added error message.`, 'Ensure invalid inputs are described by an error message via aria-describedby.', 'Understandable', '3.3.1 Error Identification', true, 'A')
					}
				}
			} catch (e) {
				console.error('Error: FormValidationAria:', e, el)
			}
		});
		console.groupEnd()
	},
	checkLandmarkRoles: function (globalState) {
		ar_logSection('ARIA Landmark Roles / HTML5 Semantic Elements');
		const body = document.body;
		AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.forEach(r => {
			globalState.detectedLandmarkRoleCounts[r] = 0
		});
		AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.forEach(t => {
			globalState.detectedLandmarkRoleCounts[t] = globalState.detectedLandmarkRoleCounts[t] || 0
		});
		document.querySelectorAll('*').forEach(el => {
			if (ar_isVisuallyHidden(el))
				return;
			const r = el.getAttribute('role');
			const tn = el.tagName.toLowerCase();
			if (r && AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.includes(r))
				globalState.detectedLandmarkRoleCounts[r]++;
			else if (AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.includes(tn)) {
				const ir = {
					'main': 'main',
					'header': 'banner',
					'footer': 'contentinfo',
					'nav': 'navigation',
					'aside': 'complementary',
					'form': 'form',
					'section': el.hasAttribute('aria-label') || el.hasAttribute('aria-labelledby') ? 'region' : null
				}[tn];
				if (ir)
					globalState.detectedLandmarkRoleCounts[ir]++
			}
		});
		const essentialLandmarksSetup = {
			'banner': {
				selector: AR_SELECTOR_STRINGS.COMMON_HEADER_SELECTORS,
				htmlTag: 'header',
				role: 'banner',
				placement: 'prepend',
				contentHeuristic: children => children.slice(0, Math.min(children.length, 3))
			},
			'navigation': {
				selector: AR_SELECTOR_STRINGS.COMMON_NAV_SELECTORS,
				htmlTag: 'nav',
				role: 'navigation',
				placement: 'afterHeader',
				contentHeuristic: children => {
					const navCand = children.find(c => c.tagName === 'UL' && c.querySelectorAll('li > a[href]').length > 2);
					return navCand ? [navCand] : []
				}
			},
			'main': {
				selector: AR_SELECTOR_STRINGS.MAIN_CONTENT_TARGET_SELECTORS,
				htmlTag: 'main',
				role: 'main',
				placement: 'beforeFooter',
				contentHeuristic: (children, header, nav, footer) => {
					const mainContent = [];
					let inMain = false;
					for (const child of children) {
						if (child === header || child === nav || child.id === AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID || child.id === AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID || [
								'SCRIPT',
								'STYLE',
								'LINK'
							].includes(child.tagName)) {
							if (!inMain && child !== header && child !== nav) {
							} else
								continue
						}
						if (child === footer)
							break;
						inMain = true;
						mainContent.push(child)
					}
					return mainContent.length > 0 ? mainContent : children.filter(c => c !== header && c !== nav && c !== footer && ![
						'SCRIPT',
						'STYLE'
					].includes(c.tagName) && c.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && c.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID).slice(0, Math.max(1, children.length - (header ? 1 : 0) - (nav ? 1 : 0) - (footer ? 1 : 0) - 2))
				}
			},
			'contentinfo': {
				selector: AR_SELECTOR_STRINGS.COMMON_FOOTER_SELECTORS,
				htmlTag: 'footer',
				role: 'contentinfo',
				placement: 'append',
				contentHeuristic: children => children.length > 1 ? children.slice(Math.max(0, children.length - 2)) : children
			}
		};
		for (const roleName in essentialLandmarksSetup) {
			const setup = essentialLandmarksSetup[roleName];
			if (globalState.detectedLandmarkRoleCounts[roleName] === 0) {
				let candidate = document.querySelector(setup.htmlTag) || document.querySelector(`[role="${ setup.role }"]`) || document.querySelector(setup.selector);
				if (candidate && candidate.tagName.toLowerCase() !== setup.htmlTag && !candidate.getAttribute('role')) {
					ar_setAttributeAndLog(candidate, 'role', setup.role, 'Moderate', `Missing ${ roleName } landmark. Auto-added role to likely candidate <${ candidate.tagName }>.`, `Use <${ setup.htmlTag }> or role="${ setup.role }".`, 'Perceivable', '1.3.1', 'A');
					globalState.detectedLandmarkRoleCounts[roleName]++
				} else if (!candidate) {
					const newLandmark = document.createElement(setup.htmlTag);
					if (setup.role !== setup.htmlTag && setup.role)
						newLandmark.setAttribute('role', setup.role);
					let movedContent = false;
					if (setup.contentHeuristic) {
						const bodyChildren = Array.from(body.children);
						const childrenToMove = setup.contentHeuristic(bodyChildren, body.querySelector(essentialLandmarksSetup.banner.htmlTag + ', [role=banner]'), body.querySelector(essentialLandmarksSetup.navigation.htmlTag + ', [role=navigation]'), body.querySelector(essentialLandmarksSetup.contentinfo.htmlTag + ', [role=contentinfo]'));
						if (childrenToMove.length > 0) {
							childrenToMove.forEach(child => {
								if (child.parentNode === body && child !== newLandmark)
									newLandmark.appendChild(child)
							});
							movedContent = true
						}
					}
					if (setup.placement === 'prepend' && body.firstChild)
						body.insertBefore(newLandmark, body.firstChild);
					else if (setup.placement === 'append')
						body.appendChild(newLandmark);
					else if (setup.placement === 'afterHeader') {
						const headerEl = body.querySelector('header, [role="banner"]');
						if (headerEl && headerEl.nextSibling)
							body.insertBefore(newLandmark, headerEl.nextSibling);
						else if (body.firstChild)
							body.insertBefore(newLandmark, body.firstChild);
						else
							body.appendChild(newLandmark)
					} else if (setup.placement === 'beforeFooter') {
						const footerEl = body.querySelector('footer, [role="contentinfo"]');
						if (footerEl)
							body.insertBefore(newLandmark, footerEl);
						else
							body.appendChild(newLandmark)
					} else
						body.appendChild(newLandmark);
					ar_logAccessibilityIssue('Moderate', `Missing "${ roleName }" landmark. Aggressively Auto-created <${ setup.htmlTag }>${ movedContent ? ' and attempted to wrap plausible content.' : '.' }`, newLandmark, 'Verify content correctly structured. This is a significant DOM change.', 'Perceivable', '1.3.1 Info and Relationships', true, 'A');
					globalState.detectedLandmarkRoleCounts[roleName]++
				} else {
					ar_logAccessibilityIssue('Moderate', `Missing essential landmark: "${ roleName }". Could not auto-create or assign.`, document.body, `Use <${ setup.htmlTag }> or role="${ setup.role }".`, 'Perceivable', '1.3.1', false, 'A')
				}
			} else if (globalState.detectedLandmarkRoleCounts[roleName] > 1 && [
					'main',
					'banner',
					'contentinfo'
				].includes(roleName)) {
				ar_logAccessibilityIssue('Minor', `Multiple "${ roleName }" landmarks.`, document.querySelector(setup.s), `Usually one "${ roleName }" per page.`, 'Perceivable', '1.3.1', false, 'A')
			}
		}
		console.groupEnd()
	},
	checkFocusIndicators: function () {
		ar_logSection('Focus Indicators');
		let styleTag = document.getElementById('ar-focus-style');
		if (!styleTag) {
			styleTag = document.createElement('style');
			styleTag.id = 'ar-focus-style';
			styleTag.textContent = `${ AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS.split(',').map(s => s.trim() + ':focus-visible').join(',') } {outline: 2px solid Highlight !important;outline: 2px solid -webkit-focus-ring-color !important;outline-offset: 2px !important;box-shadow: 0 0 0 2px rgba(30,144,255,0.3) !important;}`;
			document.head.appendChild(styleTag);
			ar_logAccessibilityIssue('Info', 'Injected global CSS for :focus-visible.', styleTag, 'Review custom focus styles.', 'Operable', '2.4.7 Focus Visible', true, 'AA')
		}
		document.querySelectorAll(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS).forEach(el => {
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const s = window.getComputedStyle(el);
				if ((s.outlineStyle === 'none' || parseFloat(s.outlineWidth) === 0) && s.boxShadow === 'none') {
					const fvs = window.getComputedStyle(el, ':focus-visible');
					if ((fvs.outlineStyle === 'none' || parseFloat(fvs.outlineWidth) === 0) && fvs.boxShadow === 'none')
						ar_logAccessibilityIssue('Moderate', 'Element may lack visible focus indicator.', el, 'Ensure clear focus style.', 'Operable', '2.4.7', false, 'AA')
				}
			} catch (e) {
				console.error('Error: FocusIndicators:', e, el)
			}
		});
		console.log('\n\uD83D\uDCA1 Manual Verification for Focus Indicators is CRUCIAL.');
		console.groupEnd()
	},
	checkSkipLinks: function (globalState) {
		ar_logSection('Skip Link');
		const skipLink = document.querySelector('a[href^="#"]:first-child, a.skip-link:first-child, [data-skip-link="true"]:first-child');
		if (!skipLink || ar_isVisuallyHidden(skipLink)) {
			const newSkipLink = document.createElement('a');
			newSkipLink.textContent = 'Skip to main content';
			Object.assign(newSkipLink.style, {
				position: 'absolute',
				left: '-9999px',
				top: 'auto',
				width: '1px',
				height: '1px',
				overflow: 'hidden',
				zIndex: '-999',
				padding: '0.5em 1em',
				background: '#f0f0f0',
				color: '#333',
				textDecoration: 'none',
				borderRadius: '3px',
				border: '1px solid #ccc'
			});
			newSkipLink.onfocus = function () {
				Object.assign(this.style, {
					left: '10px',
					top: '10px',
					width: 'auto',
					height: 'auto',
					zIndex: '2147483647',
					boxShadow: '0 0 10px rgba(0,0,0,0.5)'
				})
			};
			newSkipLink.onblur = function () {
				Object.assign(this.style, {
					left: '-9999px',
					top: 'auto',
					width: '1px',
					height: '1px',
					zIndex: '-999',
					boxShadow: 'none'
				})
			};
			let mainTarget = document.querySelector(AR_SELECTOR_STRINGS.MAIN_CONTENT_TARGET_SELECTORS) || document.querySelector('article, section[aria-label], section[aria-labelledby]') || document.body.children[0];
			if (mainTarget) {
				if (!mainTarget.id)
					mainTarget.id = ar_generateUniqueElementId('main-content-target');
				if (mainTarget.getAttribute('tabindex') === null && !mainTarget.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS) && mainTarget.getAttribute('role') !== 'region') {
					ar_setAttributeAndLog(mainTarget, 'tabindex', '-1', 'Info', 'Main content target for skip link made programmatically focusable.', 'Ensure main content area can receive focus for skip links.', 'Operable', '2.4.1 Bypass Blocks', true, 'A')
				}
				newSkipLink.href = `#${ mainTarget.id }`;
				document.body.prepend(newSkipLink);
				ar_logAccessibilityIssue('Moderate', 'No visible "skip to main" link as first focusable. Auto-injected.', newSkipLink, 'Ensure skip link is first, targets main content, visible on focus.', 'Operable', '2.4.1 Bypass Blocks', true, 'A')
			} else {
				ar_logAccessibilityIssue('Moderate', 'No "skip to main" link, no clear main target for autofix.', document.body, 'Implement skip link.', 'Operable', '2.4.1 Bypass Blocks', false, 'A')
			}
		}
		console.groupEnd()
	},
	DocumentGlobals: function () {
		ar_logSection('Global Document Setup');
		const dE = document.documentElement, head = document.head, body = document.body;
		const titleElement = head.querySelector('title');
		if (!titleElement || !(titleElement.textContent || '').trim()) {
			const h1 = body.querySelector('h1');
			const h1Text = h1 && h1.textContent ? h1.textContent.trim().substring(0, 60) : '';
			let newTitleEl = titleElement || document.createElement('title');
			const newTitle = (h1Text || 'Untitled Page') + (h1Text ? '' : ' - AutoTitle');
			ar_setAttributeAndLog(newTitleEl, 'textContent', newTitle, 'Critical', 'Doc title missing/empty. Auto-generated.', 'Provide descriptive title. **Manual review.**', 'Operable', '2.4.2 Page Titled', 'A');
			if (!titleElement)
				head.appendChild(newTitleEl)
		}
		let viewportMeta = head.querySelector('meta[name="viewport"]');
		const vpContent = viewportMeta ? viewportMeta.content : '';
		if (!viewportMeta || !vpContent || !vpContent.includes('width=device-width') || !vpContent.includes('initial-scale=1')) {
			let newVp = viewportMeta || document.createElement('meta');
			if (!viewportMeta) {
				newVp.name = 'viewport';
				head.appendChild(newVp)
			}
			let newContentVal = 'width=device-width, initial-scale=1.0';
			if (vpContent && vpContent.includes('user-scalable=no'))
				newContentVal = vpContent.replace(/user-scalable=no[,]?/g, '');
			if (vpContent && vpContent.includes('maximum-scale'))
				newContentVal = newContentVal.replace(/maximum-scale=[0-9.]*[,]?/g, '');
			newContentVal = newContentVal.replace(/,,/g, ',').replace(/,$/, '');
			if (!newContentVal.includes('user-scalable=yes') && !newContentVal.includes('user-scalable=no'))
				newContentVal += (newContentVal ? ',' : '') + 'user-scalable=yes';
			ar_setAttributeAndLog(newVp, 'content', newContentVal, 'Critical', 'Viewport missing/improper. Auto-corrected.', 'Ensure proper viewport for responsiveness & scaling.', 'Perceivable', '1.4.10 Reflow, 1.4.4 Resize text', 'AA')
		} else if (vpContent && (vpContent.includes('user-scalable=no') || vpContent.includes('maximum-scale=1.0') || vpContent.includes('maximum-scale=1,'))) {
			let newContent = vpContent.replace(/user-scalable=no[,]?/g, '').replace(/maximum-scale=1(.0)?[,]?/g, '');
			newContent = newContent.replace(/,,/g, ',').replace(/,$/, '');
			if (!newContent.includes('user-scalable=yes') && !newContent.includes('user-scalable=no'))
				newContent += (newContent ? ',' : '') + 'user-scalable=yes';
			ar_setAttributeAndLog(viewportMeta, 'content', newContent, 'Moderate', 'Viewport restricts scaling. Auto-corrected.', 'Avoid user-scalable=no or maximum-scale=1.0.', 'Perceivable', '1.4.4 Resize text', 'AA')
		}
		const metaRefresh = head.querySelector('meta[http-equiv="refresh"]');
		if (metaRefresh) {
			ar_logAccessibilityIssue('Critical', 'Meta refresh tag found. This can cause accessibility issues.', metaRefresh, 'Avoid using meta refresh for redirects or timed updates. Use server-side redirects or JavaScript with user controls.', 'Operable', '2.2.1 Timing Adjustable / 2.2.4 Interruptions', false, 'A')
		}
		if (!head.querySelector('#ar-focus-style'))
			AR_CheckModules.checkFocusIndicators();
		console.groupEnd()
	}
};
function ar_rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	const max = Math.max(r, g, b), min = Math.min(r, g, b);
	let h, s, l = (max + min) / 2;
	if (max === min) {
		h = s = 0
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
		case r:
			h = (g - b) / d + (g < b ? 6 : 0);
			break;
		case g:
			h = (b - r) / d + 2;
			break;
		case b:
			h = (r - g) / d + 4;
			break
		}
		h /= 6
	}
	return [
		h,
		s,
		l
	]
}
function ar_hslToRgb(h, s, l) {
	let r, g, b;
	if (s === 0) {
		r = g = b = l
	} else {
		const hue2rgb = (p, q, t) => {
			if (t < 0)
				t += 1;
			if (t > 1)
				t -= 1;
			if (t < 1 / 6)
				return p + (q - p) * 6 * t;
			if (t < 1 / 2)
				return q;
			if (t < 2 / 3)
				return p + (q - p) * (2 / 3 - t) * 6;
			return p
		};
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3)
	}
	return [
		Math.round(r * 255),
		Math.round(g * 255),
		Math.round(b * 255)
	]
}
function ar_setupMutationObserverForContrast() {
	const observer = new MutationObserver(mutationsList => {
		for (const mutation of mutationsList) {
			if (mutation.type === 'attributes' && (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
				if (mutation.target.nodeType === Node.ELEMENT_NODE)
					AR_CheckModules.checkContrastRatioForAllElements(mutation.target)
			} else if (mutation.type === 'childList') {
				mutation.addedNodes.forEach(node => {
					if (node.nodeType === Node.ELEMENT_NODE) {
						AR_CheckModules.checkContrastRatioForAllElements(node);
						node.querySelectorAll('*').forEach(descendant => AR_CheckModules.checkContrastRatioForAllElements(descendant))
					}
				})
			}
		}
	});
	observer.observe(document.body, {
		attributes: true,
		childList: true,
		subtree: true,
		attributeFilter: [
			'style',
			'class'
		]
	});
	console.log('\uD83D\uDCA1 MutationObserver for contrast changes is active.')
}
async function ar_runAccessibilityScan() {
	console.clear();
	ar_loggedIssuesTracker.clear();
	ar_accessibilityIssuesLog.length = 0;
	ar_totalScannedIssuesCounter = 0;
	ar_totalAutoFixedIssuesCounter = 0;
	console.log('%c Accessibility Resolver ', 'background:#0056b3;color:white;font-size:1.5em;font-weight:bold;padding:10px 20px;border-radius:5px;');
	console.log('Scanning for accessibility issues and applying auto-fixes...');
	console.time('AccessibilityScanDuration');
	const dE = document.documentElement;
	const globalState = {
		lastHeadingLevel: 0,
		seenIds: new Map(),
		detectedLandmarkRoleCounts: {}
	};
	AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.forEach(role => {
		globalState.detectedLandmarkRoleCounts[role] = 0
	});
	AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.forEach(tag => {
		globalState.detectedLandmarkRoleCounts[tag] = globalState.detectedLandmarkRoleCounts[tag] || 0
	});
	AR_CheckModules.DocumentGlobals();
	AR_CheckModules.checkLangAttribute();
	AR_CheckModules.checkSkipLinks(globalState);
	AR_CheckModules.checkContentStructure(globalState);
	AR_CheckModules.checkMediaIntegrity();
	AR_CheckModules.checkImageAltText();
	AR_CheckModules.checkIframeTitles();
	AR_CheckModules.checkTableAccessibility();
	AR_CheckModules.checkOverlayFocusBlocking();
	AR_CheckModules.checkInteractiveElementSize();
	AR_CheckModules.checkHoverFocusContent();
	AR_CheckModules.checkAutoFormSubmission();
	AR_CheckModules.checkDuplicateIds(globalState);
	AR_CheckModules.checkAccessibleNames();
	AR_CheckModules.checkTabindexUsage();
	AR_CheckModules.checkAriaMisuse();
	AR_CheckModules.checkContrastRatioForAllElements();
	AR_CheckModules.checkFormFieldLabels();
	AR_CheckModules.checkFormValidationAria();
	AR_CheckModules.checkLandmarkRoles(globalState);
	AR_CheckModules.checkFocusIndicators();
	ar_setupMutationObserverForContrast();
	console.log('\n%c Accessibility Check and Auto-Fix Summary ', 'font-size:1.3em;font-weight:bold;color:#003973;padding:5px;background:#e3f2fd;border-bottom:2px solid #003973;display:block;text-align:center;');
	const unresolvedIssues = ar_accessibilityIssuesLog.filter(r => !r.isAutofixed);
	console.log(`%cTotal Issues Identified: %c${ ar_accessibilityIssuesLog.length }`, 'font-weight:bold;', 'font-weight:normal;');
	console.log(`%cAuto-Fixed: %c${ ar_totalAutoFixedIssuesCounter }`, 'font-weight:bold;color:green;', `font-weight:normal;color:${ ar_totalAutoFixedIssuesCounter > 0 ? 'green' : 'grey' };`);
	console.log(`%cUnresolved: %c${ unresolvedIssues.length }`, 'font-weight:bold;color:red;', `font-weight:normal;color:${ unresolvedIssues.length > 0 ? 'red' : 'green' };`);
	[
		'Critical',
		'Moderate',
		'Minor',
		'Info'
	].forEach(severity => {
		const issues = unresolvedIssues.filter(r => r.severity === severity && r.wcagLevel !== 'User');
		if (issues.length > 0) {
			const colorMap = {
				'Critical': '#c62828',
				'Moderate': '#ef6c00',
				'Minor': '#0277bd',
				'Info': '#546e7a'
			};
			console.groupCollapsed(`%c ${ severity } Unresolved: ${ issues.length } `, `color:white;background-color:${ colorMap[severity] };padding:3px 7px;border-radius:3px;font-weight:bold;`);
			issues.forEach(issue => {
				console.log(`%cMessage: %c${ issue.message }`, 'font-weight:bold;', '');
				if (issue.element instanceof HTMLElement)
					console.log('%cElement:', 'font-style:italic;', issue.element);
				if (issue.recommendation)
					console.log(`%cRecommendation: %c${ issue.recommendation }`, 'font-style:italic;color:#01579b;', '');
				if (issue.wcagGuideline)
					console.log(`%cWCAG: %c${ issue.wcagGuideline } (${ issue.wcagLevel })`, 'font-style:italic;color:#311b92;', '');
				console.log('---')
			});
			console.groupEnd()
		}
	});
	if (unresolvedIssues.filter(r => r.wcagLevel !== 'User').length > 0) {
		console.log("\n%cReview unresolved issues by expanding the groups above. The 'accessibilityScanGlobalResults' object in the console contains all findings.", 'color:#01579b;');
		window.accessibilityScanGlobalResults = ar_accessibilityIssuesLog
	} else if (ar_accessibilityIssuesLog.filter(r => r.wcagLevel !== 'User' && !r.isAutofixed).length === 0) {
		console.log('%c\uD83C\uDF89 All identified automated accessibility issues were either fixed or not detected in this scan!', 'color:green;font-weight:bold;font-size:1.1em;')
	}
	console.timeEnd('AccessibilityScanDuration');
	const generalObserver = new MutationObserver(() => {
		clearTimeout(ar_mainMutationObserverDebounceTimeout);
		ar_mainMutationObserverDebounceTimeout = setTimeout(() => {
			generalObserver.disconnect();
			console.warn('%cDOM changed. Re-run Accessibility Resolver for an accurate report.', 'color:orange;font-weight:bold;background:lightyellow;padding:5px;')
		}, AR_CONFIG.MUTATION_OBSERVER_DEBOUNCE_MILLISECONDS)
	});
	generalObserver.observe(dE, {
		attributes: true,
		childList: true,
		subtree: true,
		characterData: true,
		attributeFilter: [
			'style',
			'class',
			'alt',
			'href',
			'role',
			'tabindex',
			'aria-hidden',
			'aria-label',
			'id',
			'for',
			'value',
			'src'
		]
	})
}
function ar_initializeAndRunMerged() {
	console.log('%c Author (Original Scripts): Yaron Koresh ', 'background:#4CAF50;color:white;font-size:1em;font-weight:bold;padding:5px 10px;border-radius:3px;');
	AR_AccessibilityMenu.init();
	ar_runAccessibilityScan()
}
if (document.readyState === 'complete' || document.readyState === 'interactive') {
	setTimeout(ar_initializeAndRunMerged, 400)
} else {
	window.addEventListener('DOMContentLoaded', () => setTimeout(ar_initializeAndRunMerged, 400))
}
