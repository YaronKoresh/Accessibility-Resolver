const AR_CONFIG = {
	MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX: 24,
	MINIMUM_TOUCH_TARGET_SPACING_PX: 8,
	CONTRAST_RATIO_AA_NORMAL_TEXT: 4.5,
	CONTRAST_RATIO_AA_LARGE_TEXT: 3,
	CONTRAST_RATIO_AAA_NORMAL_TEXT: 7,
	CONTRAST_RATIO_AAA_LARGE_TEXT: 4.5,
	NON_TEXT_CONTRAST_RATIO_AA: 3,
	LARGE_TEXT_FONT_SIZE_PX: 24,
	LARGE_TEXT_FONT_SIZE_BOLD_PX: 18.66,
	MINIMUM_BODY_TEXT_FONT_SIZE_PX: 13,
	MAX_CHARS_FOR_WALL_OF_TEXT_DETECTION: 600,
	MAX_REPETITIONS_FOR_GENERIC_LINK_TEXT: 2,
	MUTATION_OBSERVER_DEBOUNCE_MILLISECONDS: 750,
	MAX_CHAR_LENGTH_FOR_HEADINGS: 90,
	MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT: 3,
	MAX_SIBLING_SEARCH_DEPTH_FOR_ARIA_RELATIONSHIP: 4,
	MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL: 120,
	MIN_CONTRAST_FOR_PDF_ICON: 2.5,
	MIN_CHAR_LENGTH_FOR_REDUNDANT_TITLE_CHECK: 4,
	MAX_WORDS_FROM_CONTEXT_FOR_GENERIC_LINK_ARIA_LABEL: 12,
	ACCESSIBILITY_MENU_BUTTON_ID: 'accessibility-resolver-menu-toggle-button',
	ACCESSIBILITY_MENU_PANEL_ID: 'accessibility-resolver-menu-panel',
	DEFAULT_FONT_SIZE_ADJUSTMENT_INCREMENT: 0.1,
	MAX_FONT_SIZE_ADJUSTMENT_MULTIPLIER: 3,
	MIN_FONT_SIZE_ADJUSTMENT_MULTIPLIER: 0.6,
	READING_MASK_ELEMENT_ID: 'accessibility-resolver-reading-mask',
	READING_LINE_ELEMENT_ID: 'accessibility-resolver-reading-line',
	DYSLEXIA_FRIENDLY_FONT_CLASS_NAME: 'accessibility-resolver-dyslexia-font',
	SATURATION_FILTER_CLASS_NAME: 'accessibility-resolver-saturation-filter',
	TEXT_ALIGNMENT_CLASS_NAME_PREFIX: 'accessibility-resolver-text-align-',
	INCREASED_LETTER_SPACING_CLASS_NAME: 'accessibility-resolver-increased-letter-spacing',
	INCREASED_WORD_SPACING_CLASS_NAME: 'accessibility-resolver-increased-word-spacing',
	INCREASED_LINE_HEIGHT_CLASS_NAME: 'accessibility-resolver-increased-line-height',
	ANIMATIONS_STOPPED_CLASS_NAME: 'accessibility-resolver-animations-stopped',
	HIGHLIGHTED_LINKS_CLASS_NAME: 'accessibility-resolver-highlight-links',
	HIGHLIGHTED_HEADINGS_CLASS_NAME: 'accessibility-resolver-highlight-headings',
	HIGH_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-high',
	INVERTED_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-inverted',
	GRAYSCALE_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-grayscale',
	LOW_SATURATION_CLASS_NAME: 'accessibility-resolver-saturation-low',
	AVATAR_KEYWORDS: [
		'avatar',
		'profile',
		'usericon',
		'dp',
		'user-img',
		'user_image'
	],
	FILENAME_CLEANUP_REGEX: /[-_]/g,
	COMMON_ICON_CLASS_PREFIXES: [
		'fa-',
		'fas',
		'far',
		'fal',
		'fad',
		'fab',
		'glyphicon-',
		'icon-',
		'material-icons',
		'mdi-',
		'bi-',
		'icofont-'
	],
	MENU_ICON_COLOR: '#455a64',
	MENU_ICON_ACTIVE_COLOR: '#ffffff',
	MENU_TEXT_ACTIVE_COLOR: '#ffffff',
	PLACEHOLDER_IMAGE_URL: 'https://placehold.co/{width}x{height}/E0E0E0/BDBDBD?text={text}',
	CONTRAST_ADJUSTMENT_STEPS: 10,
	CONTRAST_ADJUSTMENT_AMOUNT: 0.1,
	AGGRESSIVE_CONTRAST_BG_ADJUST_MAX_DELTA: 0.25
};
const AR_SELECTOR_STRINGS = {
	INTERACTIVE_ELEMENTS: 'button, a[href], input:not([type="hidden"]), select, textarea, [role="button"], [role="link"], [role="checkbox"], [role="radio"], [role="option"], [role="menuitem"], [role="tab"], [role="treeitem"], [role="slider"], [role="spinbutton"], [role="switch"], [tabindex]:not([tabindex="-1"])',
	HEADING_ELEMENTS: 'h1, h2, h3, h4, h5, h6',
	TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU: `:is(p, li, dt, dd, figcaption, blockquote, pre, code, summary, h1, h2, h3, h4, h5, h6, article, section, main, header, footer, nav, aside, div:not(#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }):not(#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID }):not([role="toolbar"]):not([role="menubar"]):not([class*="toast"]):not([class*="modal"]):not([class*="popup"]), span:not(#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } *):not(#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID } *), td, th, caption, label, legend, em, strong, b, i, small, sub, sup, mark, ins, del, q, cite):not(:has(:not(span)))`.replace(/\s+/g, ' ').trim(),
	FORM_CONTROL_ELEMENTS: 'input:not([type="hidden"]), select, textarea',
	LANDMARK_ROLES_ARRAY: [
		'main',
		'banner',
		'contentinfo',
		'navigation',
		'complementary',
		'form',
		'region',
		'search'
	],
	LANDMARK_HTML_TAGS_ARRAY: [
		'main',
		'header',
		'footer',
		'nav',
		'aside',
		'form',
		'section'
	],
	MEDIA_ELEMENTS: 'img, svg, canvas, iframe, audio, video',
	MAIN_CONTENT_TARGET_SELECTORS: 'main, [role="main"], #main, #content, .main, .page-content, article, #main-content, [data-main-content], .container, .wrapper, #page-wrapper, div[class*="content-area" i], section[class*="main-content" i]',
	NATIVE_INTERACTIVE_TAGS: 'button, a, input, select, textarea',
	COMMON_HEADER_SELECTORS: 'body > header, body > div[id*="header" i], body > div[class*="header" i], body > div[id*="banner" i], body > div[class*="banner" i], body > .site-header, body > #site-header, body > #masthead',
	COMMON_FOOTER_SELECTORS: 'body > footer, body > div[id*="footer" i], body > div[class*="footer" i], body > div[id*="colophon" i], body > .site-footer, body > #site-footer',
	COMMON_NAV_SELECTORS: 'body > nav, body > div[id*="nav" i], body > div[class*="nav" i], body > ul[class*="nav" i], body > div[id*="menu" i], body > ul[id*="menu" i], body > .main-nav, body > #main-nav, body > .primary-navigation'
};
let ar_accessibilityIssuesLog = [];
let ar_totalScannedIssuesCounter = 0;
let ar_totalAutoFixedIssuesCounter = 0;
const ar_generatedUniqueElementIds = new Set();
const ar_detectedLandmarkRoleCounts = {};
let ar_mainMutationObserverDebounceTimeout;
const ar_originalElementStylesMap = new Map();
let ar_activeReadingGuideType = null;
const ar_loggedIssuesTracker = new Set()
function getDevice(){
	return [
		(document.body.classList.contains('tablet') ? 'tablet' : document.body.classList.contains('mobile') ? 'mobile' : 'desktop' ),
		(document.body.classList.contains('portrait') ? 'portrait' : 'landscape')
	];
}
function _setDeviceOrientation() {
	const newOrientation = screen.orientation.type;
	const newAngle = screen.orientation.angle;	
	document.body.classList.remove('portrait', 'landscape');
	if (newOrientation.startsWith('portrait')) {
	    document.body.classList.add('portrait');
	} else if (newOrientation.startsWith('landscape')) {
	    document.body.classList.add('landscape');
	}
}
function setDeviceOrientation() {
	screen.orientation.addEventListener('change', () => _setDeviceOrientation);
	_setDeviceOrientation();
}
function setDeviceType() {
	const ua = navigator.userAgent;
	document.body.classList.remove('tablet', 'mobile', 'desktop');
	if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) {
		document.body.classList.add( "tablet" );
	}
	if ( /Mobile|iP(hone|od)|Android|BlackBerry|IEMobile|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test( ua )) {
		document.body.classList.add( "mobile" );
	}
	document.body.classList.add( "desktop" );
}
function ar_generateUniqueElementId(prefix = 'ar-uid') {
	let newId;
	let attempts = 0;
	do {
		newId = `${ prefix }-${ Math.random().toString(36).substring(2, 9) }${ attempts > 0 ? '-' + attempts : '' }`;
		attempts++
	} while (document.getElementById(newId) || ar_generatedUniqueElementIds.has(newId));
	ar_generatedUniqueElementIds.add(newId);
	return newId
}
function ar_isVisuallyHidden(element) {
	if (!element)
		return true;
	const style = window.getComputedStyle(element);
	return style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0' || element.offsetWidth === 0 || element.offsetHeight === 0
}
function ar_parseCssColorString(colorString) {
	if (!colorString || typeof colorString !== 'string')
		return [
			0,
			0,
			0,
			0
		];
	const div = document.createElement('div');
	Object.assign(div.style, {
		color: 'transparent',
		backgroundColor: 'transparent',
		display: 'none'
	});
	if (!document.body)
		return [
			0,
			0,
			0,
			0
		];
	document.body.appendChild(div);
	try {
		div.style.color = colorString;
		const compColor = window.getComputedStyle(div).color;
		const match = compColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
		if (match) {
			return [
				+match[1],
				+match[2],
				+match[3],
				match[4] !== undefined ? parseFloat(match[4]) : 1
			]
		}
	} catch (e) {
	} finally {
		div.remove()
	}
	return [
		0,
		0,
		0,
		0
	]
}
function ar_getLuminanceFromRgb(rgbArray) {
	const a = rgbArray.slice(0, 3).map(v => {
		v /= 255;
		return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)
	});
	return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722
}
function ar_getContrastRatioBetweenColors(rgba1, rgba2) {
	const lum1 = ar_getLuminanceFromRgb(rgba1);
	const lum2 = ar_getLuminanceFromRgb(rgba2);
	return (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05)
}
function ar_blendColors(fgRgba, bgRgba) {
	const alpha = fgRgba[3];
	if (alpha === 1)
		return fgRgba;
	const r = Math.round((1 - alpha) * bgRgba[0] + alpha * fgRgba[0]);
	const g = Math.round((1 - alpha) * bgRgba[1] + alpha * fgRgba[1]);
	const b = Math.round((1 - alpha) * bgRgba[2] + alpha * fgRgba[2]);
	return [
		r,
		g,
		b,
		1
	]
}
function ar_getEffectiveBackgroundColorOfElement(element) {
	let currentEl = element;
	while (currentEl && currentEl !== document.documentElement) {
		const style = window.getComputedStyle(currentEl);
		const bgColor = style.backgroundColor;
		if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
			const rgba = ar_parseCssColorString(bgColor);
			if (rgba[3] === 1)
				return rgba
		}
		if (currentEl === document.body || !currentEl.parentElement)
			break;
		currentEl = currentEl.parentElement
	}
	const bodyBg = ar_parseCssColorString(window.getComputedStyle(document.body).backgroundColor);
	return bodyBg[3] === 1 ? bodyBg : [
		255,
		255,
		255,
		1
	]
}
function ar_isTextLargeForWCAG(element) {
	const style = window.getComputedStyle(element);
	const fontSize = parseFloat(style.fontSize);
	const fontWeight = style.fontWeight;
	return fontSize >= AR_CONFIG.LARGE_TEXT_FONT_SIZE_PX || fontSize >= AR_CONFIG.LARGE_TEXT_FONT_SIZE_BOLD_PX && (parseInt(fontWeight) >= 700 || fontWeight === 'bold' || fontWeight === 'bolder')
}
function ar_rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	const max = Math.max(r, g, b), min = Math.min(r, g, b);
	let h, s, l = (max + min) / 2;
	if (max === min) {
		h = s = 0
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
		case r:
			h = (g - b) / d + (g < b ? 6 : 0);
			break;
		case g:
			h = (b - r) / d + 2;
			break;
		case b:
			h = (r - g) / d + 4;
			break
		}
		h /= 6
	}
	return [
		h,
		s,
		l
	]
}
function ar_hslToRgb(h, s, l) {
	let r, g, b;
	if (s === 0) {
		r = g = b = l
	} else {
		const hue2rgb = (p, q, t) => {
			if (t < 0)
				t += 1;
			if (t > 1)
				t -= 1;
			if (t < 1 / 6)
				return p + (q - p) * 6 * t;
			if (t < 1 / 2)
				return q;
			if (t < 2 / 3)
				return p + (q - p) * (2 / 3 - t) * 6;
			return p
		};
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3)
	}
	return [
		Math.round(r * 255),
		Math.round(g * 255),
		Math.round(b * 255)
	]
}
function ar_getLogMeta(severity, isAutofixed) {
	const styles = {
		'Critical': {
			p: '\u274C Critical:',
			s: 'color:white;background:#d32f2f;border-left:4px solid #b71c1c;'
		},
		'Moderate': {
			p: '\u26A0️ Moderate:',
			s: 'color:black;background:#ffb300;border-left:4px solid #e65100;'
		},
		'Minor': {
			p: '\uD83D\uDCA1 Minor:',
			s: 'color:black;background:#64b5f6;border-left:4px solid #1976d2;'
		},
		'Info': {
			p: 'ℹ️ Info:',
			s: 'color:#37474f;background:#eceff1;border-left:4px solid #90a4ae;'
		}
	};
	const fixStyle = {
		p: '\u2705 Auto-Fixed:',
		s: 'color:darkgreen;background:#c8e6c9;border-left:4px solid #388e3c;'
	};
	return isAutofixed ? fixStyle : styles[severity] || styles.Info
}
function ar_logIssueDetails(element, recommendation, wcagPrinciple, wcagGuideline, wcagLevel, isAutofixed, severity) {
	if (element instanceof HTMLElement) {
		console.log('%cElement:', 'font-weight:bold;color:#424242;margin-left:15px;', element)
	} else if (typeof element === 'string') {
		console.log(`%cContext: %c${ element }`, 'font-weight:bold;color:#424242;margin-left:15px;', 'color:#424242;')
	}
	if (recommendation && (!isAutofixed || severity === 'Critical' || severity === 'Moderate')) {
		console.log(`%cRecommendation: %c${ recommendation }`, 'font-weight:bold;color:#0d47a1;margin-left:15px;padding-left:8px;border-left:3px solid #bbdefb;', 'color:#1565c0;')
	}
	if (wcagGuideline) {
		console.log(`%cWCAG: %c${ wcagGuideline } (${ wcagLevel }) - ${ wcagPrinciple }`, 'font-weight:bold;color:#4a148c;margin-left:15px;padding-left:8px;border-left:3px solid #e1bee7;', 'color:#6a1b9a;')
	}
}
function ar_logAccessibilityIssue(severity, message, element = null, recommendation = '', wcagPrinciple = '', wcagGuideline = '', isAutofixed = false, wcagLevel = 'A') {
	let elId = 'global', elSig = '';
	if (element instanceof HTMLElement) {
		elId = element.id || element.dataset.arGeneratedId || (element.dataset.arGeneratedId = ar_generateUniqueElementId('el-tracked-'));
		if (wcagGuideline === '1.4.3 Contrast (Minimum)') {
			const style = window.getComputedStyle(element);
			const fg = style.color;
			const bg = ar_getEffectiveBackgroundColorOfElement(element).join(',');
			elSig = `::${ fg }-${ bg }`
		}
	}
	const baseMsgKey = message.substring(0, 40).replace(/\s+/g, '_').replace(/[^\w-]/g, '');
	let issueKey = `${ elId }::${ wcagGuideline || baseMsgKey }${ elSig }::${ severity }`;
	if (message.toLowerCase().includes('autofix attempt failed') && wcagGuideline === '1.4.3 Contrast (Minimum)') {
		const origKey = `${ elId }::${ wcagGuideline }${ elSig }::Critical`;
		if (ar_loggedIssuesTracker.has(origKey))
			return;
		issueKey = origKey
	}
	if (ar_loggedIssuesTracker.has(issueKey) && !isAutofixed)
		return;
	ar_loggedIssuesTracker.add(issueKey);
	ar_totalScannedIssuesCounter++;
	ar_accessibilityIssuesLog.push({
		id: `ar-issue-${ ar_totalScannedIssuesCounter }`,
		severity,
		message,
		element,
		recommendation,
		wcagPrinciple,
		wcagGuideline,
		isAutofixed,
		wcagLevel
	});
	const logMeta = ar_getLogMeta(severity, isAutofixed);
	console.groupCollapsed(`%c${ logMeta.p } %c${ message }`, `${ logMeta.s }font-weight:bold;padding:4px 8px;border-radius:4px 0 0 4px;`, 'font-weight:normal;padding:4px 8px;');
	ar_logIssueDetails(element, recommendation, wcagPrinciple, wcagGuideline, wcagLevel, isAutofixed, severity);
	console.groupEnd();
	if (isAutofixed)
		ar_totalAutoFixedIssuesCounter++
}
function ar_logSection(title) {
	console.groupCollapsed(`%c🔎 ${ title } %c`, 'background-color:#e8f0fe;color:#174ea6;font-weight:bold;padding:6px 12px;border-radius:5px;border:1px solid #d0d8e0;margin-bottom:5px;display:inline-block;', '')
}
function ar_escapeHtml(str) {
    if (typeof str !== "string") return str;
    return str
	.replace(/&/g, "&amp;")
	.replace(/</g, "&lt;")
	.replace(/>/g, "&gt;")
	.replace(/"/g, "&quot;")
	.replace(/'/g, "&#39;");
}
function ar_hasAriaLabel(el) {
	return el.getAttribute('aria-label') && el.getAttribute('aria-label').trim();
}
function ar_hasAriaLabelledby(el) {
	const labelledbyAttr = el.getAttribute('aria-labelledby');
	if (!labelledbyAttr)
		return false;
	return labelledbyAttr.split(/\s+/).some(id => {
		const lblEl = document.getElementById(id);
		return lblEl && (lblEl.textContent || '').trim();
	});
}
function ar_hasTextOrValue(el) {
	return (el.textContent || '').trim() || (el.value || '').trim();
}
function ar_hasImageWithAltInAnchor(el) {
	const img = el.querySelector('img[alt]');
	return img && (img.alt || '').trim();
}
function ar_hasImageAlt(el) {
	return (el.alt || '').trim();
}
function ar_hasFigcaption(el) {
	const figcaption = el.querySelector('figcaption');
	return figcaption && (figcaption.textContent || '').trim();
}
function ar_hasExplicitLabel(el) {
	if (!el.id)
		return false;
	const labels = document.querySelectorAll(`label[for="${ el.id }"]`);
	return Array.from(labels).some(lbl => (lbl.textContent || '').trim() || lbl.querySelector('img[alt]'));
}
function ar_hasParentLabel(el) {
	const parentLbl = el.closest('label');
	return parentLbl && (parentLbl.textContent || '').trim() && (!parentLbl.htmlFor || parentLbl.htmlFor === el.id);
}
function ar_hasTitleAttr(el) {
	return !!(el.getAttribute('title') && el.getAttribute('title').trim());
}
function ar_hasAccessibleNameForElement(element) {
	if (!element)
		return false;
	if (ar_hasAriaLabel(element) || ar_hasAriaLabelledby(element))
		return true;
	const tagName = element.tagName.toUpperCase();
	if ((tagName === 'BUTTON' || tagName === 'INPUT' && [
			'submit',
			'reset',
			'button'
		].includes(element.type)) && ar_hasTextOrValue(element))
		return true;
	if (tagName === 'A' && (ar_hasTextOrValue(element) || ar_hasImageWithAltInAnchor(element)))
		return true;
	if (tagName === 'IMG' && ar_hasImageAlt(element))
		return true;
	if (tagName === 'INPUT' && element.type === 'image' && ar_hasImageAlt(element))
		return true;
	if (tagName === 'FIGURE' && ar_hasFigcaption(element))
		return true;
	if ([
			'INPUT',
			'SELECT',
			'TEXTAREA'
		].includes(tagName) && (ar_hasExplicitLabel(element) || ar_hasParentLabel(element)))
		return true;
	return ar_hasTitleAttr(element);
}
function ar_setAttributeAndLog(el, attr, val, sev, msg, rec, princ, guide, level = 'A') {
	try {
		if (attr === 'textContent')
			el.textContent = val;
		else
			el.setAttribute(attr, val);
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1;
	} catch (e) {
		console.error(`setAttribute Error: ${ attr }=${ val } on`, el, e);
		return 0;
	}
}
function ar_removeAttributeAndLog(el, attr, sev, msg, rec, princ, guide, level = 'A') {
	try {
		el.removeAttribute(attr);
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1;
	} catch (e) {
		console.error(`removeAttribute Error: ${ attr } on`, el, e);
		return 0;
	}
}
function ar_applyStylesAndLog(el, styles, sev, msg, rec, princ, guide, level = 'A') {
	try {
		for (const prop in styles) {
			el.style.setProperty(prop, styles[prop]);
		}
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1;
	} catch (e) {
		console.error('applyStyles Error:', el, styles, e);
		return 0;
	}
}
function ar_storeOriginalInlineStyle(element, cssProperty) {
	if (!ar_originalElementStylesMap.has(element)) {
		ar_originalElementStylesMap.set(element, {});
	}
	const elementOriginalStyles = ar_originalElementStylesMap.get(element);
	if (elementOriginalStyles[cssProperty] === undefined) {
		elementOriginalStyles[cssProperty] = element.style.getPropertyValue(cssProperty);
	}
}
function ar_restoreOriginalInlineStyle(element, cssProperty) {
	if (ar_originalElementStylesMap.has(element)) {
		const elementOriginalStyles = ar_originalElementStylesMap.get(element);
		if (elementOriginalStyles[cssProperty] !== undefined) {
			element.style.setProperty(cssProperty, elementOriginalStyles[cssProperty]);
		} else {
			element.style.removeProperty(cssProperty);
		}
	}
}
function ar_getElementsForMenuTextStyleAdjustments() {
	const menuElements = [
		document.getElementById('aaa-menu-button'),
		document.getElementById('aaa-menu-panel'),
		document.getElementById('aaa-page-structure-panel')
	].filter(Boolean);
	return Array.from(document.querySelectorAll(AR_SELECTOR_STRINGS.TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU)).filter(el => {
		return !menuElements.some(menuEl => menuEl.contains(el));
	});
}

var AR_AccessibilityMenu = AR_AccessibilityMenu || {};
(function (Menu) {
	const MENU_BUTTON_ID = 'aaa-menu-button';
	const MENU_PANEL_ID = 'aaa-menu-panel';
	const PAGE_STRUCTURE_PANEL_ID = 'aaa-page-structure-panel';
	const READING_MASK_TOP_ID = 'aaa-reading-mask-top';
	const READING_MASK_BOTTOM_ID = 'aaa-reading-mask-bottom';
	const READING_LINE_ID = 'aaa-reading-line';
	const FONT_SIZE_MULTIPLIER = 1.08;
	const STORAGE_KEY = 'AR_AccessibilityMenu_Settings';
	const EDGE_MARGIN_PX = 38;
	const CLASS_HIGH_CONTRAST = 'ar-aaa-high-contrast';
	const CLASS_INVERT_COLORS = 'ar-aaa-invert-colors';
	const CLASS_DARK_CONTRAST = 'ar-aaa-dark-contrast';
	const CLASS_HIGHLIGHT_LINKS = 'ar-aaa-highlight-links';
	const CLASS_ENHANCED_FOCUS = 'ar-aaa-enhanced-focus';
	const CLASS_ANIMATIONS_STOPPED = 'ar-aaa-animations-stopped';
	const CLASS_DYSLEXIA_FONT = 'ar-aaa-dyslexia-font';
	const CLASS_READING_MODE = 'ar-aaa-reading-mode';
	const CLASS_TEMP_HIGHLIGHT = 'ar-aaa-temp-highlight';
	const CLASS_TEXT_SCALED = 'ar-text-scaled-by-menu';
	Menu.isOpen = false;
	Menu.isDyslexiaFontActive = false;
	Menu.activeContrastMode = 'default';
	Menu.areLinksHighlighted = false;
	Menu.isFocusEnhanced = false;
	Menu.areAnimationsStopped = false;
	Menu.isReadingAloud = false;
	Menu.fontScaleLevel = 0;
	Menu.isReadingModeActive = false;
	Menu.isReadingMaskActive = false;
	Menu.isReadingLineActive = false;
	Menu.isStructurePanelOpen = false;
	Menu.isPanelDragging = false;
	Menu.isButtonDragging = false;
	Menu.buttonDragOccurred = false;
	Menu.buttonWasDragged = false;
	Menu.panelWasDragged = false;
	Menu._originalFontSizes = new Map();
	Menu._initialButtonX = 0;
	Menu._initialButtonY = 0;
	Menu._initialPanelX = 0;
	Menu._initialPanelY = 0;
	Menu._initialMouseX = 0;
	Menu._initialMouseY = 0;
	Menu._panelRelativeOffsetX = 0;
	Menu._panelRelativeOffsetY = 0;
	Menu.readingMaskTop = null;
	Menu.readingMaskBottom = null;
	Menu.readingLine = null;
	Menu.pageStructurePanel = null;
	Menu.profiles = {
		'motor': {
			settings: {
				enhancedFocus: true,
				stopAnimations: true
			},
			labelKey: 'profileMotor',
			iconPath: '<path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"/>'
		},
		'adhd': {
			settings: {
				stopAnimations: true,
				readingMode: true,
				readingLine: true
			},
			labelKey: 'profileADHD',
			iconPath: '<path d="M11.5,6C8.46,6 5.83,7.43 4.42,9.59L2.93,8.1L1.87,9.16L3.87,11.16C3.67,11.46 3.5,11.72 3.5,12C3.5,12.28 3.67,12.54 3.87,12.84L1.87,14.84L2.93,15.9L4.42,14.41C5.83,16.57 8.46,18 11.5,18C14.54,18 17.17,16.57 18.58,14.41L20.07,15.9L21.13,14.84L19.13,12.84C19.33,12.54 19.5,12.28 19.5,12C19.5,11.72 19.33,11.46 19.13,11.16L21.13,9.16L20.07,8.1L18.58,9.59C17.17,7.43 14.54,6 11.5,6M11.5,8A4.5,4.5 0 0,1 16,12.5A4.5,4.5 0 0,1 11.5,17A4.5,4.5 0 0,1 7,12.5A4.5,4.5 0 0,1 11.5,8M11.5,10A2.5,2.5 0 0,0 9,12.5A2.5,2.5 0 0,0 11.5,15A2.5,2.5 0 0,0 14,12.5A2.5,2.5 0 0,0 11.5,10Z"/>'
		},
		'epileptic': {
			settings: { stopAnimations: true },
			labelKey: 'profileEpileptic',
			iconPath: '<path d="M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1Z"/>'
		},
		'vision': {
			settings: {
				fontScaleLevel: 2,
				highlightLinks: true,
				activeContrastMode: 'dark'
			},
			labelKey: 'profileVision',
			iconPath: '<path d="M12,4.5C7,4.5 2.73,7.61 1,12c1.73,4.39 6,7.5 11,7.5s9.27-3.11 11-7.5C21.27,7.61 17,4.5 12,4.5zM12,17a4.5,4.5 0 1,1 0-9 4.5,4.5 0 0,1 0,9zm0-7a2.5,2.5 0 0,0 0,5 2.5,2.5 0 0,0 0-5z"/>'
		}
	};
	Menu.translations = {
		'he': {
			menuTitle: 'כלי נגישות',
			increaseText: 'הגדל טקסט',
			decreaseText: 'הקטן טקסט',
			highContrast: 'ניגודיות גבוהה (בהיר)',
			invertColors: 'היפוך צבעים',
			darkContrast: 'ניגודיות גבוהה (כהה)',
			highlightLinks: 'הדגש קישורים',
			enhancedFocus: 'מיקוד משופר',
			stopAnimations: 'עצור אנימציות',
			dyslexiaFont: 'גופן דיסלקטי',
			readAloud: 'קרא בקול',
			readingMode: 'מצב קריאה',
			readingMask: 'מסכת קריאה',
			readingLine: 'קו קריאה',
			pageStructure: 'מבנה עמוד',
			pageStructureTitle: 'מבנה עמוד',
			headings: 'כותרות',
			landmarks: 'נקודות ציון',
			links: 'קישורים',
			noItemsFound: 'לא נמצאו פריטים.',
			profilesTitle: 'פרופילי נגישות',
			profileMotor: 'לקויות מוטוריות',
			profileADHD: 'הפרעת קשב',
			profileEpileptic: 'אפילפסיה',
			profileVision: 'לקות ראייה',
			resetAll: 'איפוס הכל',
			closeMenu: 'סגור תפריט',
			closeStructurePanel: 'סגור מבנה עמוד',
			accessibilityIcon: 'אייקון נגישות',
			textSize: 'גודל טקסט',
			contrast: 'ניגודיות',
			highlight: 'הדגשה',
			animation: 'אנימציה',
			fontStyle: 'סגנון גופן',
			reset: 'איפוס',
			readAloudIcon: 'אייקון קריאה בקול',
			readingModeIcon: 'אייקון מצב קריאה',
			readingMaskIcon: 'אייקון מסכת קריאה',
			readingLineIcon: 'אייקון קו קריאה',
			pageStructureIcon: 'אייקון מבנה עמוד',
			profileIcon: 'אייקון פרופיל',
			speechNotSupported: 'סינתזת דיבור אינה נתמכת בדפדפן זה.',
			mainContent: 'תוכן ראשי',
			navigation: 'ניווט',
			header: 'כותרת עליונה',
			footer: 'כותרת תחתונה',
			complementary: 'תוכן משלים (סרגל צד)',
			form: 'טופס',
			search: 'חיפוש',
			region: 'אזור',
			unlabeled: 'ללא תווית'
		},
		'en': {
			menuTitle: 'Accessibility Tools',
			increaseText: 'Increase Text',
			decreaseText: 'Decrease Text',
			highContrast: 'High Contrast (Light)',
			invertColors: 'Invert Colors',
			darkContrast: 'High Contrast (Dark)',
			highlightLinks: 'Highlight Links',
			enhancedFocus: 'Enhanced Focus',
			stopAnimations: 'Stop Animations',
			dyslexiaFont: 'Dyslexia Font',
			readAloud: 'Read Aloud',
			readingMode: 'Reading Mode',
			readingMask: 'Reading Mask',
			readingLine: 'Reading Line',
			pageStructure: 'Page Structure',
			pageStructureTitle: 'Page Structure',
			headings: 'Headings',
			landmarks: 'Landmarks',
			links: 'Links',
			noItemsFound: 'No items found.',
			profilesTitle: 'Accessibility Profiles',
			profileMotor: 'Motor Impairment',
			profileADHD: 'ADHD Focus',
			profileEpileptic: 'Epilepsy Safe',
			profileVision: 'Low Vision',
			resetAll: 'Reset All',
			closeMenu: 'Close Menu',
			closeStructurePanel: 'Close Structure Panel',
			accessibilityIcon: 'Accessibility Icon',
			textSize: 'Text Size',
			contrast: 'Contrast',
			highlight: 'Highlight',
			animation: 'Animation',
			fontStyle: 'Font Style',
			reset: 'Reset',
			readAloudIcon: 'Read Aloud Icon',
			readingModeIcon: 'Reading Mode Icon',
			readingMaskIcon: 'Reading Mask Icon',
			readingLineIcon: 'Reading Line Icon',
			pageStructureIcon: 'Page Structure Icon',
			profileIcon: 'Profile Icon',
			speechNotSupported: 'Speech synthesis not supported in this browser.',
			mainContent: 'Main Content',
			navigation: 'Navigation',
			header: 'Header',
			footer: 'Footer',
			complementary: 'Sidebar',
			form: 'Form',
			search: 'Search',
			region: 'Region',
			unlabeled: 'Unlabeled'
		}
	};
	Menu._getLocalizedString = function (key) {
		let lang = document.documentElement.lang || navigator.language || 'en';
		lang = lang.split('-')[0];
		if (Menu.translations[lang] && Menu.translations[lang][key]) {
			return Menu.translations[lang][key];
		}
		return Menu.translations['en'][key] || key;
	};
	function getClientCoords(event) {
		if (event.touches && event.touches.length > 0) {
			return {
				clientX: event.touches[0].clientX,
				clientY: event.touches[0].clientY
			};
		}
		return {
			clientX: event.clientX,
			clientY: event.clientY
		};
	}
	function logAction(message, isUserAction = false) {
		console.log(`[ARMenu] ${ message } ${ isUserAction ? '(User Action)' : '' }`);
	}
	function showCustomMessage(message) {
		const existingModal = document.getElementById('ar-aaa-message-modal');
		if (existingModal) {
			existingModal.remove();
		}
		const modal = document.createElement('div');
		modal.id = 'ar-aaa-message-modal';
		modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 2px solid black;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 2147483647;
            text-align: center;
            font-family: 'Inter', Arial, sans-serif;
            max-width: 90%;
            width: 300px;
        `;
		const messageText = document.createElement('p');
		messageText.textContent = message;
		messageText.style.marginBottom = '15px';
		messageText.style.color = 'black';
		const closeButton = document.createElement('button');
		closeButton.textContent = 'OK';
		closeButton.style.cssText = `
            padding: 8px 20px;
            background-color: #000000;
            color: #ffffff;
            border: 1px solid #000000;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            font-family: 'Inter', Arial, sans-serif;
        `;
		closeButton.addEventListener('click', () => modal.remove());
		modal.appendChild(messageText);
		modal.appendChild(closeButton);
		document.body.appendChild(modal);
		closeButton.focus();
	}
	Menu.init = function () {
		if (document.getElementById(MENU_BUTTON_ID)) {
			logAction('Already initialized.');
			return;
		}
		this._createMenuButton();
		if (typeof Menu.panel !== 'undefined' && typeof Menu.panel.createMenuPanel === 'function') {
			Menu.panel.createMenuPanel();
			Menu.panel.createReadingAidElements();
			Menu.panel.createPageStructurePanel();
			this._attachEventListeners();
		} else {
			console.error('ARMenu: panel.js not loaded or not properly initialized.');
			return;
		}
		this._loadSettings();
		logAction('Initialized successfully.');
	};
	Menu._createMenuButton = function () {
		const btn = document.createElement('button');
		btn.id = MENU_BUTTON_ID;
		btn.setAttribute('aria-label', this._getLocalizedString('menuTitle'));
		btn.setAttribute('aria-expanded', 'false');
		btn.setAttribute('aria-controls', MENU_PANEL_ID);
		const accessibilityIconSVG = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"/></svg>';
		btn.innerHTML = `<span class="ar-aaa-menu-icon" role="img" aria-label="${ this._getLocalizedString('accessibilityIcon') }">${ accessibilityIconSVG }</span>`;
		btn.style.right = '20px';
		btn.style.top = '50%';
		btn.style.transform = 'translateY(-50%)';
		btn.style.left = 'auto';
		btn.style.bottom = 'auto';
		document.body.appendChild(btn);
		btn.addEventListener('mousedown', this._handleButtonMouseDown.bind(this));
		btn.addEventListener('touchstart', this._handleButtonMouseDown.bind(this), { passive: false });
	};
	Menu._attachEventListeners = function () {
		const menuButton = document.getElementById(MENU_BUTTON_ID);
		const menuPanel = document.getElementById(MENU_PANEL_ID);
		if (menuButton) {
			menuButton.addEventListener('click', this._handleMenuButtonClick.bind(this));
		}
		if (menuPanel) {
			menuPanel.addEventListener('click', this._handlePanelActionClick.bind(this));
			menuPanel.addEventListener('keydown', this._handlePanelKeydown.bind(this));
			menuPanel.addEventListener('mousedown', this._handlePanelMouseDown.bind(this));
			menuPanel.addEventListener('touchstart', this._handlePanelMouseDown.bind(this), { passive: false });
		}
		document.addEventListener('mousemove', this._handleDocumentMouseMove.bind(this));
		document.addEventListener('mousemove', this._handleReadingAidMouseMove.bind(this));
		document.addEventListener('mouseup', this._handleDocumentMouseUp.bind(this));
		document.addEventListener('touchmove', this._handleDocumentMouseMove.bind(this), { passive: false });
		document.addEventListener('touchend', this._handleDocumentMouseUp.bind(this));
		document.addEventListener('keydown', this._handleTabKeyFocusTrap.bind(this));
		window.addEventListener('resize', this._handleWindowResize.bind(this));
		document.addEventListener('DOMContentLoaded', () => {
			if (Menu.pageStructurePanel) {
				Menu.pageStructurePanel.addEventListener('keydown', this._handleStructurePanelKeydown.bind(this));
			}
		});
	};
	Menu._handleStructurePanelKeydown = function (event) {
		if (event.key === 'Escape' && Menu.isStructurePanelOpen) {
			this._togglePageStructurePanel(false);
		}
	};
	Menu._handleReadingAidMouseMove = function (event) {
		if (Menu.isReadingMaskActive && Menu.readingMaskTop && Menu.readingMaskBottom) {
			const mouseY = event.clientY;
			const maskHeight = 80;
			Menu.readingMaskTop.style.height = `${ mouseY - maskHeight / 2 }px`;
			Menu.readingMaskBottom.style.height = `${ window.innerHeight - (mouseY + maskHeight / 2) }px`;
		}
		if (Menu.isReadingLineActive && Menu.readingLine) {
			Menu.readingLine.style.top = `${ event.clientY }px`;
		}
	};
	Menu._handleWindowResize = function () {
		const button = document.getElementById(MENU_BUTTON_ID);
		const panel = document.getElementById(MENU_PANEL_ID);
		if (!button)
			return;
		if (Menu.buttonWasDragged) {
			const buttonWidth = button.offsetWidth;
			const buttonHeight = button.offsetHeight;
			let currentLeft = parseFloat(button.style.left);
			let currentTop = parseFloat(button.style.top);
			const newButtonX = Math.max(EDGE_MARGIN_PX, Math.min(currentLeft, window.innerWidth - buttonWidth - EDGE_MARGIN_PX));
			const newButtonY = Math.max(EDGE_MARGIN_PX, Math.min(currentTop, window.innerHeight - buttonHeight - EDGE_MARGIN_PX));
			if (parseFloat(button.style.left) !== newButtonX || parseFloat(button.style.top) !== newButtonY) {
				button.style.left = `${ newButtonX }px`;
				button.style.top = `${ newButtonY }px`;
			}
			if (this.isOpen && panel && Menu.panelWasDragged) {
				const panelWidth = panel.offsetWidth;
				const panelHeight = panel.offsetHeight;
				let panelNewLeft = newButtonX + Menu._panelRelativeOffsetX;
				let panelNewTop = newButtonY + Menu._panelRelativeOffsetY;
				panelNewLeft = Math.max(EDGE_MARGIN_PX, Math.min(panelNewLeft, window.innerWidth - panelWidth - EDGE_MARGIN_PX));
				panelNewTop = Math.max(EDGE_MARGIN_PX, Math.min(panelNewTop, window.innerHeight - panelHeight - EDGE_MARGIN_PX));
				panel.style.left = `${ panelNewLeft }px`;
				panel.style.top = `${ panelNewTop }px`;
				panel.style.right = 'auto';
				panel.style.bottom = 'auto';
				Menu._panelRelativeOffsetX = panelNewLeft - newButtonX;
				Menu._panelRelativeOffsetY = panelNewTop - newButtonY;
			} else if (this.isOpen && panel) {
				this._positionPanelRelativeToButton(button, panel);
			}
		} else if (this.isOpen && panel) {
			this._positionPanelRelativeToButton(button, panel);
		}
	};
	Menu._positionPanelRelativeToButton = function (button, panel) {
		if (!button || !panel)
			return;
		const buttonRect = button.getBoundingClientRect();
		const panelRect = panel.getBoundingClientRect();
		let newTop = buttonRect.top - panelRect.height - 10;
		let newLeft = buttonRect.left;
		const docDir = document.documentElement.dir || window.getComputedStyle(document.documentElement).direction;
		if (docDir === 'rtl') {
			newLeft = buttonRect.right - panelRect.width;
		}
		if (newTop < EDGE_MARGIN_PX) {
			newTop = Math.max(EDGE_MARGIN_PX, buttonRect.bottom + 10);
		}
		if (newTop + panelRect.height > window.innerHeight - EDGE_MARGIN_PX) {
			newTop = Math.max(EDGE_MARGIN_PX, window.innerHeight - panelRect.height - EDGE_MARGIN_PX);
		}
		if (newLeft < EDGE_MARGIN_PX)
			newLeft = EDGE_MARGIN_PX;
		if (newLeft + panelRect.width > window.innerWidth - EDGE_MARGIN_PX) {
			newLeft = Math.max(EDGE_MARGIN_PX, window.innerWidth - panelRect.width - EDGE_MARGIN_PX);
		}
		panel.style.top = `${ newTop }px`;
		panel.style.left = `${ newLeft }px`;
		panel.style.bottom = 'auto';
		panel.style.right = 'auto';
		Menu._panelRelativeOffsetX = newLeft - buttonRect.left;
		Menu._panelRelativeOffsetY = newTop - buttonRect.top;
	};
	Menu._handleMenuButtonClick = function (event) {
		if (Menu.buttonDragOccurred) {
			Menu.buttonDragOccurred = false;
			return;
		}
		this.toggleMenu();
	};
	Menu._handlePanelActionClick = function (event) {
		console.log('Menu panel click detected:', event.target);
		const targetButton = event.target.closest('button');
		if (targetButton && targetButton.dataset.action) {
			console.log('Action button clicked:', targetButton.dataset.action);
			try {
				this.handleAction(targetButton.dataset.action, targetButton);
			} catch (e) {
				console.error('Error handling menu action:', targetButton.dataset.action, e);
			}
		} else {
			console.log('Click did not originate from a button with a data-action attribute.');
		}
	};
	Menu._handlePanelKeydown = function (event) {
		if (event.key === 'Escape' && this.isOpen) {
			this.toggleMenu();
		}
	};
	Menu._handleTabKeyFocusTrap = function (event) {
		if (!this.isOpen && !Menu.isStructurePanelOpen)
			return;
		const activePanel = Menu.isStructurePanelOpen ? Menu.pageStructurePanel : document.getElementById(MENU_PANEL_ID);
		if (!activePanel)
			return;
		const focusableElements = Array.from(activePanel.querySelectorAll('button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"]):not([disabled])')).filter(el => el.offsetWidth > 0 || el.offsetHeight > 0 || el === document.activeElement);
		if (focusableElements.length === 0)
			return;
		const firstFocusableEl = focusableElements[0];
		const lastFocusableEl = focusableElements[focusableElements.length - 1];
		if (event.key === 'Tab') {
			if (event.shiftKey) {
				if (document.activeElement === firstFocusableEl) {
					lastFocusableEl.focus();
					event.preventDefault();
				}
			} else {
				if (document.activeElement === lastFocusableEl) {
					firstFocusableEl.focus();
					event.preventDefault();
				} else if (!focusableElements.includes(document.activeElement)) {
					firstFocusableEl.focus();
					event.preventDefault();
				}
			}
		}
	};
	Menu._startDragging = function (event, isButtonDrag) {
		const button = document.getElementById(MENU_BUTTON_ID);
		const panel = document.getElementById(MENU_PANEL_ID);
		if (!button || !panel)
			return;
		let draggedElement = isButtonDrag ? button : panel;
		if (!isButtonDrag) {
			const target = event.target;
			if (target.closest('button')) {
				this.isPanelDragging = false;
				return;
			}
			const isPanelItself = target === panel;
			const isPanelTitle = target === panel.querySelector('h3');
			if (!isPanelItself && !isPanelTitle) {
				this.isPanelDragging = false;
				return;
			}
		}
		this.isButtonDragging = isButtonDrag;
		this.isPanelDragging = !isButtonDrag;
		if (isButtonDrag) {
			Menu.buttonDragOccurred = false;
			Menu.buttonWasDragged = true;
		} else {
			Menu.panelWasDragged = true;
		}
		draggedElement.classList.add('dragging');
		const coords = getClientCoords(event);
		const buttonRect = button.getBoundingClientRect();
		const panelRect = panel.getBoundingClientRect();
		Menu._initialButtonX = buttonRect.left;
		Menu._initialButtonY = buttonRect.top;
		Menu._initialPanelX = panelRect.left;
		Menu._initialPanelY = panelRect.top;
		Menu._initialMouseX = coords.clientX;
		Menu._initialMouseY = coords.clientY;
		if (isButtonDrag && button.style.transform !== 'none') {
			button.style.transform = 'none';
		}
		if (Menu.isOpen) {
			Menu._panelRelativeOffsetX = panelRect.left - buttonRect.left;
			Menu._panelRelativeOffsetY = panelRect.top - buttonRect.top;
		} else {
			const estimatedPanelHeight = panel.offsetHeight || 300;
			const estimatedPanelWidth = panel.offsetWidth || 320;
			const docDir = document.documentElement.dir || window.getComputedStyle(document.documentElement).direction;
			if (docDir === 'rtl') {
				Menu._panelRelativeOffsetX = buttonRect.width - estimatedPanelWidth;
			} else {
				Menu._panelRelativeOffsetX = 0;
			}
			Menu._panelRelativeOffsetY = -estimatedPanelHeight - 10;
		}
		if (event.type === 'touchstart') {
			event.preventDefault();
		}
	};
	Menu._handleButtonMouseDown = function (event) {
		Menu.buttonDragOccurred = false;
		this._startDragging(event, true);
	};
	Menu._handlePanelMouseDown = function (event) {
		this._startDragging(event, false);
	};
	Menu._handleDocumentMouseMove = function (event) {
		if (!this.isButtonDragging && !this.isPanelDragging)
			return;
		const button = document.getElementById(MENU_BUTTON_ID);
		const panel = document.getElementById(MENU_PANEL_ID);
		if (!button || !panel)
			return;
		if (this.isButtonDragging) {
			Menu.buttonDragOccurred = true;
		}
		const coords = getClientCoords(event);
		const deltaX = coords.clientX - Menu._initialMouseX;
		const deltaY = coords.clientY - Menu._initialMouseY;
		let targetButtonX, targetButtonY;
		if (this.isButtonDragging) {
			targetButtonX = Menu._initialButtonX + deltaX;
			targetButtonY = Menu._initialButtonY + deltaY;
		} else if (this.isPanelDragging) {
			const targetPanelX = Menu._initialPanelX + deltaX;
			const targetPanelY = Menu._initialPanelY + deltaY;
			targetButtonX = targetPanelX - Menu._panelRelativeOffsetX;
			targetButtonY = targetPanelY - Menu._panelRelativeOffsetY;
		}
		const buttonWidth = button.offsetWidth;
		const buttonHeight = button.offsetHeight;
		targetButtonX = Math.max(EDGE_MARGIN_PX, Math.min(targetButtonX, window.innerWidth - buttonWidth - EDGE_MARGIN_PX));
		targetButtonY = Math.max(EDGE_MARGIN_PX, Math.min(targetButtonY, window.innerHeight - buttonHeight - EDGE_MARGIN_PX));
		button.style.left = `${ targetButtonX }px`;
		button.style.top = `${ targetButtonY }px`;
		button.style.transform = 'none';
		button.style.right = 'auto';
		button.style.bottom = 'auto';
		if (Menu.isOpen) {
			const panelWidth = panel.offsetWidth;
			const panelHeight = panel.offsetHeight;
			let desiredPanelX = targetButtonX + Menu._panelRelativeOffsetX;
			let desiredPanelY = targetButtonY + Menu._panelRelativeOffsetY;
			desiredPanelX = Math.max(EDGE_MARGIN_PX, Math.min(desiredPanelX, window.innerWidth - panelWidth - EDGE_MARGIN_PX));
			desiredPanelY = Math.max(EDGE_MARGIN_PX, Math.min(desiredPanelY, window.innerHeight - panelHeight - EDGE_MARGIN_PX));
			panel.style.left = `${ desiredPanelX }px`;
			panel.style.top = `${ desiredPanelY }px`;
			panel.style.right = 'auto';
			panel.style.bottom = 'auto';
			if (this.isButtonDragging) {
				let adjustedButtonX = desiredPanelX - Menu._panelRelativeOffsetX;
				let adjustedButtonY = desiredPanelY - Menu._panelRelativeOffsetY;
				adjustedButtonX = Math.max(EDGE_MARGIN_PX, Math.min(adjustedButtonX, window.innerWidth - buttonWidth - EDGE_MARGIN_PX));
				adjustedButtonY = Math.max(EDGE_MARGIN_PX, Math.min(adjustedButtonY, window.innerHeight - buttonHeight - EDGE_MARGIN_PX));
				if (button.style.left !== `${ adjustedButtonX }px` || button.style.top !== `${ adjustedButtonY }px`) {
					button.style.left = `${ adjustedButtonX }px`;
					button.style.top = `${ adjustedButtonY }px`;
				}
				Menu._panelRelativeOffsetX = desiredPanelX - adjustedButtonX;
				Menu._panelRelativeOffsetY = desiredPanelY - adjustedButtonY;
			}
		}
		if (event.type === 'touchmove') {
			event.preventDefault();
		}
	};
	Menu._handleDocumentMouseUp = function () {
		let settingsChanged = false;
		if (this.isButtonDragging) {
			this.isButtonDragging = false;
			const button = document.getElementById(MENU_BUTTON_ID);
			if (button)
				button.classList.remove('dragging');
			settingsChanged = true;
		}
		if (this.isPanelDragging) {
			this.isPanelDragging = false;
			const panel = document.getElementById(MENU_PANEL_ID);
			if (panel)
				panel.classList.remove('dragging');
			settingsChanged = true;
		}
		if (settingsChanged) {
			this._saveSettings();
		}
	};
	Menu.toggleMenu = function () {
		const panel = document.getElementById(MENU_PANEL_ID);
		const button = document.getElementById(MENU_BUTTON_ID);
		if (!panel || !button)
			return;
		this.isOpen = !this.isOpen;
		panel.style.display = this.isOpen ? 'block' : 'none';
		panel.classList.toggle('ar-aaa-menu-open', this.isOpen);
		panel.setAttribute('aria-hidden', String(!this.isOpen));
		button.setAttribute('aria-expanded', String(this.isOpen));
		if (this.isOpen) {
			if (!Menu.panelWasDragged || !panel.style.left || !panel.style.top) {
				this._positionPanelRelativeToButton(button, panel);
			}
			const firstFocusableButton = panel.querySelector('button:not([disabled])');
			if (firstFocusableButton) {
				firstFocusableButton.focus();
			}
		} else {
			button.focus();
		}
		logAction(`Menu ${ this.isOpen ? 'opened' : 'closed' }`);
		this._saveSettings();
	};
	Menu.handleAction = function (action, targetButton) {
		logAction(`Action: ${ action }`, true);
		if (action === 'close-menu') {
			this.toggleMenu();
			return;
		}
		if (action === 'close-structure-panel') {
			this._togglePageStructurePanel(false);
			return;
		}
		if (action.startsWith('profile-')) {
			const profileName = action.substring('profile-'.length);
			this._applyProfile(profileName);
			this._saveSettings();
			return;
		}
		switch (action) {
		case 'increase-text':
		case 'decrease-text':
			this._handleTextSizeAction(action, targetButton);
			break;
		case 'contrast-high':
		case 'contrast-invert':
		case 'contrast-dark':
			this._handleContrastAction(action, targetButton);
			break;
		case 'highlight-links':
		case 'enhanced-focus':
			this._handleHighlightAction(action, targetButton);
			break;
		case 'read-aloud':
			this._handleReadAloudAction(targetButton);
			break;
		case 'reading-mode':
			this._handleReadingModeAction(targetButton);
			break;
		case 'reading-mask':
			this._handleReadingMaskAction(targetButton);
			break;
		case 'reading-line':
			this._handleReadingLineAction(targetButton);
			break;
		case 'stop-animations':
			this._handleStopAnimationsAction(targetButton);
			break;
		case 'toggle-dyslexia-font':
			this._handleDyslexiaFontAction(targetButton);
			break;
		case 'reset-all':
			this._resetAllSettings();
			break;
		}
		if (action !== 'read-aloud') {
			this._saveSettings();
		}
	};
	Menu._togglePageStructurePanel = function (forceShow) {
		if (!Menu.pageStructurePanel)
			return;
		Menu.isStructurePanelOpen = forceShow !== undefined ? forceShow : !Menu.isStructurePanelOpen;
		Menu.pageStructurePanel.style.display = Menu.isStructurePanelOpen ? 'block' : 'none';
		Menu.pageStructurePanel.setAttribute('aria-hidden', String(!Menu.isStructurePanelOpen));
		if (Menu.isStructurePanelOpen) {
			if (typeof Menu.panel !== 'undefined' && typeof Menu.panel.populatePageStructurePanel === 'function') {
				Menu.panel.populatePageStructurePanel(null);
			}
			const firstFocusable = Menu.pageStructurePanel.querySelector('button, [href]');
			if (firstFocusable)
				firstFocusable.focus();
		} else {
			const menuButton = document.getElementById(MENU_BUTTON_ID);
			if (menuButton && Menu.isOpen) {
				const mainPanelFirstButton = document.getElementById(MENU_PANEL_ID) && document.getElementById(MENU_PANEL_ID).querySelector('button');
				if (mainPanelFirstButton)
					mainPanelFirstButton.focus();
				else
					menuButton.focus();
			} else if (menuButton) {
				menuButton.focus();
			}
		}
	};
	Menu._applyProfile = function (profileName) {
		const profile = Menu.profiles[profileName];
		if (!profile) {
			logAction(`Profile "${ profileName }" not found.`);
			return;
		}
		logAction(`Applying profile: ${ profileName }`);
		this._resetAllSettings(true);
		const panel = document.getElementById(MENU_PANEL_ID);
		if (!panel)
			return;
		if (profile.settings.fontScaleLevel !== undefined) {
			Menu.fontScaleLevel = profile.settings.fontScaleLevel;
			this._applyFontScaleToElements();
		}
		if (profile.settings.activeContrastMode) {
			panel.querySelectorAll('button[data-action^="contrast-"]').forEach(btn => {
				this._updateButtonActiveState(btn, false);
			});
			const contrastButton = panel.querySelector(`button[data-action="contrast-${ profile.settings.activeContrastMode }"]`);
			if (contrastButton)
				this._handleContrastAction(`contrast-${ profile.settings.activeContrastMode }`, contrastButton);
		}
		if (profile.settings.highlightLinks) {
			const hlButton = panel.querySelector('button[data-action="highlight-links"]');
			if (hlButton && !Menu.areLinksHighlighted)
				this._handleHighlightAction('highlight-links', hlButton);
		}
		if (profile.settings.enhancedFocus) {
			const efButton = panel.querySelector('button[data-action="enhanced-focus"]');
			if (efButton && !Menu.isFocusEnhanced)
				this._handleHighlightAction('enhanced-focus', efButton);
		}
		if (profile.settings.stopAnimations) {
			const saButton = panel.querySelector('button[data-action="stop-animations"]');
			if (saButton) {
				Menu.areAnimationsStopped = false;
				this._handleStopAnimationsAction(saButton);
			}
		}
		if (profile.settings.dyslexiaFont) {
			const dfButton = panel.querySelector('button[data-action="toggle-dyslexia-font"]');
			if (dfButton && !Menu.isDyslexiaFontActive)
				this._handleDyslexiaFontAction(dfButton);
		}
		if (profile.settings.readingMode) {
			const rmButton = panel.querySelector('button[data-action="reading-mode"]');
			if (rmButton && !Menu.isReadingModeActive)
				this._handleReadingModeAction(rmButton);
		}
		if (profile.settings.readingMask) {
			const rmaskButton = panel.querySelector('button[data-action="reading-mask"]');
			if (rmaskButton && !Menu.isReadingMaskActive)
				this._handleReadingMaskAction(rmaskButton);
		}
		if (profile.settings.readingLine) {
			const rlineButton = panel.querySelector('button[data-action="reading-line"]');
			if (rlineButton && !Menu.isReadingLineActive)
				this._handleReadingLineAction(rlineButton);
		}
	};
	Menu._updateButtonActiveState = function (buttonElement, isActive) {
		if (!buttonElement)
			return;
		const action = buttonElement.dataset.action;
		if (action && action.startsWith('contrast-')) {
			const parentGroup = buttonElement.closest('.ar-aaa-button-row') || buttonElement.closest('.ar-aaa-menu-group');
			if (parentGroup) {
				parentGroup.querySelectorAll('button[data-action^="contrast-"]').forEach(btn => {
					btn.classList.remove('ar-aaa-menu-btn-active');
				});
			}
			if (isActive) {
				buttonElement.classList.add('ar-aaa-menu-btn-active');
			}
		} else {
			buttonElement.classList.toggle('ar-aaa-menu-btn-active', isActive);
		}
	};
	Menu._applyFontScaleToElements = function () {
		let elements = [];
		if (typeof window.ar_getElementsForMenuTextStyleAdjustments === 'function') {
			elements = window.ar_getElementsForMenuTextStyleAdjustments();
		}
		if (!elements || elements.length === 0) {
			elements = Array.from(document.querySelectorAll(':is(p, li, span, div:not(#' + MENU_PANEL_ID + '):not(#' + MENU_BUTTON_ID + '):not([class*="icon"]):not(:empty),' + 'h1, h2, h3, h4, h5, h6, a, label, td, th, caption, strong, em, b, i, small, big, sub, sup):not(:has(:not(span)))')).filter(el => el.closest(`#${ MENU_PANEL_ID }`) === null && el.closest(`#${ MENU_BUTTON_ID }`) === null);
		}
		elements.forEach(el => {
			if (!document.body.contains(el))
				return;
			if (!Menu._originalFontSizes.has(el)) {
				const initialComputedPx = parseFloat(window.getComputedStyle(el).fontSize);
				Menu._originalFontSizes.set(el, {
					inline: el.style.fontSize || '',
					initialPx: initialComputedPx
				});
			}
			const sizeData = Menu._originalFontSizes.get(el);
			let newSize = sizeData.initialPx * Math.pow(FONT_SIZE_MULTIPLIER, Menu.fontScaleLevel);
			if (newSize < 8)
				newSize = 8;
			if (newSize > 72)
				newSize = 72;
			el.classList.add(CLASS_TEXT_SCALED);
			el.style.setProperty('--ar-scaled-font-size', newSize + 'px');
		});
	};
	Menu._handleTextSizeAction = function (action, button) {
		if (action === 'increase-text') {
			Menu.fontScaleLevel++;
		} else if (action === 'decrease-text') {
			Menu.fontScaleLevel--;
		}
		this._applyFontScaleToElements();
	};
	Menu._handleContrastAction = function (action, button) {
		const htmlEl = document.documentElement;
		const bodyEl = document.body;
		const isHighContrastAction = action === 'contrast-high';
		const isInvertColorsAction = action === 'contrast-invert';
		const isDarkContrastAction = action === 'contrast-dark';
		let newMode = 'default';
		if (isHighContrastAction) {
			newMode = this.activeContrastMode === 'high' ? 'default' : 'high';
		} else if (isInvertColorsAction) {
			newMode = this.activeContrastMode === 'inverted' ? 'default' : 'inverted';
		} else if (isDarkContrastAction) {
			newMode = this.activeContrastMode === 'dark' ? 'default' : 'dark';
		}
		htmlEl.classList.remove(CLASS_INVERT_COLORS);
		bodyEl.classList.remove(CLASS_HIGH_CONTRAST, CLASS_DARK_CONTRAST);
		const parentGroup = button.closest('.ar-aaa-button-row') || button.closest('.ar-aaa-menu-group');
		if (parentGroup) {
			parentGroup.querySelectorAll('button[data-action^="contrast-"]').forEach(btn => {
				this._updateButtonActiveState(btn, false);
			});
		}
		if (newMode === 'high') {
			bodyEl.classList.add(CLASS_HIGH_CONTRAST);
			this._updateButtonActiveState(button, true);
		} else if (newMode === 'inverted') {
			htmlEl.classList.add(CLASS_INVERT_COLORS);
			this._updateButtonActiveState(button, true);
		} else if (newMode === 'dark') {
			bodyEl.classList.add(CLASS_DARK_CONTRAST);
			this._updateButtonActiveState(button, true);
		}
		this.activeContrastMode = newMode;
		logAction(`Contrast mode set to: ${ this.activeContrastMode }`);
	};
	Menu._handleHighlightAction = function (action, button) {
		const body = document.body;
		if (action === 'highlight-links') {
			this.areLinksHighlighted = !this.areLinksHighlighted;
			body.classList.toggle(CLASS_HIGHLIGHT_LINKS, this.areLinksHighlighted);
			this._updateButtonActiveState(button, this.areLinksHighlighted);
			logAction(`Highlight links ${ this.areLinksHighlighted ? 'enabled' : 'disabled' }. Class on body: ${ body.classList.contains(CLASS_HIGHLIGHT_LINKS) }`);
		} else if (action === 'enhanced-focus') {
			this.isFocusEnhanced = !this.isFocusEnhanced;
			body.classList.toggle(CLASS_ENHANCED_FOCUS, this.isFocusEnhanced);
			this._updateButtonActiveState(button, this.isFocusEnhanced);
			logAction(`Enhanced focus ${ this.isFocusEnhanced ? 'enabled' : 'disabled' }. Class on body: ${ body.classList.contains(CLASS_ENHANCED_FOCUS) }`);
		}
	};
	Menu._handleReadAloudAction = function (button) {
		if (!('speechSynthesis' in window)) {
			showCustomMessage(this._getLocalizedString('speechNotSupported'));
			button.disabled = true;
			return;
		}
		if (Menu.isReadingAloud) {
			window.speechSynthesis.cancel();
			Menu.isReadingAloud = false;
			this._updateButtonActiveState(button, false);
			logAction('Speech cancelled by user', true);
			return;
		}
		let textToRead = '';
		const selectedText = window.getSelection().toString().trim();
		if (selectedText) {
			textToRead = selectedText;
			logAction('Reading selected text.');
		} else {
			const mainContent = document.querySelector('main');
			if (mainContent) {
				textToRead = mainContent.innerText;
			} else {
				const bodyClone = document.body.cloneNode(true);
				bodyClone.querySelectorAll('script, style, noscript, #' + MENU_BUTTON_ID + ', #' + MENU_PANEL_ID).forEach(el => el.remove());
				textToRead = bodyClone.innerText;
			}
			logAction('Reading main content or body fallback.');
		}
		if (textToRead.trim() === '') {
			logAction('No text found to read.');
			return;
		}
		window.speechSynthesis.cancel();
		const utterance = new SpeechSynthesisUtterance(textToRead);
		const docLang = document.documentElement.lang || 'en';
		utterance.lang = docLang;
		utterance.onstart = () => {
			Menu.isReadingAloud = true;
			this._updateButtonActiveState(button, true);
			logAction('Speech started');
		};
		utterance.onend = () => {
			Menu.isReadingAloud = false;
			this._updateButtonActiveState(button, false);
			logAction('Speech finished');
		};
		utterance.onerror = event => {
			Menu.isReadingAloud = false;
			this._updateButtonActiveState(button, false);
			console.error('Speech synthesis error:', event.error);
			logAction('Speech error');
		};
		window.speechSynthesis.speak(utterance);
	};
	Menu._handleReadingModeAction = function (button) {
		Menu.isReadingModeActive = !Menu.isReadingModeActive;
		document.body.classList.toggle(CLASS_READING_MODE, Menu.isReadingModeActive);
		this._updateButtonActiveState(button, Menu.isReadingModeActive);
		logAction('Reading mode ' + (Menu.isReadingModeActive ? 'enabled' : 'disabled'), true);
		//this._togglePageStructurePanel(Menu.isReadingModeActive);
	};
	Menu._handleReadingMaskAction = function (button) {
		Menu.isReadingMaskActive = !Menu.isReadingMaskActive;
		if (Menu.readingMaskTop && Menu.readingMaskBottom) {
			Menu.readingMaskTop.style.display = Menu.isReadingMaskActive ? 'block' : 'none';
			Menu.readingMaskBottom.style.display = Menu.isReadingMaskActive ? 'block' : 'none';
		}
		this._updateButtonActiveState(button, Menu.isReadingMaskActive);
		logAction('Reading mask ' + (Menu.isReadingMaskActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleReadingLineAction = function (button) {
		Menu.isReadingLineActive = !Menu.isReadingLineActive;
		if (Menu.readingLine) {
			Menu.readingLine.style.display = Menu.isReadingLineActive ? 'block' : 'none';
		}
		this._updateButtonActiveState(button, Menu.isReadingLineActive);
		logAction('Reading line ' + (Menu.isReadingLineActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleStopAnimationsAction = function (button) {
		this.areAnimationsStopped = !this.areAnimationsStopped;
		document.body.classList.toggle(CLASS_ANIMATIONS_STOPPED, this.areAnimationsStopped);
		this._updateButtonActiveState(button, this.areAnimationsStopped);
		if (this.areAnimationsStopped) {
			const gifsToFreeze = Array.from(document.querySelectorAll('img[src*=".gif"]:not([data-ar-gif-frozen="true"])')).filter(img => {
				try {
					return new URL(img.src, window.location.href).pathname.toLowerCase().endsWith('.gif');
				} catch (e) {
					return (img.src || '').toLowerCase().includes('.gif');
				}
			});
			gifsToFreeze.forEach(img => {
				if (typeof window.ar_isVisuallyHidden === 'function' && window.ar_isVisuallyHidden(img))
					return;
				img.dataset.arOriginalSrc = img.src;
				img.dataset.arOriginalAlt = img.alt || '';
				img.dataset.arOriginalDisplay = img.style.display || '';
				img.dataset.arOriginalWidth = img.offsetWidth + 'px';
				img.dataset.arOriginalHeight = img.offsetHeight + 'px';
				const tempImage = new Image();
				tempImage.crossOrigin = 'Anonymous';
				tempImage.onload = () => {
					const canvas = document.createElement('canvas');
					canvas.width = tempImage.naturalWidth || parseInt(img.dataset.arOriginalWidth) || img.width || 50;
					canvas.height = tempImage.naturalHeight || parseInt(img.dataset.arOriginalHeight) || img.height || 50;
					canvas.className = img.className;
					canvas.style.cssText = img.style.cssText;
					canvas.style.width = img.dataset.arOriginalWidth;
					canvas.style.height = img.dataset.arOriginalHeight;
					if (window.getComputedStyle(img).display === 'inline') {
						canvas.style.display = 'inline-block';
					} else {
						canvas.style.display = img.dataset.arOriginalDisplay || 'block';
					}
					canvas.setAttribute('role', 'img');
					canvas.setAttribute('aria-label', img.dataset.arOriginalAlt || `Frozen animation: ${ img.src.split('/').pop() }`);
					canvas.dataset.arFrozenGifCanvas = 'true';
					if (!img.id) {
						img.id = typeof window.ar_generateUniqueElementId === 'function' ? window.ar_generateUniqueElementId('ar-original-gif-') : `ar-gif-${ Date.now() }-${ Math.random().toString(36).substr(2, 5) }`;
					}
					canvas.dataset.arOriginalImgId = img.id;
					const ctx = canvas.getContext('2d');
					try {
						ctx.drawImage(tempImage, 0, 0, canvas.width, canvas.height);
						img.style.display = 'none';
						img.dataset.arGifFrozen = 'true';
						if (img.parentNode) {
							img.parentNode.insertBefore(canvas, img.nextSibling);
						}
					} catch (e) {
						console.error('ARMenu: Failed to draw GIF to canvas. Freezing by replacing src.', e);
						img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
						img.style.display = img.dataset.arOriginalDisplay || '';
						img.dataset.arGifFrozen = 'true';
						img.dataset.arGifFrozenFallback = 'true';
					}
				};
				tempImage.onerror = () => {
					console.error('ARMenu: Failed to load GIF for freezing. Replacing src.');
					img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
					img.dataset.arGifFrozen = 'true';
					img.dataset.arGifFrozenFallback = 'true';
				};
				tempImage.src = img.dataset.arOriginalSrc;
			});
		} else {
			document.querySelectorAll('canvas[data-ar-frozen-gif-canvas="true"]').forEach(canvas => {
				const originalImgId = canvas.dataset.arOriginalImgId;
				if (originalImgId) {
					const originalImg = document.getElementById(originalImgId);
					if (originalImg) {
						originalImg.style.display = originalImg.dataset.arOriginalDisplay || '';
						[
							'arGifFrozen',
							'arOriginalSrc',
							'arOriginalAlt',
							'arOriginalDisplay',
							'arOriginalWidth',
							'arOriginalHeight',
							'arGifFrozenFallback'
						].forEach(attr => delete originalImg.dataset[attr]);
					}
				}
				if (canvas.parentNode) {
					canvas.parentNode.removeChild(canvas);
				}
			});
			document.querySelectorAll('img[data-ar-gif-frozen-fallback="true"]').forEach(img => {
				if (img.dataset.arOriginalSrc) {
					img.src = img.dataset.arOriginalSrc;
				}
				[
					'arGifFrozen',
					'arGifFrozenFallback',
					'arOriginalSrc',
					'arOriginalAlt',
					'arOriginalDisplay',
					'arOriginalWidth',
					'arOriginalHeight'
				].forEach(attr => delete img.dataset[attr]);
			});
		}
	};
	Menu._handleDyslexiaFontAction = function (button) {
		this.isDyslexiaFontActive = !this.isDyslexiaFontActive;
		document.body.classList.toggle(CLASS_DYSLEXIA_FONT, this.isDyslexiaFontActive);
		this._updateButtonActiveState(button, this.isDyslexiaFontActive);
	};
	Menu._resetAllSettings = function (calledByProfile = false) {
		Menu.fontScaleLevel = 0;
		document.querySelectorAll('.' + CLASS_TEXT_SCALED).forEach(el => {
			el.classList.remove(CLASS_TEXT_SCALED);
			el.style.removeProperty('--ar-scaled-font-size');
			if (Menu._originalFontSizes.has(el)) {
				const sizeState = Menu._originalFontSizes.get(el);
				if (sizeState.inline) {
					el.style.fontSize = sizeState.inline;
				} else {
					el.style.removeProperty('font-size');
				}
			} else {
				el.style.removeProperty('font-size');
			}
		});
		Menu._originalFontSizes.clear();
		if (Menu.isReadingAloud && 'speechSynthesis' in window) {
			window.speechSynthesis.cancel();
		}
		Menu.isReadingAloud = false;
		Menu.isReadingModeActive = false;
		Menu.isReadingMaskActive = false;
		Menu.isReadingLineActive = false;
		this.activeContrastMode = 'default';
		this.areLinksHighlighted = false;
		this.isFocusEnhanced = false;
		this.areAnimationsStopped = false;
		this.isDyslexiaFontActive = false;
		document.documentElement.classList.remove(CLASS_INVERT_COLORS);
		document.body.classList.remove(CLASS_HIGH_CONTRAST, CLASS_DARK_CONTRAST, CLASS_HIGHLIGHT_LINKS, CLASS_ENHANCED_FOCUS, CLASS_ANIMATIONS_STOPPED, CLASS_DYSLEXIA_FONT, CLASS_READING_MODE);
		if (Menu.readingMaskTop)
			Menu.readingMaskTop.style.display = 'none';
		if (Menu.readingMaskBottom)
			Menu.readingMaskBottom.style.display = 'none';
		if (Menu.readingLine)
			Menu.readingLine.style.display = 'none';
		if (Menu.isStructurePanelOpen) {
			//this._togglePageStructurePanel(false);
		}
		const panel = document.getElementById(MENU_PANEL_ID);
		if (panel) {
			panel.querySelectorAll('button[data-action]').forEach(btn => {
				this._updateButtonActiveState(btn, false);
			});
		}
		if (!calledByProfile) {
			logAction('All settings reset.');
			this._saveSettings();
		}
	};
	Menu._saveSettings = function () {
		const button = document.getElementById(MENU_BUTTON_ID);
		const panel = document.getElementById(MENU_PANEL_ID);
		let buttonPosition = {
			left: button ? button.style.left : null,
			top: button ? button.style.top : null,
			right: button ? button.style.right : null,
			bottom: button ? button.style.bottom : null,
			transform: button ? button.style.transform : null,
			wasDragged: Menu.buttonWasDragged
		};
		let panelPosition = null;
		if (Menu.isOpen && panel && Menu.panelWasDragged) {
			panelPosition = {
				left: panel.style.left,
				top: panel.style.top
			};
		}
		const settings = {
			activeContrastMode: Menu.activeContrastMode,
			areLinksHighlighted: Menu.areLinksHighlighted,
			isFocusEnhanced: Menu.isFocusEnhanced,
			areAnimationsStopped: Menu.areAnimationsStopped,
			isDyslexiaFontActive: Menu.isDyslexiaFontActive,
			fontScaleLevel: Menu.fontScaleLevel,
			isOpen: Menu.isOpen,
			buttonPosition: buttonPosition,
			panelPosition: panelPosition,
			panelWasDragged: Menu.panelWasDragged,
			isReadingModeActive: Menu.isReadingModeActive,
			isReadingMaskActive: Menu.isReadingMaskActive,
			isReadingLineActive: Menu.isReadingLineActive
		};
		try {
			localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
			logAction('Settings saved.');
		} catch (e) {
			console.error('Error saving settings to localStorage:', e);
		}
	};
	Menu._loadSettings = function () {
		try {
			const savedSettingsJSON = localStorage.getItem(STORAGE_KEY);
			if (!savedSettingsJSON) {
				logAction('No saved settings found.');
				return;
			}
			const savedSettings = JSON.parse(savedSettingsJSON);
			if (!savedSettings) {
				logAction('Saved settings are invalid. Using defaults.');
				localStorage.removeItem(STORAGE_KEY);
				return;
			}
			logAction('Loading saved settings.');
			Menu.activeContrastMode = savedSettings.activeContrastMode || 'default';
			if (Menu.activeContrastMode === 'high')
				document.body.classList.add(CLASS_HIGH_CONTRAST);
			else if (Menu.activeContrastMode === 'dark')
				document.body.classList.add(CLASS_DARK_CONTRAST);
			else if (Menu.activeContrastMode === 'inverted')
				document.documentElement.classList.add(CLASS_INVERT_COLORS);
			Menu.areLinksHighlighted = savedSettings.areLinksHighlighted || false;
			if (Menu.areLinksHighlighted)
				document.body.classList.add(CLASS_HIGHLIGHT_LINKS);
			Menu.isFocusEnhanced = savedSettings.isFocusEnhanced || false;
			if (Menu.isFocusEnhanced)
				document.body.classList.add(CLASS_ENHANCED_FOCUS);
			if (savedSettings.areAnimationsStopped) {
				const stopAnimButton = document.querySelector(`#${ MENU_PANEL_ID } button[data-action="stop-animations"]`);
				if (stopAnimButton) {
					Menu.areAnimationsStopped = false;
					this._handleStopAnimationsAction(stopAnimButton);
				}
			}
			Menu.isDyslexiaFontActive = savedSettings.isDyslexiaFontActive || false;
			if (Menu.isDyslexiaFontActive)
				document.body.classList.add(CLASS_DYSLEXIA_FONT);
			Menu.fontScaleLevel = savedSettings.fontScaleLevel || 0;
			if (Menu.fontScaleLevel !== 0) {
				this._applyFontScaleToElements();
			}
			Menu.isReadingModeActive = savedSettings.isReadingModeActive || false;
			if (Menu.isReadingModeActive)
				document.body.classList.add(CLASS_READING_MODE);
			Menu.isReadingMaskActive = savedSettings.isReadingMaskActive || false;
			if (Menu.isReadingMaskActive && Menu.readingMaskTop && Menu.readingMaskBottom) {
				Menu.readingMaskTop.style.display = 'block';
				Menu.readingMaskBottom.style.display = 'block';
			}
			Menu.isReadingLineActive = savedSettings.isReadingLineActive || false;
			if (Menu.isReadingLineActive && Menu.readingLine) {
				Menu.readingLine.style.display = 'block';
			}
			const button = document.getElementById(MENU_BUTTON_ID);
			if (button && savedSettings.buttonPosition) {
				Menu.buttonWasDragged = savedSettings.buttonPosition.wasDragged || false;
				if (Menu.buttonWasDragged && savedSettings.buttonPosition.left && savedSettings.buttonPosition.top) {
					button.style.left = savedSettings.buttonPosition.left;
					button.style.top = savedSettings.buttonPosition.top;
					button.style.right = 'auto';
					button.style.bottom = 'auto';
					button.style.transform = 'none';
				} else if (savedSettings.buttonPosition.right && savedSettings.buttonPosition.top && savedSettings.buttonPosition.transform) {
					button.style.right = savedSettings.buttonPosition.right;
					button.style.top = savedSettings.buttonPosition.top;
					button.style.transform = savedSettings.buttonPosition.transform;
					button.style.left = 'auto';
					button.style.bottom = 'auto';
				}
			}
			const panel = document.getElementById(MENU_PANEL_ID);
			if (panel) {
				this._updateButtonActiveState(panel.querySelector('[data-action="contrast-high"]'), Menu.activeContrastMode === 'high');
				this._updateButtonActiveState(panel.querySelector('[data-action="contrast-invert"]'), Menu.activeContrastMode === 'inverted');
				this._updateButtonActiveState(panel.querySelector('[data-action="contrast-dark"]'), Menu.activeContrastMode === 'dark');
				this._updateButtonActiveState(panel.querySelector('[data-action="highlight-links"]'), Menu.areLinksHighlighted);
				this._updateButtonActiveState(panel.querySelector('[data-action="enhanced-focus"]'), Menu.isFocusEnhanced);
				this._updateButtonActiveState(panel.querySelector('[data-action="stop-animations"]'), Menu.areAnimationsStopped);
				this._updateButtonActiveState(panel.querySelector('[data-action="toggle-dyslexia-font"]'), Menu.isDyslexiaFontActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="reading-mode"]'), Menu.isReadingModeActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="reading-mask"]'), Menu.isReadingMaskActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="reading-line"]'), Menu.isReadingLineActive);
			}
			Menu.panelWasDragged = savedSettings.panelWasDragged || false;
			if (savedSettings.isOpen) {
				Menu.isOpen = false;
				this.toggleMenu();
				if (panel && Menu.panelWasDragged && savedSettings.panelPosition && savedSettings.panelPosition.left && savedSettings.panelPosition.top) {
					panel.style.left = savedSettings.panelPosition.left;
					panel.style.top = savedSettings.panelPosition.top;
					panel.style.right = 'auto';
					panel.style.bottom = 'auto';
					if (button) {
						const panelRect = panel.getBoundingClientRect();
						const buttonRect = button.getBoundingClientRect();
						Menu._panelRelativeOffsetX = panelRect.left - buttonRect.left;
						Menu._panelRelativeOffsetY = panelRect.top - buttonRect.top;
					}
				}
			}
			this._handleWindowResize();
			if (Menu.isReadingModeActive) {
				//this._togglePageStructurePanel(true);
			}
		} catch (e) {
			console.error('Error loading settings from localStorage:', e);
			localStorage.removeItem(STORAGE_KEY);
		}
	};
  	function isAccessibilityMenuElement(el) {
		return el.closest(`#${ MENU_BUTTON_ID }`) || el.closest(`#${ MENU_PANEL_ID }`) || el.closest(`#${ PAGE_STRUCTURE_PANEL_ID }`);
	}
	if (typeof Menu._getLocalizedString === 'undefined') {
		console.error('ARMenu: _getLocalizedString is not defined. Ensure action.js is loaded before panel.js.');
		Menu._getLocalizedString = key => key;
	}
	Menu.panel = Menu.panel || {};
	Menu.panel.createMenuPanel = function () {
		const panel = document.createElement('div');
		panel.id = MENU_PANEL_ID;
		panel.setAttribute('role', 'dialog');
		panel.setAttribute('aria-modal', 'true');
		panel.setAttribute('aria-labelledby', 'ar-aaa-menu-title');
		panel.style.display = 'none';
		panel.innerHTML = Menu.panel.getMenuPanelHTML();
		document.body.appendChild(panel);
	};
	Menu.panel.createReadingAidElements = function () {
		Menu.readingMaskTop = document.createElement('div');
		Menu.readingMaskTop.className = READING_MASK_TOP_ID;
		document.body.appendChild(Menu.readingMaskTop);
		Menu.readingMaskBottom = document.createElement('div');
		Menu.readingMaskBottom.className = READING_MASK_BOTTOM_ID;
		document.body.appendChild(Menu.readingMaskBottom);
		Menu.readingLine = document.createElement('div');
		Menu.readingLine.className = READING_LINE_ID;
		document.body.appendChild(Menu.readingLine);
	};
	Menu.panel.createPageStructurePanel = function () {
		Menu.pageStructurePanel = document.createElement('div');
		Menu.pageStructurePanel.id = PAGE_STRUCTURE_PANEL_ID;
		Menu.pageStructurePanel.setAttribute('role', 'dialog');
		Menu.pageStructurePanel.setAttribute('aria-modal', 'false');
		Menu.pageStructurePanel.setAttribute('aria-labelledby', 'ar-aaa-structure-title');
		Menu.pageStructurePanel.style.display = 'none';
		Menu.pageStructurePanel.classList.add('ar-aaa-page-structure-panel');
		let panelHTML = `<h3 id="ar-aaa-structure-title">${ Menu._getLocalizedString('pageStructureTitle') }</h3>`;
		panelHTML += `<div class="ar-structure-category" id="ar-aaa-structure-headings"><h4>${ Menu._getLocalizedString('headings') }</h4><ul></ul></div>`;
		panelHTML += `<div class="ar-structure-category" id="ar-aaa-structure-landmarks"><h4>${ Menu._getLocalizedString('landmarks') }</h4><ul></ul></div>`;
		panelHTML += `<div class="ar-structure-category" id="ar-aaa-structure-links"><h4>${ Menu._getLocalizedString('links') }</h4><ul></ul></div>`;
		panelHTML += `<button class="ar-aaa-structure-close-btn" data-action="close-structure-panel">${ Menu._getLocalizedString('closeStructurePanel') }</button>`;
		Menu.pageStructurePanel.innerHTML = panelHTML;
		document.body.appendChild(Menu.pageStructurePanel);
		Menu.pageStructurePanel.querySelector('.ar-aaa-structure-close-btn').addEventListener('click', () => {
			Menu._togglePageStructurePanel(false);
			if (Menu.isReadingModeActive) {
				document.body.classList.remove('ar-aaa-reading-mode');
				Menu.isReadingModeActive = false;
				const rmButton = document.querySelector(`#${ MENU_PANEL_ID } button[data-action="reading-mode"]`);
				if (rmButton)
					Menu._updateButtonActiveState(rmButton, false);
			}
		});
		Menu.pageStructurePanel.addEventListener('keydown', event => {
			if (event.key === 'Escape') {
				Menu._togglePageStructurePanel(false);
				if (Menu.isReadingModeActive) {
					document.body.classList.remove('ar-aaa-reading-mode');
					Menu.isReadingModeActive = false;
					const rmButton = document.querySelector(`#${ MENU_PANEL_ID } button[data-action="reading-mode"]`);
					if (rmButton)
						Menu._updateButtonActiveState(rmButton, false);
				}
			}
		});
	};
	Menu.panel._getIconSVG = function (pathData, label = '') {
		return `<span class="ar-aaa-menu-icon" role="img" aria-label="${ label }"><svg viewBox="0 0 24 24">${ pathData }</svg></span>`;
	};
	Menu.panel.getMenuPanelHTML = function () {
		const ICONS = {
			textSize: Menu.panel._getIconSVG('<path d="M2.5,4V7H7.5V19H10.5V7H15.5V4M10.5,10.5H13.5V13.5H10.5V10.5Z"/>', Menu._getLocalizedString('textSize')),
			contrast: Menu.panel._getIconSVG('<path d="M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6V18M20,15L19.3,14C19.5,13.4 19.6,12.7 19.6,12C19.6,11.3 19.5,10.6 19.3,10L20,9L17.3,4L16.7,5C15.9,4.3 14.9,3.8 13.8,3.5L13.5,2H10.5L10.2,3.5C9.1,3.8 8.1,4.3 7.3,5L6.7,4L4,9L4.7,10C4.5,10.6 4.4,11.3 4.4,12C4.4,12.7 4.5,13.4 4.7,14L4,15L6.7,20L7.3,19C8.1,19.7 9.1,20.2 10.2,20.5L10.5,22H13.5L13.8,20.5C14.9,20.2 15.9,19.7 16.7,19L17.3,20L20,15Z"/>', Menu._getLocalizedString('contrast')),
			highlight: Menu.panel._getIconSVG('<path d="M16.2,12L12,16.2L7.8,12L12,7.8M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4Z"/>', Menu._getLocalizedString('highlight')),
			readAloud: Menu.panel._getIconSVG('<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>', Menu._getLocalizedString('readAloudIcon')),
			readingMode: Menu.panel._getIconSVG('<path d="M5 5v14h14V5H5zm8 12H7v-2h6v2zm4-4H7v-2h10v2zm0-4H7V7h10v2z"/>', Menu._getLocalizedString('readingModeIcon')),
			readingMask: Menu.panel._getIconSVG('<path d="M11.5,6C8.46,6 5.83,7.43 4.42,9.59L2.93,8.1L1.87,9.16L3.87,11.16C3.67,11.46 3.5,11.72 3.5,12C3.5,12.28 3.67,12.54 3.87,12.84L1.87,14.84L2.93,15.9L4.42,14.41C5.83,16.57 8.46,18 11.5,18C14.54,18 17.17,16.57 18.58,14.41L20.07,15.9L21.13,14.84L19.13,12.84C19.33,12.54 19.5,12.28 19.5,12C19.5,11.72 19.33,11.46 19.13,11.16L21.13,9.16L20.07,8.1L18.58,9.59C17.17,7.43 14.54,6 11.5,6M11.5,8A4.5,4.5 0 0,1 16,12.5A4.5,4.5 0 0,1 11.5,17A4.5,4.5 0 0,1 7,12.5A4.5,4.5 0 0,1 11.5,8M11.5,10A2.5,2.5 0 0,0 9,12.5A2.5,2.5 0 0,0 11.5,15A2.5,2.5 0 0,0 14,12.5A2.5,2.5 0 0,0 11.5,10Z"/>', Menu._getLocalizedString('readingMaskIcon')),
			readingLine: Menu.panel._getIconSVG('<path d="M19 13H5v-2h14v2z"/>', Menu._getLocalizedString('readingLineIcon')),
			pageStructure: Menu.panel._getIconSVG('<path d="M3,3H9V7H3V3M15,3H21V7H15V3M3,10H9V14H3V10M15,10H21V14H15V10M3,17H9V21H3V17M15,17H21V21H15V17Z"/>', Menu._getLocalizedString('pageStructureIcon')),
			animation: Menu.panel._getIconSVG('<path d="M8,5V19L19,12L8,5Z"/>', Menu._getLocalizedString('animation')),
			fontStyle: Menu.panel._getIconSVG('<path d="M9.25,4V5.5H6.75V4H5.25V5.5H2.75V4H1.25V14.5H2.75V16H5.25V14.5H7.75V16H10.25V14.5H11.75V4H9.25M17.75,4V14.5H19.25V16H21.75V14.5H24.25V4H21.75V5.5H19.25V4H17.75M10.25,7H7.75V13H10.25V7M16.25,7H13.75V13H16.25V7Z"/>', Menu._getLocalizedString('fontStyle')),
			reset: Menu.panel._getIconSVG('<path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/>', Menu._getLocalizedString('reset')),
			close: Menu.panel._getIconSVG('<path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>', Menu._getLocalizedString('closeMenu'))
		};
		let html = `<h3 id="ar-aaa-menu-title">${ Menu._getLocalizedString('menuTitle') }</h3>`;
		html += `<div class="ar-aaa-menu-group"><h4 class="ar-aaa-profile-title">${ Menu._getLocalizedString('profilesTitle') }</h4><div class="ar-aaa-button-row">`;
		for (const profileKey in Menu.profiles) {
			const profile = Menu.profiles[profileKey];
			html += `<button data-action="profile-${ profileKey }">${ Menu.panel._getIconSVG(profile.iconPath, Menu._getLocalizedString('profileIcon')) } ${ Menu._getLocalizedString(profile.labelKey) }</button>`;
		}
		html += `</div></div>`;
		html += `
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="increase-text">${ ICONS.textSize } ${ Menu._getLocalizedString('increaseText') }</button> <button data-action="decrease-text">${ ICONS.textSize } ${ Menu._getLocalizedString('decreaseText') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="contrast-high">${ ICONS.contrast } ${ Menu._getLocalizedString('highContrast') }</button> <button data-action="contrast-invert">${ ICONS.contrast } ${ Menu._getLocalizedString('invertColors') }</button> <button data-action="contrast-dark">${ ICONS.contrast } ${ Menu._getLocalizedString('darkContrast') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="highlight-links">${ ICONS.highlight } ${ Menu._getLocalizedString('highlightLinks') }</button> <button data-action="enhanced-focus">${ ICONS.highlight } ${ Menu._getLocalizedString('enhancedFocus') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="read-aloud" class="ar-aaa-fullwidth-btn">${ ICONS.readAloud } ${ Menu._getLocalizedString('readAloud') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="reading-mode" class="ar-aaa-fullwidth-btn">${ ICONS.readingMode } ${ Menu._getLocalizedString('readingMode') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="reading-mask">${ ICONS.readingMask } ${ Menu._getLocalizedString('readingMask') }</button> <button data-action="reading-line">${ ICONS.readingLine } ${ Menu._getLocalizedString('readingLine') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="stop-animations" class="ar-aaa-fullwidth-btn">${ ICONS.animation } ${ Menu._getLocalizedString('stopAnimations') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="toggle-dyslexia-font" class="ar-aaa-fullwidth-btn">${ ICONS.fontStyle } ${ Menu._getLocalizedString('dyslexiaFont') }</button> </div></div>
            <div class="ar-aaa-menu-group"><div class="ar-aaa-button-row"> <button data-action="reset-all" class="ar-aaa-fullwidth-btn ar-aaa-reset-btn">${ ICONS.reset } ${ Menu._getLocalizedString('resetAll') }</button> <button data-action="close-menu" class="ar-aaa-fullwidth-btn">${ ICONS.close } ${ Menu._getLocalizedString('closeMenu') }</button> </div></div>`;
		return html;
	};
	Menu.panel.populatePageStructurePanel = function (customSelectors) {
		if (!Menu.pageStructurePanel)
			return;
		const selectors = customSelectors || {
		    headings: 'h1:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h2:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h3:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h4:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h5:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
		    	  'h6:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
		    landmarks: [
			  'main:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="main"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'nav:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="navigation"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'header:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="banner"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'footer:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="contentinfo"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'aside:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="complementary"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'form:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="form"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="search"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'section[aria-label]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'section[aria-labelledby]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="region"][aria-label]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="region"][aria-labelledby]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)'
		    ].join(', '),
		    links: 'a[href]:not([href=""]):not([href="#"]):not([href^="javascript:"]):not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)'
		};
		
		const listedElements = new Set();
		const isHiddenOrEmpty = el => {
			if (!el || el.nodeType !== Node.ELEMENT_NODE)
				return true;
			if (window.getComputedStyle(el).display === 'none' || window.getComputedStyle(el).visibility === 'hidden' || el.offsetWidth === 0 || el.offsetHeight === 0) {
				return true;
			}
			if (el.matches('h1,h2,h3,h4,h5,h6,a[href]')) {
				return !ar_hasAccessibleNameForElement(el);
			}
			return false;
		};
		const getAccessibleName = el => {
			if (!el)
				return '';
			if (el.hasAttribute('aria-label') && el.getAttribute('aria-label').trim()) {
				return el.getAttribute('aria-label').trim();
			}
			if (el.hasAttribute('aria-labelledby')) {
				const labelledbyIds = el.getAttribute('aria-labelledby').split(/\s+/);
				for (const id of labelledbyIds) {
					const lblEl = document.getElementById(id);
					if (lblEl && lblEl.textContent.trim()) {
						return lblEl.textContent.trim();
					}
				}
			}
			if (el.textContent && el.textContent.trim()) {
				let text = el.textContent.trim().replace(/\s+/g, ' ');
				const tempDiv = document.createElement('div');
				tempDiv.textContent = text;
				text = tempDiv.textContent.trim().replace(/\s+/g, ' ');
				if (text.length > 100) {
					text = text.substring(0, 97) + '...';
				}
				return text;
			}
			if (el.tagName === 'A') {
				const img = el.querySelector('img[alt]');
				if (img && img.alt.trim()) {
					return img.alt.trim();
				}
			}
			if (el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'TEXTAREA') {
				if (el.placeholder && el.placeholder.trim())
					return el.placeholder.trim();
				if (el.title && el.title.trim())
					return el.title.trim();
			}
			return '';
		};
		const isElementAlreadyListedOrCovered = el => {
			if (listedElements.has(el))
				return true;
			let current = el.parentElement;
			while (current) {
				if (listedElements.has(current)) {
					const currentRole = current.getAttribute('role') || current.tagName.toLowerCase();
					if ([
							'main',
							'navigation',
							'banner',
							'contentinfo',
							'complementary',
							'form',
							'region',
							'search'
						].includes(currentRole)) {
						if (getAccessibleName(current) && !el.matches('h1, h2, h3, h4, h5, h6, a[href], button, input, select, textarea, [role="button"], [role="link"]')) {
							return true;
						}
					}
				}
				current = current.parentElement;
			}
			return false;
		};
		const addToList = (el, text, type) => {
			if (isAccessibilityMenuElement(el)) {
				return null;
			}
			if (isHiddenOrEmpty(el)) {
				return null;
			}
			if (isElementAlreadyListedOrCovered(el)) {
				return null;
			}
			const li = document.createElement('li');
			const button = document.createElement('button');
			const display_text = text.substring(0, 70) + (text.length > 70 ? '...' : '');
			button.textContent = display_text;
			button.title = text;
			button.addEventListener('click', () => {
				el.scrollIntoView({
					behavior: 'smooth',
					block: 'center'
				});
				el.classList.add(CLASS_TEMP_HIGHLIGHT);
				setTimeout(() => {
					el.classList.remove(CLASS_TEMP_HIGHLIGHT);
				}, 2000);
			});
			li.appendChild(button);
			listedElements.add(el);
			return li;
		};
		const createListSection = (selector, containerId, itemType) => {
			const container = Menu.pageStructurePanel.querySelector(`#${ containerId } ul`);
			if (!container)
				return;
			container.innerHTML = '';
			let elements = Array.from(document.querySelectorAll(selector));
			elements = elements.filter(el => !isAccessibilityMenuElement(el));
			const itemsToAdd = [];
			elements.forEach(el => {
				let text = getAccessibleName(el);
				if (!( !text || text.length < 2 || text.toLowerCase().includes('read more') || text.toLowerCase().includes('click here') )){
					const parentText = el.parentElement ? el.parentElement.textContent.trim().replace(/\s+/g, ' ') : '';
					if (parentText.length > 10 && parentText.length < 100) {
						text = `${ parentText.substring(0, Math.min(parentText.length, 50)) }...`;
					}
					if (text && text.trim() !== '') {
						const listItem = addToList(el, text, itemType);
						if (listItem) {
							itemsToAdd.push(listItem);
						}
					}
				}
			});
			if (itemsToAdd.length === 0) {
				container.innerHTML = `<li>${ Menu._getLocalizedString('noItemsFound') }</li>`;
			} else {
				itemsToAdd.forEach(li => container.appendChild(li));
			}
		};
		listedElements.clear();
		createListSection(selectors.headings,'ar-aaa-structure-headings','Heading');
		createListSection(selectors.landmarks, 'ar-aaa-structure-landmarks', 'Landmarks');
		createListSection(selectors.links,'ar-aaa-structure-links','Links');
	};
}(AR_AccessibilityMenu));

var AR_CheckModules = AR_CheckModules || {};
(function (AR_CheckModulesProto) {
	AR_CheckModulesProto.checkContentStructure = function (globalState) {
		ar_logSection('Structure and Relationships');
		this._checkVisualHeadings(globalState);
		this._checkPseudoLists();
		this._checkParagraphsWithOnlyImages();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkVisualHeadings = function (globalState) {
		document.querySelectorAll('div, span, p').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || el.closest('h1, h2, h3, h4, h5, h6'))
					return;
				const style = window.getComputedStyle(el);
				const fontSize = parseFloat(style.fontSize);
				const fontWeight = style.fontWeight;
				const isSemanticallyHeading = [
					'H1',
					'H2',
					'H3',
					'H4',
					'H5',
					'H6'
				].includes(el.tagName);
				const hasHeadingRole = el.getAttribute('role') === 'heading';
				if (fontSize >= 20 && (parseInt(fontWeight) >= 600 || fontWeight === 'bold' || fontWeight === 'bolder') && el.textContent.trim().length > 0) {
					if (!isSemanticallyHeading && !hasHeadingRole) {
						let level = 2;
						const h1 = document.querySelector('h1');
						if (h1) {
							const h1FontSize = parseFloat(window.getComputedStyle(h1).fontSize);
							if (fontSize > h1FontSize * 0.85) {
								level = 1
							} else if (fontSize < h1FontSize * 0.6) {
								level = 3
							}
						}
						ar_setAttributeAndLog(el, 'role', 'heading', 'Moderate', 'Visually strong text not semantic heading. Auto-added role="heading".', 'Use H1-H6 or ensure correct aria-level.', 'Operable', '2.4.6 Headings and Labels', 'AA');
						ar_setAttributeAndLog(el, 'aria-level', level.toString(), 'Info', `Auto-set aria-level="${ level }". Review.`, 'Ensure aria-level matches visual hierarchy.', 'Operable', '2.4.6 Headings and Labels', 'AA')
					} else if (hasHeadingRole && !el.hasAttribute('aria-level')) {
						ar_setAttributeAndLog(el, 'aria-level', '2', 'Minor', 'role="heading" without aria-level. Auto-set to "2".', 'Provide aria-level.', 'Operable', '2.4.6 Headings and Labels', 'AA')
					}
				} else if (hasHeadingRole && (fontSize < 16 || parseInt(fontWeight) < 500)) {
					ar_removeAttributeAndLog(el, 'role', 'Minor', 'Element with role="heading" does not appear visually as a heading. Auto-removed role.', 'Remove role="heading" if not a visual heading.', 'Robust', '4.1.2', 'A');
					ar_removeAttributeAndLog(el, 'aria-level', 'Minor', 'Removed associated aria-level.', '', 'Robust', '4.1.2', 'A')
				}
			} catch (e) {
				console.error('Error: VisualHeadings Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkPseudoLists = function () {
		document.querySelectorAll('div, p').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || el.closest('ul, ol, dl'))
					return;
				const textContent = (el.textContent || '').trim();
				const isPseudoListItem = textContent.startsWith('\u2022 ') || textContent.startsWith('- ') || /^\d+\.\s/.test(textContent);
				if (isPseudoListItem) {
					let nextSibling = el.nextElementSibling;
					let similarSiblings = [el];
					while (nextSibling && !nextSibling.closest('ul,ol,dl')) {
						const siblingText = (nextSibling.textContent || '').trim();
						if (siblingText.startsWith('\u2022 ') || siblingText.startsWith('- ') || /^\d+\.\s/.test(siblingText)) {
							similarSiblings.push(nextSibling);
							nextSibling = nextSibling.nextElementSibling
						} else {
							break
						}
					}
					if (similarSiblings.length > 1) {
						const listType = /^\d+\.\s/.test(textContent) ? 'ol' : 'ul';
						const newList = document.createElement(listType);
						const parent = el.parentNode;
						if (parent) {
							parent.insertBefore(newList, el);
							similarSiblings.forEach(sibling => {
								const listItem = document.createElement('li');
								while (sibling.firstChild) {
									listItem.appendChild(sibling.firstChild)
								}
								sibling.remove();
								newList.appendChild(listItem)
							});
							ar_logAccessibilityIssue('Moderate', `Wrapped ${ similarSiblings.length } pseudo-list items in <${ listType }>.`, newList, 'Review auto-generated list structure. Ensure nested lists are handled correctly.', 'Perceivable', '1.3.1 Info and Relationships', true, 'A')
						}
					}
				}
			} catch (e) {
				console.error('Error: PseudoList Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkParagraphsWithOnlyImages = function () {
		document.querySelectorAll('p').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (el.children.length === 1 && el.children[0].tagName === 'IMG') {
					const img = el.children[0];
					if (((img.alt || '').trim() === '' || img.getAttribute('role') === 'presentation') && !ar_hasAccessibleNameForElement(img)) {
						if (el.getAttribute('role') !== 'presentation') {
							ar_setAttributeAndLog(el, 'role', 'presentation', 'Minor', 'Paragraph contains only a decorative image. Added role="presentation" to the paragraph.', 'If the paragraph is purely a decorative container for the image, role="presentation" is appropriate. Otherwise, ensure the image has proper alt text.', 'Perceivable', '1.3.1 Info and Relationships', true, 'A')
						}
					} else if (el.getAttribute('role') === 'presentation' && ar_hasAccessibleNameForElement(img)) {
						ar_removeAttributeAndLog(el, 'role', 'Minor', 'Paragraph with role="presentation" contains informative image. Auto-removed role.', 'Remove role="presentation" if image is informative.', 'Robust', '4.1.2', 'A')
					}
				}
			} catch (e) {
				console.error('Error: ParagraphsWithOnlyImages Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto.checkMediaIntegrity = function () {
		ar_logSection('Media Integrity (Images, Links)');
		this._checkBrokenImages();
		this._checkEmptyLinks();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkBrokenImages = function () {
		document.querySelectorAll('img').forEach(img => {
			if (img.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(img) && !img.hasAttribute('alt') || img.src.includes('placehold.co') && img.alt.startsWith('Placeholder for broken image')) {
					if (ar_isVisuallyHidden(img) && !img.hasAttribute('alt')) {
						ar_setAttributeAndLog(img, 'alt', '', 'Info', 'Visually hidden image was missing alt attribute. Auto-set alt="".', 'Ensure decorative hidden images have an empty alt attribute.', 'Perceivable', '1.1.1 Non-text Content', 'A')
					}
					return
				}
				if (!img.complete || img.naturalWidth === 0 || img.naturalHeight === 0) {
					if (img.src.includes('placehold.co') && img.src.includes('Broken%20Image'))
						return;
					const originalSrc = img.src;
					const altText = img.alt && img.alt.trim() !== '' ? img.alt.trim() : 'Broken Image';
					const placeholderWidth = Math.max(50, img.width || parseInt(img.style.width, 10) || 150);
					const placeholderHeight = Math.max(50, img.height || parseInt(img.style.height, 10) || 100);
					const placeholderSrc = AR_CONFIG.PLACEHOLDER_IMAGE_URL.replace('{width}', placeholderWidth.toString()).replace('{height}', placeholderHeight.toString()).replace('{text}', encodeURIComponent(altText.substring(0, 50)));
					img.setAttribute('data-original-src', originalSrc);
					img.src = placeholderSrc;
					img.alt = `Placeholder for broken image: ${ ar_escapeHtml(altText) }`;
					ar_logAccessibilityIssue('Critical', 'Broken image detected. Replaced with a placeholder.', img, `Original src: ${ originalSrc }. Verify the image source or ensure the alt text is sufficiently descriptive if the image cannot be restored.`, 'Perceivable', '1.1.1 Non-text Content', true, 'A')
				}
			} catch (e) {
				console.error('Error: BrokenImage Check:', e, img)
			}
		})
	};
	AR_CheckModulesProto._checkEmptyLinks = function () {
		document.querySelectorAll('a[href]').forEach(a => {
			if (a.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(a))
					return;
				const href = a.getAttribute('href');
				const hasName = ar_hasAccessibleNameForElement(a);
				if (!hasName && (href === '#' || href === '' || !href || href.trim().toLowerCase() === 'javascript:void(0);')) {
					const titleAttr = (a.getAttribute('title') || '').trim();
					if (titleAttr.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT) {
						ar_setAttributeAndLog(a, 'aria-label', ar_escapeHtml(titleAttr), 'Minor', 'Link with no discernible text content but a title attribute. Auto-set aria-label from title.', 'Review auto-generated aria-label. Prefer descriptive link text over title attribute for links.', 'Perceivable', '2.4.4 Link Purpose (In Context)', 'A')
					} else {
						const rect = a.getBoundingClientRect();
						if (rect.width < 10 && rect.height < 10 && rect.width > 0 && rect.height > 0) {
							ar_setAttributeAndLog(a, 'aria-hidden', 'true', 'Minor', 'Small, empty, non-functional link auto-hidden with aria-hidden="true".', 'Remove or provide a descriptive name if the link is functional.', 'Perceivable', '2.4.4 Link Purpose (In Context)', true, 'A')
						} else {
							ar_setAttributeAndLog(a, 'aria-label', 'Link - Description Needed', 'Critical', 'Link has no discernible text or accessible name. Auto-added a generic aria-label.', 'Provide descriptive text content or an aria-label for the link.', 'Perceivable', '2.4.4 Link Purpose (In Context)', true, 'A')
						}
					}
				}
			} catch (e) {
				console.error('Error: EmptyLink Check:', e, a)
			}
		})
	};
	AR_CheckModulesProto.checkImageAltText = function () {
		ar_logSection('Image Alternative Text');
		document.querySelectorAll('img').forEach(img => {
			if (img.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(img) && img.hasAttribute('alt') || img.src.includes('placehold.co') && img.alt.startsWith('Placeholder for broken image'))
					return;
				if (img.naturalWidth === 0 && !img.src.startsWith('data:image/svg+xml') && !img.src.includes('placehold.co')) {
					if (img.complete && !img.hasAttribute('alt')) {
						ar_setAttributeAndLog(img, 'alt', 'Broken image (description needed)', 'Critical', 'Image appears broken and is missing alt text.', 'Fix image source or provide descriptive alt text.', 'Perceivable', '1.1.1', 'A')
					}
					return
				}
				if (!img.hasAttribute('alt')) {
					const generatedAlt = this._generateAltTextAttempt(img);
					ar_setAttributeAndLog(img, 'alt', ar_escapeHtml(generatedAlt), 'Critical', `Image missing alt attribute. Auto-set to "${ ar_escapeHtml(generatedAlt) }".`, '**Manual review required.**', 'Perceivable', '1.1.1 Non-text Content', 'A')
				} else {
					const alt = (img.alt || '').trim();
					if (alt === '') {
						this._checkDecorativeImageContext(img)
					} else {
						this._checkInformativeAltText(img, alt)
					}
				}
			} catch (e) {
				console.error('Error: ImageAltText Check:', e, img)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._generateAltTextAttempt = function (img) {
		if (img.getAttribute('aria-hidden') === 'true') return;
		let altText = 'Image (description needed)';
		const src = (img.src || '').toLowerCase();
		const className = (img.className || '').toLowerCase();
		if (AR_CONFIG.AVATAR_KEYWORDS.some(kw => src.includes(kw) || className.includes(kw))) {
			altText = 'User avatar'
		} else {
			const filenameMatch = src.match(/[^/\\&?]+\.\w{3,4}(?=([?&].*$|$))/);
			if (filenameMatch) {
				const filename = filenameMatch[0].substring(0, filenameMatch[0].lastIndexOf('.')).replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
				if (filename.length > 3 && filename.length < 50 && !/\d{4,}/.test(filename) && !/(icon|logo|banner|image|pic)/i.test(filename)) {
					altText = filename.charAt(0).toUpperCase() + filename.slice(1)
				}
			}
		}
		if (img.title && img.title.trim().length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT && !/(image|graphic|picture|photo)/i.test(img.title.trim())) {
			altText = img.title.trim()
		} else if (img.parentElement && img.parentElement.textContent && img.parentElement.textContent.trim().length > 10 && img.parentElement.textContent.trim().length < 100) {
			const parentText = img.parentElement.textContent.trim().replace(/\s+/g, ' ');
			if (!/(image|graphic|picture|photo)/i.test(parentText)) {
				altText = parentText.substring(0, Math.min(parentText.length, 50)) + (parentText.length > 50 ? '...' : '')
			}
		}
		return ar_escapeHtml(altText)
	};
	AR_CheckModulesProto._checkDecorativeImageContext = function (img) {
		if (img.getAttribute('aria-hidden') === 'true') return;
		const src = (img.src || '').toLowerCase();
		if (/(chart|graph|diagram|stats|figure)/.test(src) && (img.offsetWidth > 50 || img.offsetHeight > 50)) {
			ar_setAttributeAndLog(img, 'alt', 'Image (description needed, was decorative)', 'Moderate', `Image has alt="" but src suggests it might be informative. Auto-set placeholder.`, 'Verify if decorative. Provide descriptive alt text if informative.', 'Perceivable', '1.1.1', 'A')
		}
		if (/(spacer|1x1)\.(gif|png|jpg)/i.test(src) && img.getAttribute('role') !== 'presentation') {
			ar_setAttributeAndLog(img, 'role', 'presentation', 'Minor', 'Spacer image with alt="". Auto-added role="presentation".', 'Spacers: alt="" and role="presentation".', 'Perceivable', '1.1.1', true, 'A')
		}
	};
	AR_CheckModulesProto._checkInformativeAltText = function (img, alt) {
		if (img.getAttribute('aria-hidden') === 'true') return;
		const filenameFromSrc = (img.src || '').split('/').pop().split('.')[0].replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ').toLowerCase();
		if (alt.toLowerCase() === filenameFromSrc && alt.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT) {
			ar_setAttributeAndLog(img, 'alt', `Image: ${ ar_escapeHtml(alt) } (description needed, was filename)`, 'Minor', `Alt text "${ ar_escapeHtml(alt) }" is filename. Auto-updated.`, 'Replace filename with description.', 'Perceivable', '1.1.1', 'A')
		}
		const genericAlts = [
			'image',
			'graphic',
			'picture',
			'photo',
			'logo',
			'icon',
			'banner'
		];
		if (genericAlts.includes(alt.toLowerCase()) && (img.offsetWidth > 30 || img.offsetHeight > 30)) {
			ar_logAccessibilityIssue('Minor', `Alt text "${ ar_escapeHtml(alt) }" is generic.`, img, 'Provide more specific alt text.', 'Perceivable', '1.1.1', false, 'A')
		}
	};
	AR_CheckModulesProto.checkIframeTitles = function () {
		ar_logSection('Iframe Titles');
		document.querySelectorAll('iframe').forEach(iframe => {
			if (iframe.getAttribute('aria-hidden') === 'true') return;
			try {
				if (!iframe.title || iframe.title.trim() === '') {
					const generatedTitle = this._generateIframeTitleAttempt(iframe);
					ar_setAttributeAndLog(iframe, 'title', ar_escapeHtml(generatedTitle), 'Critical', `Iframe missing title. Auto-set to "${ ar_escapeHtml(generatedTitle) }".`, '**Manual review required.**', 'Operable', '2.4.1, 4.1.2', 'A')
				}
			} catch (e) {
				console.error('Error: IframeTitles Check:', e, iframe)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._generateIframeTitleAttempt = function (iframe) {
		if (iframe.getAttribute('aria-hidden') === 'true') return;
		let title = 'Embedded content';
		if (iframe.src) {
			try {
				const url = new URL(iframe.src);
				const hostname = url.hostname.toLowerCase();
				const allowedYouTubeHosts = [
					'youtube.com',
					'youtu.be'
				];
				const allowedVimeoHosts = ['vimeo.com'];
				const allowedGoogleMapsHosts = [
					'maps.google.com',
					'google.com/maps'
				];
				if (allowedYouTubeHosts.some(h => hostname.endsWith(h)))
					title = 'YouTube video player';
				else if (allowedVimeoHosts.some(h => hostname.endsWith(h)))
					title = 'Vimeo video player';
				else if (allowedGoogleMapsHosts.some(h => hostname.endsWith(h)))
					title = 'Google Maps embed';
				else if (url.pathname.endsWith('.pdf'))
					title = `Embedded PDF document: ${ url.pathname.split('/').pop() }`;
				else if (hostname && hostname !== 'about:blank')
					title = `Embedded content from ${ hostname.replace('www.', '') }`
			} catch (e) {
			}
		}
		return ar_escapeHtml(title)
	};
	AR_CheckModulesProto.checkTableAccessibility = function () {
		ar_logSection('Table Accessibility');
		document.querySelectorAll('table').forEach(table => {
			if (table.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(table))
					return;
				const role = table.getAttribute('role');
				if (role === 'presentation' || role === 'none') {
					this._checkPresentationTable(table);
					return
				}
				this._checkDataTableCaption(table);
				this._checkTableHeaders(table);
				this._checkLayoutTableHeuristic(table)
			} catch (e) {
				console.error('Error: TableAccessibility Check:', e, table)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._checkDataTableCaption = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		if (!table.querySelector('caption') && table.querySelectorAll('th').length > 0) {
			const caption = document.createElement('caption');
			caption.textContent = 'Table data (auto-caption)';
			Object.assign(caption.style, {
				position: 'absolute',
				left: '-9999px',
				width: '1px',
				height: '1px',
				overflow: 'hidden'
			});
			table.prepend(caption);
			ar_logAccessibilityIssue('Moderate', 'Data table missing <caption>. Auto-added generic hidden caption.', table, '**Manual review required.** Provide a descriptive caption.', 'Perceivable', '1.3.1', true, 'A')
		}
	};
	AR_CheckModulesProto._checkTableHeaders = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		table.querySelectorAll('thead th').forEach(thEl => {
			if (!thEl.hasAttribute('scope')) {
				ar_setAttributeAndLog(thEl, 'scope', 'col', 'Minor', '<th> in <thead> missing scope. Auto-set "col".', 'Add scope="col".', 'Perceivable', '1.3.1', 'A')
			}
		});
		table.querySelectorAll('tbody tr > th:first-child, tfoot tr > th:first-child').forEach(thEl => {
			const parentRow = thEl.closest('tr');
			if (parentRow && parentRow.querySelectorAll('th').length === 1 && !thEl.hasAttribute('scope')) {
				ar_setAttributeAndLog(thEl, 'scope', 'row', 'Minor', 'First <th> in row missing scope. Auto-set "row".', 'Add scope="row".', 'Perceivable', '1.3.1', 'A')
			}
		})
	};
	AR_CheckModulesProto._checkLayoutTableHeuristic = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		const thCount = table.querySelectorAll('th').length;
		const tdCount = table.querySelectorAll('td').length;
		const border = table.getAttribute('border');
		if (thCount === 0 && tdCount > 0 && (!border || border === '0') && !table.querySelector('caption') && !table.hasAttribute('role') && !table.hasAttribute('summary')) {
			if (table.rows.length < 5 && Array.from(table.rows).every(r => r.cells.length < 5)) {
				ar_setAttributeAndLog(table, 'role', 'presentation', 'Minor', 'Table appears to be used for layout. Auto-added role="presentation".', 'If this is a data table, remove role and add proper semantics (<th>, <caption>).', 'Perceivable', '1.3.1', true, 'A')
			}
		}
	};
	AR_CheckModulesProto._checkPresentationTable = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		if (table.querySelector('caption')) {
			ar_logAccessibilityIssue('Minor', 'Table with role="presentation" has <caption>.', table, 'Remove <caption> from tables used for layout.', 'Perceivable', '1.3.1', false, 'A')
		}
		if (table.hasAttribute('summary')) {
			ar_logAccessibilityIssue('Minor', 'Table with role="presentation" has summary.', table, 'Remove summary from tables used for layout.', 'Perceivable', '1.3.1', false, 'A')
		}
		table.querySelectorAll('th, [scope]').forEach(el => {
			ar_logAccessibilityIssue('Minor', `Table with role="presentation" contains <${ el.tagName.toLowerCase() }> or scope attribute.`, el, `Remove <th> or scope. Use <td> elements for layout tables.`, 'Perceivable', '1.3.1', false, 'A')
		})
	};
	AR_CheckModulesProto.checkOverlayFocusBlocking = function () {
		ar_logSection('Overlapping Elements (Modals/Popups)');
		document.querySelectorAll('body > div, body > section, body > aside, [role="dialog"], [role="alertdialog"]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const style = window.getComputedStyle(el);
				const rect = el.getBoundingClientRect();
				const isOverlay = (style.position === 'fixed' || style.position === 'absolute') && (rect.width >= window.innerWidth * 0.7 || rect.height >= window.innerHeight * 0.7) && parseFloat(style.zIndex) >= 1000 && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity > 0;
				if (isOverlay) {
					this._ensureModalAriaAttributes(el);
					this._manageBackgroundContentInteractivity(el)
				} else if (el.getAttribute('aria-modal') === 'true' || el.getAttribute('role') === 'dialog' || el.getAttribute('role') === 'alertdialog') {
					this._restoreBackgroundContentInteractivity(el)
				}
			} catch (e) {
				console.error('Error: OverlayFocusBlocking Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._ensureModalAriaAttributes = function (modalElement) {
		if (modalElement.getAttribute('aria-hidden') === 'true') return;
		if (modalElement.getAttribute('aria-modal') !== 'true') {
			ar_setAttributeAndLog(modalElement, 'aria-modal', 'true', 'Critical', 'Potential modal lacks aria-modal="true". Auto-fixed.', 'Ensure focus trap & ESC handling. Set aria-modal="true" for modal dialogs.', 'Operable', '4.1.2 / 2.4.3', 'A')
		}
		const role = modalElement.getAttribute('role');
		if (role !== 'dialog' && role !== 'alertdialog') {
			ar_setAttributeAndLog(modalElement, 'role', 'dialog', 'Critical', 'Potential modal lacks role="dialog/alertdialog". Auto-fixed.', 'Use role="dialog" or "alertdialog" for modal dialogs.', 'Operable', '4.1.2', 'A')
		}
	};
	AR_CheckModulesProto._manageBackgroundContentInteractivity = function (modalElement) {
		if (modalElement.getAttribute('aria-hidden') === 'true') return;
		if (modalElement.getAttribute('aria-modal') === 'true') {
			let hiddenElementsCount = 0;
			Array.from(document.body.children).forEach(child => {
				if (child !== modalElement && !modalElement.contains(child) && ![
						'SCRIPT',
						'STYLE',
						'LINK'
					].includes(child.tagName.toUpperCase()) && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID) {
					if (child.getAttribute('aria-hidden') !== 'true') {
						if (child.hasAttribute('aria-hidden')) {
							child.setAttribute('data-ar-original-aria-hidden', child.getAttribute('aria-hidden'))
						}
						child.setAttribute('aria-hidden', 'true');
						hiddenElementsCount++
					}
				}
			});
			if (hiddenElementsCount > 0) {
				ar_logAccessibilityIssue('Info', `Modal: ${ hiddenElementsCount } background elements auto-set aria-hidden="true".`, modalElement, 'Ensure these elements are made visible on modal close. Implement a robust focus trap.', 'Operable', '2.4.3', true, 'A')
			}
		}
	};
	AR_CheckModulesProto._restoreBackgroundContentInteractivity = function (modalElement) {
		if (modalElement.getAttribute('aria-hidden') === 'true') return;
		if (ar_isVisuallyHidden(modalElement)) {
			let restoredElementsCount = 0;
			Array.from(document.body.children).forEach(child => {
				if (child.getAttribute('aria-hidden') === 'true' && child.hasAttribute('data-ar-original-aria-hidden')) {
					child.setAttribute('aria-hidden', child.getAttribute('data-ar-original-aria-hidden'));
					child.removeAttribute('data-ar-original-aria-hidden');
					restoredElementsCount++
				} else if (child.getAttribute('aria-hidden') === 'true' && !child.hasAttribute('data-ar-original-aria-hidden') && child !== modalElement && !modalElement.contains(child)) {
					child.removeAttribute('aria-hidden');
					restoredElementsCount++
				}
			});
			if (restoredElementsCount > 0) {
				ar_logAccessibilityIssue('Info', `Modal: ${ restoredElementsCount } background elements auto-restored aria-hidden.`, modalElement, 'Verification of modal close logic is recommended.', 'Operable', '2.4.3', true, 'A')
			}
		}
	};
	AR_CheckModulesProto.checkInteractiveElementSize = function () {
		ar_logSection('Interactive Element Size');
		document.querySelectorAll(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const rect = el.getBoundingClientRect();
				if (rect.width > 0 && rect.height > 0 && (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX || rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX)) {
					const stylesToApply = {};
					const computedStyle = window.getComputedStyle(el);
					if (computedStyle.display === 'inline') {
						stylesToApply['display'] = 'inline-block'
					}
					if (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX) {
						stylesToApply['min-width'] = `${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px`
					}
					if (rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX) {
						stylesToApply['min-height'] = `${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px`
					}
					const currentPaddingV = parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
					const currentPaddingH = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
					if (rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX && currentPaddingV < 4) {
						stylesToApply['padding-top'] = stylesToApply['padding-bottom'] = '0.3em'
					}
					if (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX && currentPaddingH < 8) {
						stylesToApply['padding-left'] = stylesToApply['padding-right'] = '0.5em'
					}
					if (Object.keys(stylesToApply).length > 0) {
						ar_applyStylesAndLog(el, stylesToApply, 'Moderate', `Interactive element too small. Auto-adjusted.`, `Increase area to ${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }x${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px.`, 'Operable', '2.5.5 Target Size', 'AAA')
					} else {
						ar_logAccessibilityIssue('Moderate', `Interactive element too small. Could not auto-adjust.`, el, `Increase area to ${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }x${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px.`, 'Operable', '2.5.5 Target Size', false, 'AAA')
					}
				}
			} catch (e) {
				console.error('Error: InteractiveElementSize Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkHoverFocusContent = function () {
		ar_logSection('Content on Hover/Focus (ARIA Attributes)');
	
		const interactiveElements = document.querySelectorAll(
		    'button, a[href], [role="button"], [role="link"], [role="menuitem"]'
		);
	
		interactiveElements.forEach(el => {
		    if (el.getAttribute('aria-hidden') === 'true') return;
		    try {
			if (ar_isVisuallyHidden(el)) return;
	
			validateAriaHasPopup(el);
			validateAriaExpandedAndControls(el);
		    } catch (error) {
			console.error('Error in HoverFocusContent Check:', error, el);
		    }
		});
	
		console.log(
		    '\n\uD83D\uDCA1 Manual Verification for WCAG 1.4.13 (Content on Hover/Focus) is CRUCIAL: ' +
		    'Check for Dismissible, Hoverable, Persistent properties of popups.'
		);
		console.groupEnd();
	};
	function validateAriaHasPopup(el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		const VALID_ARIA_HASPOPUP_VALUES = [
			'menu', 'listbox', 'tree', 'grid', 'dialog', 'true', 'false'
		];
	        const hasPopup = el.hasAttribute('aria-haspopup');
	        if (hasPopup) {
	            const popupValue = el.getAttribute('aria-haspopup').toLowerCase();
	            if (!VALID_ARIA_HASPOPUP_VALUES.includes(popupValue)) {
	                ar_setAttributeAndLog(
	                    el,
	                    'aria-haspopup',
	                    'true',
	                    'Moderate',
	                    `Invalid aria-haspopup value "${popupValue}". Auto-set to "true".`,
	                    'Use valid values (menu, listbox, tree, grid, dialog, true, false).'
	                );
	            }
	        }
	}
	function validateAriaExpandedAndControls(el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
	        const controlsId = el.getAttribute('aria-controls');
	        const isExpanded = el.getAttribute('aria-expanded');
	
	        if (controlsId && controlsId.trim() !== "") {
	            const controlledElement = document.getElementById(controlsId);
	            if (controlledElement) {
	                const isControlledElementVisible = !ar_isVisuallyHidden(controlledElement);
	                if (isExpanded === null) {
	                    ar_setAttributeAndLog(
	                        el,
	                        'aria-expanded',
	                        String(isControlledElementVisible),
	                        'Minor',
	                        `aria-controls present without aria-expanded. Auto-fixed.`,
	                        'Add and update aria-expanded to reflect the visibility of the controlled element.'
	                    );
	                } else if (
	                    (isExpanded === 'true' && !isControlledElementVisible) ||
	                    (isExpanded === 'false' && isControlledElementVisible)
	                ) {
	                    ar_setAttributeAndLog(
	                        el,
	                        'aria-expanded',
	                        String(isControlledElementVisible),
	                        'Minor',
	                        `aria-expanded value mismatch with controlled element visibility. Auto-corrected.`,
	                        'Ensure aria-expanded reflects controlled element visibility.'
	                    );
	                }
	            } else if (isExpanded !== null) {
	                ar_logAccessibilityIssue(
	                    'Moderate',
	                    `aria-controls points to a non-existent ID "${controlsId}".`,
	                    el,
	                    'Ensure aria-controls points to a valid ID of a controlled element.',
	                    'Robust',
	                    '4.1.2'
	                );
	            }
	        } else if (isExpanded !== null) {
	            ar_logAccessibilityIssue(
	                'Minor',
	                `aria-expanded present without aria-controls.`,
	                el,
	                'Add aria-controls if content is controlled by this element, or remove aria-expanded.',
	                'Operable',
	                '4.1.2'
	            );
	        }
	}
	AR_CheckModulesProto.checkHoverFocusContent = function () {
		ar_logSection('Content on Hover/Focus (ARIA Attributes)');
		document.querySelectorAll('button, a[href], [role="button"], [role="link"], [role="menuitem"]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const hasPopup = el.hasAttribute('aria-haspopup');
				const isExpanded = el.getAttribute('aria-expanded');
				const controlsId = el.getAttribute('aria-controls');
				if (hasPopup) {
					const popupValue = el.getAttribute('aria-haspopup').toLowerCase();
					const validPopupValues = [
						'menu',
						'listbox',
						'tree',
						'grid',
						'dialog',
						'true',
						'false'
					];
					if (!validPopupValues.includes(popupValue)) {
						ar_setAttributeAndLog(el, 'aria-haspopup', 'true', 'Moderate', `Invalid aria-haspopup value "${ popupValue }". Auto-set to "true".`, 'Use valid values (menu, listbox, tree, grid, dialog, true, false).', 'Operable', '4.1.2', 'A')
					}
				}
				if (controlsId && controlsId.trim() !== "") {
					const controlledElement = document.getElementById(controlsId);
					if (controlledElement) {
						const isControlledElementVisible = !ar_isVisuallyHidden(controlledElement);
						if (isExpanded === null) {
							ar_setAttributeAndLog(el, 'aria-expanded', String(isControlledElementVisible), 'Minor', `aria-controls present without aria-expanded. Auto-fixed.`, 'Add and update aria-expanded to reflect the state of the controlled element.', 'Operable', '4.1.2', 'A')
						} else if (isExpanded === 'true' && !isControlledElementVisible || isExpanded === 'false' && isControlledElementVisible) {
							ar_setAttributeAndLog(el, 'aria-expanded', String(isControlledElementVisible), 'Minor', `aria-expanded value mismatch with controlled element visibility. Auto-corrected.`, 'Ensure aria-expanded accurately reflects the visibility state of the controlled element.', 'Operable', '4.1.2', 'A')
						}
					} else if (isExpanded !== null) {
						ar_logAccessibilityIssue('Moderate', `aria-controls points to a non-existent ID "${ controlsId }".`, el, 'Ensure aria-controls points to a valid ID of a controlled element.', 'Robust', '4.1.2', false, 'A')
					}
				} else if (isExpanded !== null) {
					ar_logAccessibilityIssue('Minor', `aria-expanded present without aria-controls.`, el, 'Add aria-controls if content is controlled by this element, or remove aria-expanded.', 'Operable', '4.1.2', false, 'A')
				}
			} catch (e) {
				console.error('Error: HoverFocusContent Check:', e, el)
			}
		});
		console.log('\n\uD83D\uDCA1 Manual Verification for WCAG 1.4.13 (Content on Hover/Focus) is CRUCIAL: Check for Dismissible, Hoverable, Persistent properties of popups.');
		console.groupEnd()
	};
	AR_CheckModulesProto.checkAutoFormSubmission = function () {
		ar_logSection('Automatic Form Submission');
		document.querySelectorAll('form, input:not([type="hidden"]), select, textarea').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				[
					'onfocus',
					'onchange'
				].forEach(attrName => {
					const attrValue = el.getAttribute(attrName);
					if (attrValue && attrValue.toLowerCase().includes('submit()')) {
						ar_removeAttributeAndLog(el, attrName, 'Minor', `${ el.tagName } with ${ attrName } auto-submits. Auto-removed.`, 'Avoid automatic form submission on focus or change. Use an explicit submit button.', 'Operable', '3.2.2', 'A')
					}
				})
			} catch (e) {
				console.error('Error: AutoFormSubmission Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkDuplicateIds = function (globalState) {
		ar_logSection('Duplicate IDs');
		document.querySelectorAll('[id]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const id = el.id;
				if (!id || id.trim() === '')
					return;
				if (globalState.seenIds.has(id)) {
					const originalElement = globalState.seenIds.get(id);
					const newId = ar_generateUniqueElementId(`dup-${ id }-`);
					ar_setAttributeAndLog(el, 'id', newId, 'Critical', `Duplicate ID "#${ id }". Auto-fixed to "#${ newId }".`, `Original element:`, 'Robust', '4.1.1', 'A');
					console.warn('    Original element with conflicting ID:', originalElement);
					document.querySelectorAll(`[aria-controls*="${ id }"], [aria-labelledby*="${ id }"], [aria-describedby*="${ id }"], label[for="${ id }"]`).forEach(refEl => {
						if (refEl.id === newId)
							return;
						if (refEl.hasAttribute('aria-controls') && refEl.getAttribute('aria-controls') === id) {
							ar_setAttributeAndLog(refEl, 'aria-controls', newId, 'Moderate', `Updated 'aria-controls' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
						if (refEl.hasAttribute('aria-labelledby') && refEl.getAttribute('aria-labelledby') === id) {
							ar_setAttributeAndLog(refEl, 'aria-labelledby', newId, 'Moderate', `Updated 'aria-labelledby' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
						if (refEl.hasAttribute('aria-describedby') && refEl.getAttribute('aria-describedby') === id) {
							ar_setAttributeAndLog(refEl, 'aria-describedby', newId, 'Moderate', `Updated 'aria-describedby' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
						if (refEl.tagName === 'LABEL' && refEl.htmlFor === id) {
							ar_setAttributeAndLog(refEl, 'for', newId, 'Moderate', `Updated 'for' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
					})
				} else {
					globalState.seenIds.set(id, el)
				}
			} catch (e) {
				console.error('Error: DuplicateIds Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkAccessibleNames = function () {
		ar_logSection('Accessible Names for Interactive Elements');
		document.querySelectorAll(`${ AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS }, [role="img"]`).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || ar_hasAccessibleNameForElement(el))
					return;
				const generatedName = this._generateAccessibleNameCandidate(el);
				if (generatedName && generatedName.trim() !== '') {
					ar_setAttributeAndLog(el, 'aria-label', ar_escapeHtml(generatedName), 'Moderate', `Lacked accessible name. Auto-fixed with aria-label: "${ ar_escapeHtml(generatedName) }".`, '**Manual review required.**', 'Perceivable', '2.4.4 / 4.1.2', 'A')
				} else {
					ar_logAccessibilityIssue('Critical', `Lacked accessible name. Could not auto-generate.`, el, 'Provide descriptive text, title, aria-label, or associate with a <label>.', 'Perceivable', '2.4.4 / 4.1.2', false, 'A')
				}
			} catch (e) {
				console.error('Error: AccessibleNames Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._generateAccessibleNameCandidate = function (el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		let label = '';
		const tagName = el.tagName.toLowerCase();
		const type = (el.type || '').toLowerCase();
		if (el.placeholder && el.placeholder.trim())
			label = el.placeholder.trim();
		else if (el.title && el.title.trim())
			label = el.title.trim();
		if (tagName === 'input' && [
				'button',
				'submit',
				'reset'
			].includes(type) && el.value && el.value.trim()) {
			label = el.value.trim()
		} else if (tagName === 'input' && type === 'image' && el.src) {
			const filename = el.src.split('/').pop().split('.')[0].replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
			label = filename.length > 3 && filename.length < 30 ? `Submit ${ filename }` : 'Submit query';
			ar_setAttributeAndLog(el, 'alt', ar_escapeHtml(label), 'Moderate', `Input type="image" missing alt. Auto-set.`, '**Manual review.**', 'Perceivable', '1.1.1', 'A');
			return ar_escapeHtml(label)
		} else if (tagName === 'img' || el.getAttribute('role') === 'img') {
			label = this._generateAltTextAttempt(el) || 'Image (description needed)'
		} else if (tagName === 'a') {
			const textContent = (el.textContent || '').trim();
			if (textContent.length > 2 && textContent.length < 50) {
				label = `Link: ${ textContent }`
			} else {
				let contextText = '';
				if (el.previousElementSibling && el.previousElementSibling.textContent) {
					contextText += el.previousElementSibling.textContent.trim()
				}
				if (el.nextElementSibling && el.nextElementSibling.textContent) {
					contextText += ' ' + el.nextElementSibling.textContent.trim()
				}
				if (el.parentElement && el.parentElement.textContent) {
					contextText += ' ' + el.parentElement.textContent.trim()
				}
				contextText = contextText.replace(/\s+/g, ' ').trim();
				if (contextText.length > 10 && contextText.length < 100) {
					label = `Link: ${ contextText.substring(0, Math.min(contextText.length, AR_CONFIG.MAX_WORDS_FROM_CONTEXT_FOR_GENERIC_LINK_ARIA_LABEL * 5)).replace(/\s+/g, ' ') }...`
				} else {
					label = 'Link - Description Needed'
				}
			}
		} else if (tagName === 'button') {
			const textContent = (el.textContent || '').trim();
			if (textContent.length > 2 && textContent.length < 50) {
				label = textContent
			} else {
				let iconLabel = '';
				for (const prefix of AR_CONFIG.COMMON_ICON_CLASS_PREFIXES) {
					for (const cssClass of Array.from(el.classList)) {
						if (cssClass.startsWith(prefix)) {
							const potentialLabel = cssClass.substring(prefix.length).replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
							if (potentialLabel.length > 2) {
								iconLabel = `${ potentialLabel.charAt(0).toUpperCase() + potentialLabel.slice(1) } button`;
								break
							}
						}
					}
					if (iconLabel)
						break
				}
				label = iconLabel || 'Button - Action Needed'
			}
		}
		if (!label || label.startsWith('Unnamed') || label.includes('Description Needed')) {
			label = `${ el.getAttribute('role') || tagName } - Description Needed`
		}
		if (label.length > AR_CONFIG.MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL) {
			label = label.substring(0, AR_CONFIG.MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL - 3) + '...'
		}
		return ar_escapeHtml(label)
	};
	AR_CheckModulesProto.checkLangAttribute = function () {
		ar_logSection('Language Attribute (HTML)');
		const htmlEl = document.documentElement;
		if (!htmlEl.lang || !htmlEl.lang.trim()) {
			ar_setAttributeAndLog(htmlEl, 'lang', 'en', 'Critical', '<html> missing lang attribute. Auto-set to "en".', '**Manual review required.** Verify "en" is the correct language for the page.', 'Understandable', '3.1.1 Language of Page', 'A')
		}
		console.groupEnd()
	};
	AR_CheckModulesProto.checkTabindexUsage = function () {
		ar_logSection('Tabindex Usage');
		document.querySelectorAll('[tabindex]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const tabindexValue = parseInt(el.getAttribute('tabindex'), 10);
				if (tabindexValue > 0) {
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Moderate', `Positive tabindex="${ tabindexValue }" found. Auto-fixed to "0".`, 'Avoid positive tabindex. Use a logical document order instead.', 'Operable', '2.4.3', 'A')
				}
				const role = el.getAttribute('role');
				const isNativeInteractive = el.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS);
				const commonInteractiveRoles = [
					'button',
					'link',
					'menuitem',
					'tab',
					'checkbox',
					'radio',
					'option',
					'switch',
					'slider',
					'treeitem',
					'textbox',
					'combobox',
					'listbox'
				];
				if (role && commonInteractiveRoles.includes(role) && !isNativeInteractive && tabindexValue < 0) {
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Minor', `Custom control [role="${ role }"] is not focusable (tabindex="-1"). Auto-added tabindex="0".`, 'Ensure custom controls are focusable and in the tab order.', 'Operable', '2.1.1', 'A')
				}
				if (role && commonInteractiveRoles.includes(role) && tabindexValue === -1 && !el.disabled && el.getAttribute('aria-disabled') !== 'true') {
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Minor', `Active custom control [role="${ role }"] has tabindex="-1". Auto-set to "0".`, 'Ensure active interactive controls are included in the tab order.', 'Operable', '2.1.1', 'A')
				}
			} catch (e) {
				console.error('Error: TabindexUsage Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkAriaMisuse = function () {
		ar_logSection('ARIA Misuse');
		this._checkAriaHiddenOnFocusable();
		this._checkRedundantAriaRoles();
		this._checkInvalidAriaRelationshipIDs();
		this._checkRedundantAriaLabels();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkAriaHiddenOnFocusable = function () {
		document.querySelectorAll('[aria-hidden="true"]').forEach(el => {
			try {
				const isElementFocusable = el.tabIndex >= 0 || el.matches(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS);
				const hasFocusableDescendant = el.querySelector(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS.split(',').map(s => `${ s.trim() }:not([tabindex="-1"])`).join(',')) !== null;
				if (isElementFocusable || hasFocusableDescendant) {
					ar_removeAttributeAndLog(el, 'aria-hidden', 'Critical', '`aria-hidden="true"` found on or containing focusable element. Auto-removed.', 'Do not use aria-hidden="true" on elements that are focusable or contain focusable descendants.', 'Perceivable', '4.1.2 / 1.3.1', true, 'A')
				}
			} catch (e) {
				console.error('Error: AriaHiddenOnFocusable Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkRedundantAriaRoles = function () {
		document.querySelectorAll('[role]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const role = el.getAttribute('role').toLowerCase();
				const tagName = el.tagName.toLowerCase();
				const type = (el.type || '').toLowerCase();
				const implicitRoles = {
					'button': 'button',
					'a': 'link',
					'input[type=button]': 'button',
					'input[type=submit]': 'button',
					'input[type=reset]': 'button',
					'input[type=checkbox]': 'checkbox',
					'input[type=radio]': 'radio',
					'input[type=text]': 'textbox',
					'input[type=email]': 'textbox',
					'input[type=password]': 'textbox',
					'input[type=search]': 'searchbox',
					'input[type=tel]': 'textbox',
					'input[type=url]': 'textbox',
					'select': 'listbox',
					'textarea': 'textbox',
					'img': 'img',
					'h1': 'heading',
					'h2': 'heading',
					'h3': 'heading',
					'h4': 'heading',
					'h5': 'heading',
					'h6': 'heading',
					'ul': 'list',
					'ol': 'list',
					'li': 'listitem',
					'nav': 'navigation',
					'header': 'banner',
					'footer': 'contentinfo',
					'main': 'main',
					'aside': 'complementary',
					'form': 'form',
					'section': 'region',
					'article': 'article',
					'dialog': 'dialog',
					'figure': 'figure',
					'figcaption': 'figcaption',
					'table': 'table',
					'tbody': 'rowgroup',
					'tfoot': 'rowgroup',
					'thead': 'rowgroup',
					'tr': 'row',
					'td': 'cell',
					'th': 'columnheader'
				};
				let nativeRole = implicitRoles[tagName];
				if (tagName === 'input' && type) {
					nativeRole = implicitRoles[`input[type=${ type }]`] || nativeRole
				}
				if (tagName === 'a' && !el.hasAttribute('href')) {
					nativeRole = null
				}
				if (tagName === 'img' && (!el.hasAttribute('alt') || el.alt.trim() === '')) {
					nativeRole = null
				}
				if (tagName === 'section' && !ar_hasAccessibleNameForElement(el)) {
					nativeRole = null
				}
				if (nativeRole === role) {
					if (tagName === 'img' && (role === 'presentation' || role === 'none') && (!el.hasAttribute('alt') || el.alt.trim() === '')) {
						return
					}
					ar_removeAttributeAndLog(el, 'role', 'Minor', `Redundant ARIA role="${ role }" on <${ tagName }>. Auto-removed.`, 'Native HTML element implicitly conveys the same semantic meaning.', 'Robust', '4.1.2', 'A')
				}
				if (role === 'text' && el.matches(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS)) {
					ar_removeAttributeAndLog(el, 'role', 'Critical', 'Interactive element has `role="text"`. Auto-removed.', 'Remove role="text" from interactive elements.', 'Robust', '4.1.2', 'A')
				}
				if ((role === 'presentation' || role === 'none') && (el.tabIndex >= 0 || el.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS))) {
					const parentRole = el.parentElement ? el.parentElement.getAttribute('role') : null;
					if (!(role === 'presentation' && tagName === 'li' && (parentRole === 'tablist' || parentRole === 'listbox' || parentRole === 'menu'))) {
						ar_removeAttributeAndLog(el, 'role', 'Moderate', `Focusable element has role="${ role }". Auto-removed.`, `Focusable elements should not have role="presentation" or "none" as this removes their semantics.`, 'Robust', '4.1.2', 'A')
					}
				}
			} catch (e) {
				console.error('Error: RedundantAriaRoles Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkRedundantAriaLabels = function () {
		document.querySelectorAll('[aria-label], [aria-labelledby]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const ariaLabel = el.getAttribute('aria-label');
				const ariaLabelledby = el.getAttribute('aria-labelledby');
				const visibleText = (el.textContent || '').trim().replace(/\s+/g, ' ');
				if (ariaLabel && visibleText.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_REDUNDANT_TITLE_CHECK && ariaLabel.trim().toLowerCase() === visibleText.toLowerCase()) {
					ar_removeAttributeAndLog(el, 'aria-label', 'Minor', `Redundant aria-label="${ ar_escapeHtml(ariaLabel) }" duplicates visible text. Auto-removed.`, 'Remove aria-label if it duplicates visible text content.', 'Robust', '4.1.2', 'A')
				}
				if (ariaLabelledby) {
					const labelledbyElements = ariaLabelledby.split(/\s+/).map(id => document.getElementById(id)).filter(Boolean);
					const labelledbyText = labelledbyElements.map(lblEl => (lblEl.textContent || '').trim().replace(/\s+/g, ' ')).join(' ').trim();
					if (labelledbyText.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_REDUNDANT_TITLE_CHECK && labelledbyText.toLowerCase() === visibleText.toLowerCase()) {
						ar_removeAttributeAndLog(el, 'aria-labelledby', 'Minor', `Redundant aria-labelledby="${ ar_escapeHtml(ariaLabelledby) }" duplicates visible text. Auto-removed.`, 'Remove aria-labelledby if it duplicates visible text content.', 'Robust', '4.1.2', 'A')
					}
				}
			} catch (e) {
				console.error('Error: RedundantAriaLabels Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkInvalidAriaRelationshipIDs = function () {
		[
			'aria-labelledby',
			'aria-describedby',
			'aria-controls',
			'aria-owns',
			'aria-flowto'
		].forEach(attr => {
			document.querySelectorAll(`[${ attr }]`).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
				try {
					const raw = el.getAttribute(attr) || "";
					const idRefs = raw.split(/\s+/).map(id => id.trim()).filter(id => id.length > 0);
					const validIdRefs = idRefs.filter(id => document.getElementById(id));
					if (validIdRefs.length !== idRefs.length) {
						if (validIdRefs.length > 0) {
							ar_setAttributeAndLog(el, attr, validIdRefs.join(' '), 'Minor', `${ attr } has invalid ID(s). Auto-removed invalid references.`, `Ensure ${ attr } points to existing element IDs.`, 'Robust', '4.1.2', 'A')
						} else {
							ar_removeAttributeAndLog(el, attr, 'Minor', `${ attr } only contains invalid ID(s). Auto-removed attribute.`, `Ensure ${ attr } points to existing element IDs.`, 'Robust', '4.1.2', 'A')
						}
					}
				} catch (e) {
					console.error(`Error: InvalidAriaRelationshipIDs Check for ${ attr }:`, e, el)
				}
			})
		})
	};
	AR_CheckModulesProto.checkContrastRatioForAllElements = function (targetElement = null) {
		if (!targetElement)
			ar_logSection('Text Contrast Ratios');
		const elementsToCheck = targetElement ? [targetElement] : Array.from(document.querySelectorAll(AR_SELECTOR_STRINGS.TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU));
		elementsToCheck.forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || el.textContent.trim().length === 0 || el.offsetWidth === 0 || el.offsetHeight === 0 || el.closest(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }`))
					return;
				const style = window.getComputedStyle(el);
				const fgOriginalRgba = ar_parseCssColorString(style.color);
				if (fgOriginalRgba[3] === 0)
					return;
				const bgEffectiveRgba = ar_getEffectiveBackgroundColorOfElement(el);
				const fgPerceivedRgba = ar_blendColors(fgOriginalRgba, bgEffectiveRgba);
				const currentContrast = ar_getContrastRatioBetweenColors(fgPerceivedRgba, bgEffectiveRgba);
				const isLargeText = ar_isTextLargeForWCAG(el);
				const requiredContrast = isLargeText ? AR_CONFIG.CONTRAST_RATIO_AA_LARGE_TEXT : AR_CONFIG.CONTRAST_RATIO_AA_NORMAL_TEXT;
				const originalFgColorString = `rgba(${ fgOriginalRgba.join(',') })`;
				const originalBgColorString = `rgb(${ bgEffectiveRgba.slice(0, 3).join(',') })`;
				if (currentContrast < requiredContrast) {
					const initialFailureKey = `${ el.id || el.dataset.arGeneratedId || ar_generateUniqueElementId('contrast-el-') }::CONTRAST_FAILURE_INITIAL::${ originalFgColorString }-${ originalBgColorString }`;
					if (!ar_loggedIssuesTracker.has(initialFailureKey)) {
						ar_logAccessibilityIssue('Critical', `Low contrast: ${ currentContrast.toFixed(2) }:1 (Req: ${ requiredContrast }:1).`, el, `Original: ${ originalFgColorString } on ${ originalBgColorString }. Attempting autofix.`, 'Perceivable', '1.4.3 Contrast (Minimum)', false, 'AA')
					}
					const fixed = this._attemptContrastFix(el, fgOriginalRgba, bgEffectiveRgba, requiredContrast, originalFgColorString, originalBgColorString);
					if (fixed.success) {
						ar_logAccessibilityIssue('Info', `Low contrast auto-fixed. New text: ${ fixed.newFgCss }, New BG: ${ fixed.newBgCss || 'unchanged' }. New contrast: ${ fixed.newContrast.toFixed(2) }:1. Strategy: ${ fixed.strategy }.`, el, `Original: ${ originalFgColorString }, ${ originalBgColorString }.`, 'Perceivable', '1.4.3', true, 'AA');
						ar_loggedIssuesTracker.add(initialFailureKey)
					} else {
						const failKey = `${ initialFailureKey }::AUTOFIX_FAILED`;
						if (!ar_loggedIssuesTracker.has(failKey)) {
							ar_logAccessibilityIssue('Critical', `Low contrast ${ currentContrast.toFixed(2) }:1. Autofix failed. Best achieved: ${ fixed.newContrast ? fixed.newContrast.toFixed(2) + ':1' : 'N/A' }.`, el, `Original: ${ originalFgColorString } on ${ originalBgColorString }. Manually adjust text or background color.`, 'Perceivable', '1.4.3', false, 'AA');
							ar_loggedIssuesTracker.add(failKey)
						}
					}
				}
			} catch (e) {
				console.error('Error: ContrastRatio Check:', e, el)
			}
		});
		if (!targetElement)
			console.groupEnd()
	};
	AR_CheckModulesProto._attemptContrastFix = function (el, fgRgba, bgRgba, requiredContrast, origFgCss, origBgCss) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		function clamp(val, min, max) {
			return Math.max(min, Math.min(max, val));
		}
		function luminance([r, g, b]) {
			const norm = [
				r,
				g,
				b
			].map(v => {
				v /= 255;
				return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
			});
			return 0.2126 * norm[0] + 0.7152 * norm[1] + 0.0722 * norm[2];
		}
		function contrast(rgb1, rgb2) {
			const lum1 = luminance(rgb1);
			const lum2 = luminance(rgb2);
			return (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05);
		}
		function rgbToHsl(r, g, b) {
			r /= 255;
			g /= 255;
			b /= 255;
			const max = Math.max(r, g, b), min = Math.min(r, g, b);
			let h, s, l = (max + min) / 2;
			if (max === min) {
				h = s = 0;
			} else {
				const d = max - min;
				s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
				switch (max) {
				case r:
					h = (g - b) / d + (g < b ? 6 : 0);
					break;
				case g:
					h = (b - r) / d + 2;
					break;
				case b:
					h = (r - g) / d + 4;
					break;
				}
				h /= 6;
			}
			return [
				h,
				s,
				l
			];
		}
		function hslToRgb(h, s, l) {
			let r, g, b;
			if (s === 0)
				r = g = b = l;
			else {
				function hue2rgb(p, q, t) {
					if (t < 0)
						t += 1;
					if (t > 1)
						t -= 1;
					if (t < 1 / 6)
						return p + (q - p) * 6 * t;
					if (t < 1 / 2)
						return q;
					if (t < 2 / 3)
						return p + (q - p) * (2 / 3 - t) * 6;
					return p;
				}
				const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				const p = 2 * l - q;
				r = hue2rgb(p, q, h + 1 / 3);
				g = hue2rgb(p, q, h);
				b = hue2rgb(p, q, h - 1 / 3);
			}
			return [
				Math.round(r * 255),
				Math.round(g * 255),
				Math.round(b * 255)
			];
		}
		let currentFg = fgRgba.slice(0, 3);
		let currentBg = bgRgba.slice(0, 3);
		let c = contrast(currentFg, currentBg);
		if (c >= requiredContrast) {
			return {
				success: true,
				newFgCss: origFgCss,
				newBgCss: origBgCss,
				newContrast: c,
				strategy: 'already_ok'
			};
		}
		let bestFg = currentFg, bestBg = currentBg, bestC = c, bestFgCss = origFgCss, bestBgCss = origBgCss, bestStrategy = 'none';
		const testColors = [
			[
				0,
				0,
				0
			],
			[
				255,
				255,
				255
			]
		];
		for (const testFg of testColors) {
			let testC = contrast(testFg, currentBg);
			if (testC > bestC) {
				bestC = testC;
				bestFg = testFg;
				bestFgCss = `rgb(${ testFg.join(',') })`;
				bestStrategy = 'bw_text';
			}
		}
		if (bestC >= requiredContrast) {
			el.style.setProperty('color', bestFgCss);
			return {
				success: true,
				newFgCss: bestFgCss,
				newBgCss: origBgCss,
				newContrast: bestC,
				strategy: bestStrategy
			};
		}
		let [h, s, l] = rgbToHsl(...currentFg);
		let step = 0.02, found = false, maxSteps = 20;
		for (let i = 1; i <= maxSteps; i++) {
			let lUp = clamp(l + step * i, 0, 1), lDn = clamp(l - step * i, 0, 1);
			let tryFg1 = hslToRgb(h, s, lUp), tryFg2 = hslToRgb(h, s, lDn);
			let c1 = contrast(tryFg1, currentBg), c2 = contrast(tryFg2, currentBg);
			if (c1 > bestC) {
				bestC = c1;
				bestFg = tryFg1;
				bestFgCss = `rgb(${ tryFg1.join(',') })`;
				bestStrategy = 'hsl_text';
			}
			if (c2 > bestC) {
				bestC = c2;
				bestFg = tryFg2;
				bestFgCss = `rgb(${ tryFg2.join(',') })`;
				bestStrategy = 'hsl_text';
			}
			if (bestC >= requiredContrast) {
				el.style.setProperty('color', bestFgCss);
				return {
					success: true,
					newFgCss: bestFgCss,
					newBgCss: origBgCss,
					newContrast: bestC,
					strategy: bestStrategy
				};
			}
		}
		const nonBgChangeTags = [
			'BODY',
			'MAIN',
			'HEADER',
			'FOOTER',
			'NAV',
			'ASIDE'
		];
		if (!nonBgChangeTags.includes(el.tagName.toUpperCase())) {
			let [bh, bs, bl] = rgbToHsl(...currentBg);
			for (let i = 1; i <= maxSteps; i++) {
				let blUp = clamp(bl + step * i, 0, 1), blDn = clamp(bl - step * i, 0, 1);
				let tryBg1 = hslToRgb(bh, bs, blUp), tryBg2 = hslToRgb(bh, bs, blDn);
				for (const testFg of testColors) {
					let c1 = contrast(testFg, tryBg1);
					if (c1 > bestC) {
						bestC = c1;
						bestFg = testFg;
						bestBg = tryBg1;
						bestFgCss = `rgb(${ testFg.join(',') })`;
						bestBgCss = `rgb(${ tryBg1.join(',') })`;
						bestStrategy = 'hsl_bg_bw_text';
					}
					let c2 = contrast(testFg, tryBg2);
					if (c2 > bestC) {
						bestC = c2;
						bestFg = testFg;
						bestBg = tryBg2;
						bestFgCss = `rgb(${ testFg.join(',') })`;
						bestBgCss = `rgb(${ tryBg2.join(',') })`;
						bestStrategy = 'hsl_bg_bw_text';
					}
				}
			}
			if (bestC >= requiredContrast) {
				el.style.setProperty('color', bestFgCss);
				el.style.setProperty('background-color', bestBgCss);
				return {
					success: true,
					newFgCss: bestFgCss,
					newBgCss: bestBgCss,
					newContrast: bestC,
					strategy: bestStrategy
				};
			}
		}
		el.style.setProperty('color', origFgCss);
		if (origBgCss)
			el.style.setProperty('background-color', origBgCss);
		return {
			success: false,
			newFgCss: origFgCss,
			newBgCss: origBgCss,
			newContrast: bestC,
			strategy: 'failed'
		};
	};
	AR_CheckModulesProto.checkFormFieldLabels = function () {
		ar_logSection('Form Field Labels');
		document.querySelectorAll('input:not([type="hidden"]):not([type="submit"]):not([type="reset"]):not([type="button"]), select, textarea').forEach(field => {
			if (field.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(field) || ar_hasAccessibleNameForElement(field))
					return;
				const fieldId = field.id || ar_generateUniqueElementId('field-');
				if (!field.id)
					field.id = fieldId;
				let labelText = (field.getAttribute('title') || '').trim() || (field.placeholder || '').trim();
				if (ar_hasExplicitLabel(field) || ar_hasParentLabel(field)) {
					return
				}
				if ((field.type === 'radio' || field.type === 'checkbox') && field.nextSibling && field.nextSibling.nodeType === Node.TEXT_NODE && (field.nextSibling.textContent || '').trim().length > 0) {
					const textNode = field.nextSibling;
					const newLabel = document.createElement('label');
					newLabel.htmlFor = fieldId;
					newLabel.appendChild(document.createTextNode((textNode.textContent || '').trim()));
					textNode.parentNode.insertBefore(newLabel, textNode.nextSibling);
					textNode.parentNode.removeChild(textNode);
					ar_logAccessibilityIssue('Moderate', `Radio/checkbox missing label. Auto-wrapped adjacent text.`, field, '**Manual review required.** Ensure the label accurately describes the input.', 'Perceivable', '3.3.2 / 1.3.1', true, 'A');
					return
				}
				if (labelText) {
					ar_setAttributeAndLog(field, 'aria-label', ar_escapeHtml(labelText), 'Moderate', `Field missing label. Auto-set aria-label from title/placeholder: "${ ar_escapeHtml(labelText) }".`, '**Manual review required.** Prefer visible <label> elements.', 'Perceivable', '3.3.2', 'A')
				} else {
					const newLabel = document.createElement('label');
					newLabel.htmlFor = fieldId;
					newLabel.textContent = field.name ? `Label for ${ field.name }` : `Label for field ${ fieldId }`;
					Object.assign(newLabel.style, {
						position: 'absolute',
						left: '-9999px',
						width: '1px',
						height: '1px',
						overflow: 'hidden'
					});
					if (field.parentElement) {
						field.parentElement.insertBefore(newLabel, field);
						ar_logAccessibilityIssue('Critical', `Field missing label. Auto-added generic hidden <label>.`, field, '**Manual review required.** Provide a descriptive and visible label for this form field.', 'Perceivable', '3.3.2', true, 'A')
					} else {
						ar_logAccessibilityIssue('Critical', `Field missing label. Could not auto-add <label> (no parent element).`, field, 'Provide a visible <label> element for this form field.', 'Perceivable', '3.3.2', false, 'A')
					}
				}
			} catch (e) {
				console.error('Error: FormFieldLabels Check:', e, field)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkFormValidationAria = function () {
		ar_logSection('Form Validation ARIA');
		document.querySelectorAll('input:not([type="hidden"]), select, textarea').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				this._checkRequiredAria(el);
				this._checkInvalidAria(el)
			} catch (e) {
				console.error('Error: FormValidationAria Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._checkRequiredAria = function (el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		const previousSiblingText = el.previousSibling && el.previousSibling.nodeType === Node.TEXT_NODE ? el.previousSibling.textContent.trim() : '';
		const parentLabel = el.closest('label');
		const labelText = parentLabel ? (parentLabel.textContent || '').trim() : '';
		const nextSiblingText = el.nextSibling && el.nextSibling.nodeType === Node.TEXT_NODE ? el.nextSibling.textContent.trim() : '';
		if ((previousSiblingText.endsWith('*') || labelText.includes('*') || nextSiblingText.startsWith('*')) && !el.hasAttribute('required') && el.getAttribute('aria-required') !== 'true') {
			ar_setAttributeAndLog(el, 'required', '', 'Minor', 'Field visually marked as required ("*") but missing `required` attribute. Auto-added `required`.', 'Ensure required fields have both `required` and `aria-required="true"`.', 'Robust', '3.3.2 / 4.1.2', 'A')
		}
		if (el.hasAttribute('required') && el.getAttribute('aria-required') !== 'true') {
			ar_setAttributeAndLog(el, 'aria-required', 'true', 'Moderate', 'Required field missing aria-required="true". Auto-fixed.', 'Add aria-required="true" for required form fields.', 'Robust', '4.1.2', 'A')
		}
	};
	AR_CheckModulesProto._checkInvalidAria = function (el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		const ariaInvalid = el.getAttribute('aria-invalid');
		if (ariaInvalid && ![
				'true',
				'false'
			].includes(ariaInvalid.toLowerCase())) {
			ar_setAttributeAndLog(el, 'aria-invalid', 'false', 'Minor', 'aria-invalid attribute has an invalid value. Auto-set to "false".', 'Use "true" or "false" for aria-invalid.', 'Robust', '4.1.2', 'A')
		}
		if (el.getAttribute('aria-invalid') === 'true' && !el.hasAttribute('aria-describedby')) {
			let errorMsgElement = null;
			const potentialErrorSibling = el.nextElementSibling;
			if (potentialErrorSibling && ((potentialErrorSibling.className || '').toLowerCase().includes('error') || (potentialErrorSibling.className || '').toLowerCase().includes('invalid') || potentialErrorSibling.getAttribute('role') === 'alert')) {
				errorMsgElement = potentialErrorSibling;
				if (!errorMsgElement.id) {
					errorMsgElement.id = ar_generateUniqueElementId('error-msg-')
				}
			} else {
				errorMsgElement = document.createElement('span');
				errorMsgElement.id = ar_generateUniqueElementId('error-msg-');
				errorMsgElement.textContent = 'Invalid input.';
				Object.assign(errorMsgElement.style, {
					position: 'absolute',
					left: '-9999px',
					width: '1px',
					height: '1px',
					overflow: 'hidden'
				});
				errorMsgElement.setAttribute('role', 'alert');
				if (el.parentNode) {
					el.parentNode.insertBefore(errorMsgElement, el.nextSibling)
				}
			}
			if (errorMsgElement && errorMsgElement.id) {
				ar_setAttributeAndLog(el, 'aria-describedby', errorMsgElement.id, 'Minor', `Input aria-invalid="true" missing aria-describedby. Auto-linked/added error message.`, 'Ensure invalid inputs are described by an error message via aria-describedby.', 'Understandable', '3.3.1', true, 'A')
			}
		}
	};
	AR_CheckModulesProto.checkLandmarkRoles = function (globalState) {
		ar_logSection('ARIA Landmark Roles / HTML5 Semantic Elements');
		this._identifyExistingLandmarks(globalState);
		this._ensureEssentialLandmarks(globalState);
		this._checkMultipleUniqueLandmarks(globalState);
		console.groupEnd()
	};
	AR_CheckModulesProto._identifyExistingLandmarks = function (globalState) {
		AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.forEach(role => {
			globalState.detectedLandmarkRoleCounts[role] = 0
		});
		AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.forEach(tag => {
			globalState.detectedLandmarkRoleCounts[tag] = globalState.detectedLandmarkRoleCounts[tag] || 0
		});
		document.querySelectorAll('*').forEach(el => {
			if (ar_isVisuallyHidden(el))
				return;
			const role = el.getAttribute('role');
			const tagName = el.tagName.toLowerCase();
			if (role && AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.includes(role)) {
				globalState.detectedLandmarkRoleCounts[role]++
			} else if (AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.includes(tagName)) {
				const implicitRole = {
					'main': 'main',
					'header': 'banner',
					'footer': 'contentinfo',
					'nav': 'navigation',
					'aside': 'complementary',
					'form': 'form',
					'section': el.hasAttribute('aria-label') || el.hasAttribute('aria-labelledby') ? 'region' : null
				}[tagName];
				if (implicitRole)
					globalState.detectedLandmarkRoleCounts[implicitRole]++
			}
		})
	};
	AR_CheckModulesProto._ensureEssentialLandmark = function (globalState, landmarkName, config) {
		const {selector, htmlTag, role, placement, contentHeuristic} = config;
		const body = document.body;
		if (globalState.detectedLandmarkRoleCounts[landmarkName] === 0) {
			let candidateElement = document.querySelector(htmlTag) || document.querySelector(`[role="${ role }"]`) || document.querySelector(selector);
			if (candidateElement) {
				if (candidateElement.tagName.toLowerCase() !== htmlTag && !candidateElement.getAttribute('role')) {
					ar_setAttributeAndLog(candidateElement, 'role', role, 'Moderate', `Missing ${ landmarkName } landmark. Auto-added role to <${ candidateElement.tagName.toLowerCase() }>.`, `Use <${ htmlTag }> or role="${ role }".`, 'Perceivable', '1.3.1', 'A');
					globalState.detectedLandmarkRoleCounts[landmarkName]++
				} else if (candidateElement.tagName.toLowerCase() === htmlTag && !candidateElement.getAttribute('role') && role !== htmlTag && landmarkName === role) {
					ar_setAttributeAndLog(candidateElement, 'role', role, 'Info', `<${ htmlTag }> candidate for ${ landmarkName }. Auto-added explicit role.`, `Consider explicit role for clarity.`, 'Perceivable', '1.3.1', 'A');
					globalState.detectedLandmarkRoleCounts[landmarkName]++
				} else if (!globalState.detectedLandmarkRoleCounts[landmarkName]) {
					globalState.detectedLandmarkRoleCounts[landmarkName]++
				}
			} else {
				const newLandmark = document.createElement(htmlTag);
				if (role !== htmlTag && role)
					newLandmark.setAttribute('role', role);
				let contentMoved = false;
				if (contentHeuristic) {
					const bodyChildren = Array.from(body.children);
					const headerEl = body.querySelector(AR_CheckModules._landmarkConfigs.banner.htmlTag + ', [role=banner]');
					const navEl = body.querySelector(AR_CheckModules._landmarkConfigs.navigation.htmlTag + ', [role=navigation]');
					const footerEl = body.querySelector(AR_CheckModules._landmarkConfigs.contentinfo.htmlTag + ', [role=contentinfo]');
					const childrenToMove = contentHeuristic(bodyChildren, headerEl, navEl, footerEl);
					if (childrenToMove.length > 0) {
						childrenToMove.forEach(child => {
							if (child.parentNode === body && child !== newLandmark && ![
									'SCRIPT',
									'STYLE',
									'LINK'
								].includes(child.tagName) && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID && !child.closest(AR_CheckModules._landmarkConfigs.banner.htmlTag) && !child.closest(AR_CheckModules._landmarkConfigs.navigation.htmlTag) && !child.closest(AR_CheckModules._landmarkConfigs.contentinfo.htmlTag) && !(child.tagName.toLowerCase() === 'main' && landmarkName !== 'main')) {
								newLandmark.appendChild(child);
								contentMoved = true
							}
						})
					}
				}
				if (placement === 'prepend' && body.firstChild)
					body.insertBefore(newLandmark, body.firstChild);
				else if (placement === 'append')
					body.appendChild(newLandmark);
				else if (placement === 'afterHeader') {
					const headerRef = body.querySelector(AR_CheckModules._landmarkConfigs.banner.htmlTag + ', [role=banner]');
					if (headerRef && headerRef.nextSibling)
						body.insertBefore(newLandmark, headerRef.nextSibling);
					else if (body.firstChild)
						body.insertBefore(newLandmark, body.firstChild);
					else
						body.appendChild(newLandmark)
				} else if (placement === 'beforeFooter') {
					const footerRef = body.querySelector(AR_CheckModules._landmarkConfigs.contentinfo.htmlTag + ', [role=contentinfo]');
					if (footerRef)
						body.insertBefore(newLandmark, footerRef);
					else
						body.appendChild(newLandmark)
				} else
					body.appendChild(newLandmark);
				ar_logAccessibilityIssue('Moderate', `Missing "${ landmarkName }" landmark. Aggressively Auto-created <${ htmlTag }>${ contentMoved ? ' and wrapped existing content.' : '.' }`, newLandmark, 'Verify the auto-generated structure. This is a significant DOM change.', 'Perceivable', '1.3.1', true, 'A');
				globalState.detectedLandmarkRoleCounts[landmarkName]++
			}
		}
	};
	AR_CheckModulesProto._landmarkConfigs = {
		'banner': {
			selector: AR_SELECTOR_STRINGS.COMMON_HEADER_SELECTORS,
			htmlTag: 'header',
			role: 'banner',
			placement: 'prepend',
			contentHeuristic: children => children.filter(c => c.tagName.toLowerCase() !== 'script' && c.tagName.toLowerCase() !== 'style' && c.tagName.toLowerCase() !== 'link' && !c.id.includes(AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID) && !c.id.includes(AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID)).slice(0, Math.min(children.length, 3))
		},
		'navigation': {
			selector: AR_SELECTOR_STRINGS.COMMON_NAV_SELECTORS,
			htmlTag: 'nav',
			role: 'navigation',
			placement: 'afterHeader',
			contentHeuristic: children => {
				const navCand = children.find(c => c.tagName === 'UL' && c.querySelectorAll('li > a[href]').length > 2);
				return navCand ? [navCand] : []
			}
		},
		'main': {
			selector: AR_SELECTOR_STRINGS.MAIN_CONTENT_TARGET_SELECTORS,
			htmlTag: 'main',
			role: 'main',
			placement: 'beforeFooter',
			contentHeuristic: (children, header, nav, footer) => {
				const mainContent = [];
				let inMainSection = false;
				for (const child of children) {
					if (child === header || child === nav || child.id === AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID || child.id === AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID || [
							'SCRIPT',
							'STYLE',
							'LINK'
						].includes(child.tagName)) {
						if (!inMainSection && child !== header && child !== nav) {
							continue
						}
					}
					if (child === footer) {
						break
					}
					inMainSection = true;
					mainContent.push(child)
				}
				return mainContent.length > 0 ? mainContent : children.filter(c => c !== header && c !== nav && c !== footer && ![
					'SCRIPT',
					'STYLE'
				].includes(c.tagName) && c.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && c.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID).slice(0, Math.max(1, children.length - (header ? 1 : 0) - (nav ? 1 : 0) - (footer ? 1 : 0) - 2))
			}
		},
		'contentinfo': {
			selector: AR_SELECTOR_STRINGS.COMMON_FOOTER_SELECTORS,
			htmlTag: 'footer',
			role: 'contentinfo',
			placement: 'append',
			contentHeuristic: children => children.length > 1 ? children.slice(Math.max(0, children.length - 2)) : children
		}
	};
	AR_CheckModulesProto._ensureEssentialLandmarks = function (globalState) {
		for (const landmarkName in this._landmarkConfigs) {
			this._ensureEssentialLandmark(globalState, landmarkName, this._landmarkConfigs[landmarkName])
		}
	};
	AR_CheckModulesProto._checkMultipleUniqueLandmarks = function (globalState) {
		[
			'main',
			'banner',
			'contentinfo'
		].forEach(roleName => {
			if (globalState.detectedLandmarkRoleCounts[roleName] > 1) {
				const elements = document.querySelectorAll(`${ this._landmarkConfigs[roleName].htmlTag }, [role="${ roleName }"]`);
				ar_logAccessibilityIssue('Minor', `Multiple "${ roleName }" landmarks (${ globalState.detectedLandmarkRoleCounts[roleName] }).`, elements.length > 0 ? elements[0] : document.body, `There should typically be only one "${ roleName }" landmark per page. Consider consolidating or using other roles.`, 'Perceivable', '1.3.1 / 2.4.1', false, 'A')
			}
		})
	};
	AR_CheckModulesProto.checkFocusIndicators = function () {
		ar_logSection('Focus Indicators');
		let styleTag = document.getElementById('ar-focus-style');
		if (!styleTag) {
			styleTag = document.createElement('style');
			styleTag.id = 'ar-focus-style';
			styleTag.textContent = `${ AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS.split(',').map(s => `${ s.trim() }:focus-visible`).join(',\n') } { outline: 3px solid #0056b3 !important; outline-offset: 2px !important; box-shadow: 0 0 0 3px rgba(112, 161, 255, 0.5) !important; }`;
			document.head.appendChild(styleTag);
			ar_logAccessibilityIssue('Info', 'Injected global CSS for :focus-visible. This provides a default focus indicator.', styleTag, 'Review custom focus styles to ensure they are visible and meet WCAG 2.4.7.', 'Operable', '2.4.7 / 2.4.11', true, 'AA')
		}
		document.querySelectorAll(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const computedStyle = window.getComputedStyle(el);
				const defaultOutlineNone = computedStyle.outlineStyle === 'none' || parseFloat(computedStyle.outlineWidth) === 0;
				const defaultBoxShadowNone = computedStyle.boxShadow === 'none' || computedStyle.boxShadow === '';
				if (defaultOutlineNone && defaultBoxShadowNone) {
					if (el.style.outline === 'none !important' || el.style.outlineStyle === 'none' && el.style.getPropertyPriority('outline-style') === 'important') {
						ar_logAccessibilityIssue('Moderate', 'Element has `outline: none !important;`. This can override default focus indicators.', el, 'Avoid using `!important` to remove outlines. Ensure a visible focus indicator is provided via `:focus-visible`.', 'Operable', '2.4.7', false, 'AA')
					} else if (defaultOutlineNone) {
						ar_logAccessibilityIssue('Minor', 'Element has `outline: none`. Ensure :focus-visible provides a clear indicator.', el, 'Verify that a visible focus indicator is provided for keyboard users, especially if `outline: none` is used.', 'Operable', '2.4.7', false, 'AA')
					}
				}
			} catch (e) {
				console.error('Error: FocusIndicators Check:', e, el)
			}
		});
		console.log('\n\uD83D\uDCA1 Manual Verification for Focus Indicators is CRUCIAL. Ensure custom focus styles are clearly visible and meet WCAG 2.4.7 and 2.4.11.');
		console.groupEnd()
	};
	AR_CheckModulesProto.checkSkipLinks = function (globalState) {
		ar_logSection('Skip Link');
		const existingSkipLink = document.querySelector('a[href^="#"]:first-child, a.skip-link:first-child, [data-skip-link="true"]:first-child');
		if (!existingSkipLink || ar_isVisuallyHidden(existingSkipLink)) {
			const newSkipLink = this._createSkipLinkElement();
			let mainContentTarget = this._findMainContentTarget();
			if (mainContentTarget) {
				if (!mainContentTarget.id)
					mainContentTarget.id = ar_generateUniqueElementId('main-content-target-');
				if (mainContentTarget.getAttribute('tabindex') === null && !mainContentTarget.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS) && mainContentTarget.getAttribute('role') !== 'region' && mainContentTarget.tagName !== 'MAIN') {
					ar_setAttributeAndLog(mainContentTarget, 'tabindex', '-1', 'Info', 'Main content target for skip link made focusable (tabindex="-1").', 'Ensure the main content area is focusable for skip links to work correctly.', 'Operable', '2.4.1', true, 'A')
				}
				newSkipLink.href = `#${ mainContentTarget.id }`;
				document.body.prepend(newSkipLink);
				ar_logAccessibilityIssue('Moderate', 'No visible "skip to main content" link found. Auto-injected.', newSkipLink, 'Ensure the skip link is the first focusable element, is visible on focus, and targets the main content area.', 'Operable', '2.4.1', true, 'A')
			} else {
				ar_logAccessibilityIssue('Moderate', 'No "skip to main content" link found and no clear main content target identified.', document.body, 'Implement a "skip to main content" link that targets the primary content area of the page.', 'Operable', '2.4.1', false, 'A')
			}
		}
		console.groupEnd()
	};
	AR_CheckModulesProto._createSkipLinkElement = function () {
		const skipLink = document.createElement('a');
		skipLink.textContent = 'Skip to main content';
		Object.assign(skipLink.style, {
			position: 'absolute',
			left: '-9999px',
			top: 'auto',
			width: '1px',
			height: '1px',
			overflow: 'hidden',
			zIndex: '99999',
			padding: '0.5em 1em',
			backgroundColor: '#f0f0f0',
			color: '#333',
			textDecoration: 'none',
			borderRadius: '3px',
			border: '1px solid #ccc',
			transition: 'left 0s 0.3s, top 0s 0.3s'
		});
		skipLink.onfocus = function () {
			Object.assign(this.style, {
				left: '10px',
				top: '10px',
				width: 'auto',
				height: 'auto',
				zIndex: '2147483647',
				boxShadow: '0 0 10px rgba(0,0,0,0.5)',
				transitionDelay: '0s'
			})
		};
		skipLink.onblur = function () {
			Object.assign(this.style, {
				left: '-9999px',
				top: 'auto',
				width: '1px',
				height: '1px',
				zIndex: '99999',
				boxShadow: 'none',
				transitionDelay: '0s 0.3s'
			})
		};
		return skipLink
	};
	AR_CheckModulesProto._findMainContentTarget = function () {
		let target = document.querySelector(AR_SELECTOR_STRINGS.MAIN_CONTENT_TARGET_SELECTORS) || document.querySelector('article') || document.querySelector('section[aria-label], section[aria-labelledby]');
		if (!target) {
			for (let i = 0; i < document.body.children.length; i++) {
				const child = document.body.children[i];
				if (!child.matches('script, style, link') && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID && !child.classList.contains('skip-link')) {
					target = child;
					break
				}
			}
		}
		return target
	};
	AR_CheckModulesProto.checkDocumentGlobals = function () {
		ar_logSection('Global Document Setup');
		const head = document.head;
		const body = document.body;
		this._checkDocumentTitle(head, body);
		this._checkViewportMeta(head);
		this._checkMetaRefresh(head);
		if (!head.querySelector('#ar-focus-style'))
			AR_CheckModules.checkFocusIndicators();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkDocumentTitle = function (head, body) {
		const titleElement = head.querySelector('title');
		if (!titleElement || !(titleElement.textContent || '').trim()) {
			const h1 = body.querySelector('h1');
			const h1Text = h1 && h1.textContent ? h1.textContent.trim().substring(0, 60) : '';
			let newTitleText = (h1Text || 'Untitled Page') + (h1Text ? '' : ' - AutoTitle');
			let newTitleEl = titleElement || document.createElement('title');
			ar_setAttributeAndLog(newTitleEl, 'textContent', ar_escapeHtml(newTitleText), 'Critical', `Document title missing or empty. Auto-generated: "${ ar_escapeHtml(newTitleText) }".`, '**Manual review required.** Provide a descriptive and unique title for the page.', 'Operable', '2.4.2 Page Titled', 'A');
			if (!titleElement)
				head.appendChild(newTitleEl)
		}
	};
	AR_CheckModulesProto._checkViewportMeta = function (head) {
		let viewportMeta = head.querySelector('meta[name="viewport"]');
		const currentContent = viewportMeta ? viewportMeta.content : '';
		let newContent = currentContent;
		let issueFound = false;
		if (!viewportMeta || !currentContent) {
			newContent = 'width=device-width, initial-scale=1.0, user-scalable=yes';
			issueFound = true;
			if (!viewportMeta) {
				viewportMeta = document.createElement('meta');
				viewportMeta.name = 'viewport';
				head.appendChild(viewportMeta)
			}
			ar_setAttributeAndLog(viewportMeta, 'content', newContent, 'Critical', 'Viewport meta tag missing or empty. Auto-added responsive viewport.', 'Ensure a proper viewport meta tag is present for responsive design and user zoom.', 'Perceivable', '1.4.10 / 1.4.4', 'AA');
			return
		}
		if (!currentContent.includes('width=device-width')) {
			newContent = `width=device-width${ newContent.length > 0 ? ',' : '' }${ newContent }`;
			issueFound = true
		}
		if (!/initial-scale\s*=\s*1(\.0*)?/.test(currentContent)) {
			newContent = `${ newContent }${ newContent.length > 0 ? ',' : '' }initial-scale=1.0`;
			issueFound = true
		}
		if (currentContent.includes('user-scalable=no')) {
			newContent = newContent.replace(/user-scalable=no[,]?/g, '');
			issueFound = true
		}
		if (/maximum-scale\s*=\s*1(\.0*)?/.test(currentContent)) {
			newContent = newContent.replace(/maximum-scale\s*=\s*1(\.0*)?[,]?/g, '');
			issueFound = true
		}
		if (!newContent.includes('user-scalable=yes') && !newContent.includes('user-scalable=no')) {
			newContent = `${ newContent }${ newContent.length > 0 ? ',' : '' }user-scalable=yes`;
			issueFound = true
		}
		newContent = newContent.replace(/,{2,}/g, ',').replace(/,\s*$/, '').trim();
		if (issueFound && newContent !== currentContent) {
			ar_setAttributeAndLog(viewportMeta, 'content', newContent, 'Moderate', `Viewport meta tag improper. Auto-corrected to "${ newContent }".`, 'Avoid `user-scalable=no` or `maximum-scale=1.0` to allow users to zoom.', 'Perceivable', '1.4.4 / 1.4.10', 'AA')
		}
	};
	AR_CheckModulesProto._checkMetaRefresh = function (head) {
		const metaRefresh = head.querySelector('meta[http-equiv="refresh"]');
		if (metaRefresh) {
			ar_logAccessibilityIssue('Critical', 'Meta refresh tag found. This can disorient users.', metaRefresh, 'Avoid using meta refresh. Use server-side redirects or JavaScript with user controls for timed updates.', 'Operable', '2.2.1 / 2.2.4', false, 'A')
		}
	}
}(AR_CheckModules))

function ar_setupMutationObserverForContrast() {
	const observer = new MutationObserver(mutationsList => {
		for (const mutation of mutationsList) {
			if (mutation.type === 'attributes' && (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
				if (mutation.target.nodeType === Node.ELEMENT_NODE) {
					AR_CheckModules.checkContrastRatioForAllElements(mutation.target)
				}
			} else if (mutation.type === 'childList') {
				mutation.addedNodes.forEach(node => {
					if (node.nodeType === Node.ELEMENT_NODE) {
						AR_CheckModules.checkContrastRatioForAllElements(node);
						node.querySelectorAll('*').forEach(descendant => AR_CheckModules.checkContrastRatioForAllElements(descendant))
					}
				})
			}
		}
	});
	observer.observe(document.body, {
		attributes: true,
		childList: true,
		subtree: true,
		attributeFilter: [
			'style',
			'class'
		]
	});
	console.log('\uD83D\uDCA1 MutationObserver for live contrast changes is active.')
}
async function ar_runAccessibilityScan() {
	ar_loggedIssuesTracker.clear();
	ar_accessibilityIssuesLog.length = 0;
	ar_totalScannedIssuesCounter = 0;
	ar_totalAutoFixedIssuesCounter = 0;
	console.log('%c Accessibility Resolver ', 'background:#0056b3;color:white;font-size:1.5em;font-weight:bold;padding:10px 20px;border-radius:5px;');
	console.log('Scanning for accessibility issues and applying auto-fixes...');
	console.time('AccessibilityScanDuration');
	const docElement = document.documentElement;
	const globalState = {
		lastHeadingLevel: 0,
		seenIds: new Map(),
		detectedLandmarkRoleCounts: {}
	};
	AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.forEach(role => {
		globalState.detectedLandmarkRoleCounts[role] = 0
	});
	AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.forEach(tag => {
		globalState.detectedLandmarkRoleCounts[tag] = globalState.detectedLandmarkRoleCounts[tag] || 0
	});
	AR_CheckModules.checkDocumentGlobals();
	AR_CheckModules.checkLangAttribute();
	AR_CheckModules.checkSkipLinks(globalState);
	AR_CheckModules.checkContentStructure(globalState);
	AR_CheckModules.checkMediaIntegrity();
	AR_CheckModules.checkImageAltText();
	AR_CheckModules.checkIframeTitles();
	AR_CheckModules.checkTableAccessibility();
	AR_CheckModules.checkOverlayFocusBlocking();
	AR_CheckModules.checkInteractiveElementSize();
	AR_CheckModules.checkAriaMisuse();
	AR_CheckModules.checkHoverFocusContent();
	AR_CheckModules.checkAutoFormSubmission();
	AR_CheckModules.checkDuplicateIds(globalState);
	AR_CheckModules.checkAccessibleNames();
	AR_CheckModules.checkTabindexUsage();
	AR_CheckModules.checkContrastRatioForAllElements();
	AR_CheckModules.checkFormFieldLabels();
	AR_CheckModules.checkFormValidationAria();
	AR_CheckModules.checkLandmarkRoles(globalState);
	AR_CheckModules.checkFocusIndicators();
	ar_setupMutationObserverForContrast();
	console.log('\n%c Accessibility Check and Auto-Fix Summary ', 'font-size:1.3em;font-weight:bold;color:#003973;padding:5px;background:#e3f2fd;border-bottom:2px solid #003973;display:block;text-align:center;');
	const unresolvedIssues = ar_accessibilityIssuesLog.filter(r => !r.isAutofixed);
	console.log(`%cTotal Issues Identified: %c${ ar_accessibilityIssuesLog.length }`, 'font-weight:bold;', 'font-weight:normal;');
	console.log(`%cAuto-Fixed: %c${ ar_totalAutoFixedIssuesCounter }`, 'font-weight:bold;color:green;', `font-weight:normal;color:${ ar_totalAutoFixedIssuesCounter > 0 ? 'green' : 'grey' };`);
	console.log(`%cUnresolved: %c${ unresolvedIssues.length }`, 'font-weight:bold;color:red;', `font-weight:normal;color:${ unresolvedIssues.length > 0 ? 'red' : 'green' };`);
	[
		'Critical',
		'Moderate',
		'Minor',
		'Info'
	].forEach(severity => {
		const issues = unresolvedIssues.filter(r => r.severity === severity && r.wcagLevel !== 'User');
		if (issues.length > 0) {
			const colorMap = {
				'Critical': '#c62828',
				'Moderate': '#ef6c00',
				'Minor': '#0277bd',
				'Info': '#546e7a'
			};
			console.groupCollapsed(`%c ${ severity } Unresolved: ${ issues.length } `, `color:white;background-color:${ colorMap[severity] };padding:3px 7px;border-radius:3px;font-weight:bold;`);
			issues.forEach(issue => {
				console.log(`%cMessage: %c${ issue.message }`, 'font-weight:bold;', '');
				if (issue.element instanceof HTMLElement)
					console.log('%cElement:', 'font-style:italic;', issue.element);
				if (issue.recommendation)
					console.log(`%cRecommendation: %c${ issue.recommendation }`, 'font-style:italic;color:#01579b;', '');
				if (issue.wcagGuideline)
					console.log(`%cWCAG: %c${ issue.wcagGuideline } (${ issue.wcagLevel })`, 'font-style:italic;color:#311b92;', '');
				console.log('---')
			});
			console.groupEnd()
		}
	});
	if (unresolvedIssues.filter(r => r.wcagLevel !== 'User').length > 0) {
		console.log("\n%cReview unresolved issues by expanding the groups above. The 'accessibilityScanGlobalResults' object in the console contains all findings.", 'color:#01579b;');
		window.accessibilityScanGlobalResults = ar_accessibilityIssuesLog
	} else if (ar_accessibilityIssuesLog.filter(r => r.wcagLevel !== 'User' && !r.isAutofixed).length === 0) {
		console.log('%c\uD83C\uDF89 All identified automated accessibility issues were either fixed or not detected in this scan!', 'color:green;font-weight:bold;font-size:1.1em;')
	}
	console.timeEnd('AccessibilityScanDuration');
	const generalObserver = new MutationObserver(() => {
		clearTimeout(ar_mainMutationObserverDebounceTimeout);
		ar_mainMutationObserverDebounceTimeout = setTimeout(() => {
			generalObserver.disconnect();
			console.warn('%cDOM has changed significantly. Re-run Accessibility Resolver for an accurate report.', 'color:orange;font-weight:bold;background:lightyellow;padding:5px;')
		}, AR_CONFIG.MUTATION_OBSERVER_DEBOUNCE_MILLISECONDS)
	});
	generalObserver.observe(docElement, {
		attributes: true,
		childList: true,
		subtree: true,
		characterData: true,
		attributeFilter: [
			'style',
			'class',
			'alt',
			'href',
			'role',
			'tabindex',
			'aria-hidden',
			'aria-label',
			'id',
			'for',
			'value',
			'src',
			'lang',
			'title'
		]
	})
}

function ar_initializeAndRunMerged() {
	console.log('%c Made by Yaron Koresh ', 'background:#4CAF50;color:white;font-size:1em;font-weight:bold;padding:5px 10px;border-radius:3px;');
	if (typeof AR_AccessibilityMenu.init !== 'function') {
		console.error('AR_AccessibilityMenu.init is not defined. Check script loading order for ar_menu_ui.js and ar_menu_actions.js.');
		return
	}
	if (typeof AR_CheckModules.checkDocumentGlobals !== 'function') {
		console.error('AR_CheckModules methods are not defined. Check script loading order for ar_check_modules_part1/2.js.');
		return
	}
	setDeviceOrientation();
	setDeviceType();
	const device = getDevice();
	if(!device.includes('mobile')){
		AR_AccessibilityMenu.init();
	}
	ar_runAccessibilityScan();
}

if (document.readyState === 'complete') {
	ar_initializeAndRunMerged();
} else {
	document.addEventListener('readystatechange', () => {
		if (document.readyState === 'complete') {
			ar_initializeAndRunMerged();
		}
	});
}
