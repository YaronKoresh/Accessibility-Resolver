const AR_CONFIG = {
	MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX: 24,
	MINIMUM_TOUCH_TARGET_SPACING_PX: 8,
	CONTRAST_RATIO_AA_NORMAL_TEXT: 4.5,
	CONTRAST_RATIO_AA_LARGE_TEXT: 3,
	CONTRAST_RATIO_AAA_NORMAL_TEXT: 7,
	CONTRAST_RATIO_AAA_LARGE_TEXT: 4.5,
	NON_TEXT_CONTRAST_RATIO_AA: 3,
	LARGE_TEXT_FONT_SIZE_PX: 24,
	LARGE_TEXT_FONT_SIZE_BOLD_PX: 18.66,
	MINIMUM_BODY_TEXT_FONT_SIZE_PX: 13,
	MAX_CHARS_FOR_WALL_OF_TEXT_DETECTION: 600,
	MAX_REPETITIONS_FOR_GENERIC_LINK_TEXT: 2,
	MUTATION_OBSERVER_DEBOUNCE_MILLISECONDS: 750,
	MAX_CHAR_LENGTH_FOR_HEADINGS: 90,
	MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT: 3,
	MAX_SIBLING_SEARCH_DEPTH_FOR_ARIA_RELATIONSHIP: 4,
	MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL: 120,
	MIN_CONTRAST_FOR_PDF_ICON: 2.5,
	MIN_CHAR_LENGTH_FOR_REDUNDANT_TITLE_CHECK: 4,
	MAX_WORDS_FROM_CONTEXT_FOR_GENERIC_LINK_ARIA_LABEL: 12,
	ACCESSIBILITY_MENU_BUTTON_ID: 'accessibility-resolver-menu-toggle-button',
	ACCESSIBILITY_MENU_PANEL_ID: 'accessibility-resolver-menu-panel',
	DEFAULT_FONT_SIZE_ADJUSTMENT_INCREMENT: 0.1,
	MAX_FONT_SIZE_ADJUSTMENT_MULTIPLIER: 3,
	MIN_FONT_SIZE_ADJUSTMENT_MULTIPLIER: 0.6,
	READING_MASK_ELEMENT_ID: 'accessibility-resolver-reading-mask',
	READING_LINE_ELEMENT_ID: 'accessibility-resolver-reading-line',
	DYSLEXIA_FRIENDLY_FONT_CLASS_NAME: 'accessibility-resolver-dyslexia-font',
	SATURATION_FILTER_CLASS_NAME: 'accessibility-resolver-saturation-filter',
	TEXT_ALIGNMENT_CLASS_NAME_PREFIX: 'accessibility-resolver-text-align-',
	INCREASED_LETTER_SPACING_CLASS_NAME: 'accessibility-resolver-increased-letter-spacing',
	INCREASED_WORD_SPACING_CLASS_NAME: 'accessibility-resolver-increased-word-spacing',
	INCREASED_LINE_HEIGHT_CLASS_NAME: 'accessibility-resolver-increased-line-height',
	ANIMATIONS_STOPPED_CLASS_NAME: 'accessibility-resolver-animations-stopped',
	HIGHLIGHTED_LINKS_CLASS_NAME: 'accessibility-resolver-highlight-links',
	HIGHLIGHTED_HEADINGS_CLASS_NAME: 'accessibility-resolver-highlight-headings',
	HIGH_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-high',
	INVERTED_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-inverted',
	GRAYSCALE_CONTRAST_MODE_CLASS_NAME: 'accessibility-resolver-contrast-grayscale',
	LOW_SATURATION_CLASS_NAME: 'accessibility-resolver-saturation-low',
	AVATAR_KEYWORDS: [
		'avatar',
		'profile',
		'usericon',
		'dp',
		'user-img',
		'user_image'
	],
	FILENAME_CLEANUP_REGEX: /[-_]/g,
	COMMON_ICON_CLASS_PREFIXES: [
		'fa-',
		'fas',
		'far',
		'fal',
		'fad',
		'fab',
		'glyphicon-',
		'icon-',
		'material-icons',
		'mdi-',
		'bi-',
		'icofont-'
	],
	MENU_ICON_COLOR: '#455a64',
	MENU_ICON_ACTIVE_COLOR: '#ffffff',
	MENU_TEXT_ACTIVE_COLOR: '#ffffff',
	PLACEHOLDER_IMAGE_URL: 'https://placehold.co/{width}x{height}/E0E0E0/BDBDBD?text={text}',
	CONTRAST_ADJUSTMENT_STEPS: 10,
	CONTRAST_ADJUSTMENT_AMOUNT: 0.1,
	AGGRESSIVE_CONTRAST_BG_ADJUST_MAX_DELTA: 0.25
};
const AR_SELECTOR_STRINGS = {
	INTERACTIVE_ELEMENTS: 'button, a[href], input:not([type="hidden"]), select, textarea, [role="button"], [role="link"], [role="checkbox"], [role="radio"], [role="option"], [role="menuitem"], [role="tab"], [role="treeitem"], [role="slider"], [role="spinbutton"], [role="switch"], [tabindex]:not([tabindex="-1"])',
	HEADING_ELEMENTS: 'h1, h2, h3, h4, h5, h6',
	TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU: `:is(p, li, dt, dd, figcaption, blockquote, pre, code, summary, h1, h2, h3, h4, h5, h6, article, section, main, header, footer, nav, aside, div:not(#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }):not(#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID }):not([role="toolbar"]):not([role="menubar"]):not([class*="toast"]):not([class*="modal"]):not([class*="popup"]), span:not(#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID } *):not(#${ AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID } *), td, th, caption, label, legend, em, strong, b, i, small, sub, sup, mark, ins, del, q, cite):not(:has(:not(br)))`.replace(/\s+/g, ' ').trim(),
	FORM_CONTROL_ELEMENTS: 'input:not([type="hidden"]), select, textarea',
	LANDMARK_ROLES_ARRAY: [
		'main',
		'banner',
		'contentinfo',
		'navigation',
		'complementary',
		'form',
		'region',
		'search'
	],
	LANDMARK_HTML_TAGS_ARRAY: [
		'main',
		'header',
		'footer',
		'nav',
		'aside',
		'form',
		'section'
	],
	MEDIA_ELEMENTS: 'img, svg, canvas, iframe, audio, video',
	MAIN_CONTENT_TARGET_SELECTORS: 'main, [role="main"], #main, #content, .main, .page-content, article, #main-content, [data-main-content], .container, .wrapper, #page-wrapper, div[class*="content-area" i], section[class*="main-content" i]',
	NATIVE_INTERACTIVE_TAGS: 'button, a, input, select, textarea',
	COMMON_HEADER_SELECTORS: 'body > header, body > div[id*="header" i], body > div[class*="header" i], body > div[id*="banner" i], body > div[class*="banner" i], body > .site-header, body > #site-header, body > #masthead',
	COMMON_FOOTER_SELECTORS: 'body > footer, body > div[id*="footer" i], body > div[class*="footer" i], body > div[id*="colophon" i], body > .site-footer, body > #site-footer',
	COMMON_NAV_SELECTORS: 'body > nav, body > div[id*="nav" i], body > div[class*="nav" i], body > ul[class*="nav" i], body > div[id*="menu" i], body > ul[id*="menu" i], body > .main-nav, body > #main-nav, body > .primary-navigation'
};
let ar_accessibilityIssuesLog = [];
let ar_totalScannedIssuesCounter = 0;
let ar_totalAutoFixedIssuesCounter = 0;
const ar_generatedUniqueElementIds = new Set();
const ar_detectedLandmarkRoleCounts = {};
let ar_mainMutationObserverDebounceTimeout;
const ar_originalElementStylesMap = new Map();
let ar_activeReadingGuideType = null;
const ar_loggedIssuesTracker = new Set()
function getDevice(){
	return [
		(document.body.classList.contains('tablet') ? 'tablet' : document.body.classList.contains('mobile') ? 'mobile' : 'desktop' ),
		(document.body.classList.contains('portrait') ? 'portrait' : 'landscape')
	];
}
function setDeviceOrientation() {
	function _setDeviceOrientation() {
		const newOrientation = screen.orientation.type;
		document.body.classList.remove('portrait', 'landscape');
		if (newOrientation.includes('portrait')) {
		    document.body.classList.add('portrait');
		} else if (newOrientation.includes('landscape')) {
		    document.body.classList.add('landscape');
		}
	}
	screen.orientation.addEventListener('change', function(e) {
		return _setDeviceOrientation();
	});
	return _setDeviceOrientation();
}
function setDeviceType() {
	const ua = navigator.userAgent;
	document.body.classList.remove('tablet', 'mobile', 'desktop');
	if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) {
		document.body.classList.add( "tablet" );
	} else if ( /Mobile|iP(hone|od)|Android|BlackBerry|IEMobile|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test( ua )) {
		document.body.classList.add( "mobile" );
	} else {
		document.body.classList.add( "desktop" );
	}
}
function ar_generateUniqueElementId(prefix = 'ar-uid') {
	let newId;
	let attempts = 0;
	do {
		newId = `${ prefix }-${ Math.random().toString(36).substring(2, 9) }${ attempts > 0 ? '-' + attempts : '' }`;
		attempts++
	} while (document.getElementById(newId) || ar_generatedUniqueElementIds.has(newId));
	ar_generatedUniqueElementIds.add(newId);
	return newId
}
function ar_isVisuallyHidden(element) {
	if (!element)
		return true;
	const style = window.getComputedStyle(element);
	return style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0' || element.offsetWidth === 0 || element.offsetHeight === 0
}
function ar_parseCssColorString(colorString) {
	if (!colorString || typeof colorString !== 'string')
		return [
			0,
			0,
			0,
			0
		];
	const div = document.createElement('div');
	Object.assign(div.style, {
		color: 'transparent',
		backgroundColor: 'transparent',
		display: 'none'
	});
	if (!document.body)
		return [
			0,
			0,
			0,
			0
		];
	document.body.appendChild(div);
	try {
		div.style.color = colorString;
		const compColor = window.getComputedStyle(div).color;
		const match = compColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
		if (match) {
			return [
				+match[1],
				+match[2],
				+match[3],
				match[4] !== undefined ? parseFloat(match[4]) : 1
			]
		}
	} catch (e) {
	} finally {
		div.remove()
	}
	return [
		0,
		0,
		0,
		0
	]
}
function ar_getLuminanceFromRgb(rgbArray) {
	const a = rgbArray.slice(0, 3).map(v => {
		v /= 255;
		return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)
	});
	return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722
}
function ar_getContrastRatioBetweenColors(rgba1, rgba2) {
	const lum1 = ar_getLuminanceFromRgb(rgba1);
	const lum2 = ar_getLuminanceFromRgb(rgba2);
	return (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05)
}
function ar_blendColors(fgRgba, bgRgba) {
	const alpha = fgRgba[3];
	if (alpha === 1)
		return fgRgba;
	const r = Math.round((1 - alpha) * bgRgba[0] + alpha * fgRgba[0]);
	const g = Math.round((1 - alpha) * bgRgba[1] + alpha * fgRgba[1]);
	const b = Math.round((1 - alpha) * bgRgba[2] + alpha * fgRgba[2]);
	return [
		r,
		g,
		b,
		1
	]
}
function ar_getEffectiveBackgroundColorOfElement(element) {
	let currentEl = element;
	while (currentEl && currentEl !== document.documentElement) {
		const style = window.getComputedStyle(currentEl);
		const bgColor = style.backgroundColor;
		if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
			const rgba = ar_parseCssColorString(bgColor);
			if (rgba[3] === 1)
				return rgba
		}
		if (currentEl === document.body || !currentEl.parentElement)
			break;
		currentEl = currentEl.parentElement
	}
	const bodyBg = ar_parseCssColorString(window.getComputedStyle(document.body).backgroundColor);
	return bodyBg[3] === 1 ? bodyBg : [
		255,
		255,
		255,
		1
	]
}
function ar_isTextLargeForWCAG(element) {
	const style = window.getComputedStyle(element);
	const fontSize = parseFloat(style.fontSize);
	const fontWeight = style.fontWeight;
	return fontSize >= AR_CONFIG.LARGE_TEXT_FONT_SIZE_PX || fontSize >= AR_CONFIG.LARGE_TEXT_FONT_SIZE_BOLD_PX && (parseInt(fontWeight) >= 700 || fontWeight === 'bold' || fontWeight === 'bolder')
}
function ar_rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	const max = Math.max(r, g, b), min = Math.min(r, g, b);
	let h, s, l = (max + min) / 2;
	if (max === min) {
		h = s = 0
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
		case r:
			h = (g - b) / d + (g < b ? 6 : 0);
			break;
		case g:
			h = (b - r) / d + 2;
			break;
		case b:
			h = (r - g) / d + 4;
			break
		}
		h /= 6
	}
	return [
		h,
		s,
		l
	]
}
function ar_hslToRgb(h, s, l) {
	let r, g, b;
	if (s === 0) {
		r = g = b = l
	} else {
		const hue2rgb = (p, q, t) => {
			if (t < 0)
				t += 1;
			if (t > 1)
				t -= 1;
			if (t < 1 / 6)
				return p + (q - p) * 6 * t;
			if (t < 1 / 2)
				return q;
			if (t < 2 / 3)
				return p + (q - p) * (2 / 3 - t) * 6;
			return p
		};
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3)
	}
	return [
		Math.round(r * 255),
		Math.round(g * 255),
		Math.round(b * 255)
	]
}
function ar_getLogMeta(severity, isAutofixed) {
	const styles = {
		'Critical': {
			p: '\u274C Critical:',
			s: 'color:white;background:#d32f2f;border-left:4px solid #b71c1c;'
		},
		'Moderate': {
			p: '\u26A0ï¸ Moderate:',
			s: 'color:black;background:#ffb300;border-left:4px solid #e65100;'
		},
		'Minor': {
			p: '\uD83D\uDCA1 Minor:',
			s: 'color:black;background:#64b5f6;border-left:4px solid #1976d2;'
		},
		'Info': {
			p: 'â„¹ï¸ Info:',
			s: 'color:#37474f;background:#eceff1;border-left:4px solid #90a4ae;'
		}
	};
	const fixStyle = {
		p: '\u2705 Auto-Fixed:',
		s: 'color:darkgreen;background:#c8e6c9;border-left:4px solid #388e3c;'
	};
	return isAutofixed ? fixStyle : styles[severity] || styles.Info
}
function ar_logIssueDetails(element, recommendation, wcagPrinciple, wcagGuideline, wcagLevel, isAutofixed, severity) {
	if (element instanceof HTMLElement) {
		console.log('%cElement:', 'font-weight:bold;color:#424242;margin-left:15px;', element)
	} else if (typeof element === 'string') {
		console.log(`%cContext: %c${ element }`, 'font-weight:bold;color:#424242;margin-left:15px;', 'color:#424242;')
	}
	if (recommendation && (!isAutofixed || severity === 'Critical' || severity === 'Moderate')) {
		console.log(`%cRecommendation: %c${ recommendation }`, 'font-weight:bold;color:#0d47a1;margin-left:15px;padding-left:8px;border-left:3px solid #bbdefb;', 'color:#1565c0;')
	}
	if (wcagGuideline) {
		console.log(`%cWCAG: %c${ wcagGuideline } (${ wcagLevel }) - ${ wcagPrinciple }`, 'font-weight:bold;color:#4a148c;margin-left:15px;padding-left:8px;border-left:3px solid #e1bee7;', 'color:#6a1b9a;')
	}
}
function ar_logAccessibilityIssue(severity, message, element = null, recommendation = '', wcagPrinciple = '', wcagGuideline = '', isAutofixed = false, wcagLevel = 'A') {
	let elId = 'global', elSig = '';
	if (element instanceof HTMLElement) {
		elId = element.id || element.dataset.arGeneratedId || (element.dataset.arGeneratedId = ar_generateUniqueElementId('el-tracked-'));
		if (wcagGuideline === '1.4.3 Contrast (Minimum)') {
			const style = window.getComputedStyle(element);
			const fg = style.color;
			const bg = ar_getEffectiveBackgroundColorOfElement(element).join(',');
			elSig = `::${ fg }-${ bg }`
		}
	}
	const baseMsgKey = message.substring(0, 40).replace(/\s+/g, '_').replace(/[^\w-]/g, '');
	let issueKey = `${ elId }::${ wcagGuideline || baseMsgKey }${ elSig }::${ severity }`;
	if (message.toLowerCase().includes('autofix attempt failed') && wcagGuideline === '1.4.3 Contrast (Minimum)') {
		const origKey = `${ elId }::${ wcagGuideline }${ elSig }::Critical`;
		if (ar_loggedIssuesTracker.has(origKey))
			return;
		issueKey = origKey
	}
	if (ar_loggedIssuesTracker.has(issueKey) && !isAutofixed)
		return;
	ar_loggedIssuesTracker.add(issueKey);
	ar_totalScannedIssuesCounter++;
	ar_accessibilityIssuesLog.push({
		id: `ar-issue-${ ar_totalScannedIssuesCounter }`,
		severity,
		message,
		element,
		recommendation,
		wcagPrinciple,
		wcagGuideline,
		isAutofixed,
		wcagLevel
	});
	const logMeta = ar_getLogMeta(severity, isAutofixed);
	console.groupCollapsed(`%c${ logMeta.p } %c${ message }`, `${ logMeta.s }font-weight:bold;padding:4px 8px;border-radius:4px 0 0 4px;`, 'font-weight:normal;padding:4px 8px;');
	ar_logIssueDetails(element, recommendation, wcagPrinciple, wcagGuideline, wcagLevel, isAutofixed, severity);
	console.groupEnd();
	if (isAutofixed)
		ar_totalAutoFixedIssuesCounter++
}
function ar_logSection(title) {
	console.groupCollapsed(`%cðŸ”Ž ${ title } %c`, 'background-color:#e8f0fe;color:#174ea6;font-weight:bold;padding:6px 12px;border-radius:5px;border:1px solid #d0d8e0;margin-bottom:5px;display:inline-block;', '')
}
function ar_escapeHtml(str) {
    if (typeof str !== "string") return str;
    return str
	.replace(/&/g, "&amp;")
	.replace(/</g, "&lt;")
	.replace(/>/g, "&gt;")
	.replace(/"/g, "&quot;")
	.replace(/'/g, "&#39;");
}
function ar_hasAriaLabel(el) {
	return el.getAttribute('aria-label') && el.getAttribute('aria-label').trim();
}
function ar_hasAriaLabelledby(el) {
	const labelledbyAttr = el.getAttribute('aria-labelledby');
	if (!labelledbyAttr)
		return false;
	return labelledbyAttr.split(/\s+/).some(id => {
		const lblEl = document.getElementById(id);
		return lblEl && (lblEl.textContent || '').trim();
	});
}
function ar_hasTextOrValue(el) {
	return (el.textContent || '').trim() || (el.value || '').trim();
}
function ar_hasImageWithAltInAnchor(el) {
	const img = el.querySelector('img[alt]');
	return img && (img.alt || '').trim();
}
function ar_hasImageAlt(el) {
	return (el.alt || '').trim();
}
function ar_hasFigcaption(el) {
	const figcaption = el.querySelector('figcaption');
	return figcaption && (figcaption.textContent || '').trim();
}
function ar_hasExplicitLabel(el) {
	if (!el.id)
		return false;
	const labels = document.querySelectorAll(`label[for="${ el.id }"]`);
	return Array.from(labels).some(lbl => (lbl.textContent || '').trim() || lbl.querySelector('img[alt]'));
}
function ar_hasParentLabel(el) {
	const parentLbl = el.closest('label');
	return parentLbl && (parentLbl.textContent || '').trim() && (!parentLbl.htmlFor || parentLbl.htmlFor === el.id);
}
function ar_hasTitleAttr(el) {
	return !!(el.getAttribute('title') && el.getAttribute('title').trim());
}
function ar_hasAccessibleNameForElement(element) {
	if (!element)
		return false;
	if (ar_hasAriaLabel(element) || ar_hasAriaLabelledby(element))
		return true;
	const tagName = element.tagName.toUpperCase();
	if ((tagName === 'BUTTON' || tagName === 'INPUT' && [
			'submit',
			'reset',
			'button'
		].includes(element.type)) && ar_hasTextOrValue(element))
		return true;
	if (tagName === 'A' && (ar_hasTextOrValue(element) || ar_hasImageWithAltInAnchor(element)))
		return true;
	if (tagName === 'IMG' && ar_hasImageAlt(element))
		return true;
	if (tagName === 'INPUT' && element.type === 'image' && ar_hasImageAlt(element))
		return true;
	if (tagName === 'FIGURE' && ar_hasFigcaption(element))
		return true;
	if ([
			'INPUT',
			'SELECT',
			'TEXTAREA'
		].includes(tagName) && (ar_hasExplicitLabel(element) || ar_hasParentLabel(element)))
		return true;
	return ar_hasTitleAttr(element);
}
function ar_setAttributeAndLog(el, attr, val, sev, msg, rec, princ, guide, level = 'A') {
	try {
		if (attr === 'textContent')
			el.textContent = val;
		else
			el.setAttribute(attr, val);
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1;
	} catch (e) {
		console.error(`setAttribute Error: ${ attr }=${ val } on`, el, e);
		return 0;
	}
}
function ar_removeAttributeAndLog(el, attr, sev, msg, rec, princ, guide, level = 'A') {
	try {
		el.removeAttribute(attr);
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1;
	} catch (e) {
		console.error(`removeAttribute Error: ${ attr } on`, el, e);
		return 0;
	}
}
function ar_applyStylesAndLog(el, styles, sev, msg, rec, princ, guide, level = 'A') {
	try {
		for (const prop in styles) {
			el.style.setProperty(prop, styles[prop]);
		}
		ar_logAccessibilityIssue(sev, msg, el, rec, princ, guide, true, level);
		return 1;
	} catch (e) {
		console.error('applyStyles Error:', el, styles, e);
		return 0;
	}
}
function ar_storeOriginalInlineStyle(element, cssProperty) {
	if (!ar_originalElementStylesMap.has(element)) {
		ar_originalElementStylesMap.set(element, {});
	}
	const elementOriginalStyles = ar_originalElementStylesMap.get(element);
	if (elementOriginalStyles[cssProperty] === undefined) {
		elementOriginalStyles[cssProperty] = element.style.getPropertyValue(cssProperty);
	}
}
function ar_restoreOriginalInlineStyle(element, cssProperty) {
	if (ar_originalElementStylesMap.has(element)) {
		const elementOriginalStyles = ar_originalElementStylesMap.get(element);
		if (elementOriginalStyles[cssProperty] !== undefined) {
			element.style.setProperty(cssProperty, elementOriginalStyles[cssProperty]);
		} else {
			element.style.removeProperty(cssProperty);
		}
	}
}
function ar_getElementsForMenuTextStyleAdjustments() {
	const menuElements = [
		document.getElementById('aaa-menu-button'),
		document.getElementById('aaa-menu-panel'),
		document.getElementById('aaa-page-structure-panel')
	].filter(Boolean);
	return Array.from(document.querySelectorAll(AR_SELECTOR_STRINGS.TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU)).filter(el => {
		return !menuElements.some(menuEl => menuEl.contains(el));
	});
}

var AR_AccessibilityMenu = AR_AccessibilityMenu || {};
(function (Menu) {
	const MENU_BUTTON_ID = 'aaa-menu-button';
	const MENU_PANEL_ID = 'aaa-menu-panel';
	const PAGE_STRUCTURE_PANEL_ID = 'aaa-page-structure-panel';
	const READING_MASK_TOP_ID = 'aaa-reading-mask-top';
	const READING_MASK_BOTTOM_ID = 'aaa-reading-mask-bottom';
	const READING_LINE_ID = 'aaa-reading-line';
	const FONT_SIZE_MULTIPLIER = 1.08;
	const STORAGE_KEY = 'AR_AccessibilityMenu_Settings';
	const EDGE_MARGIN_PX = 38;
	const CLASS_HIGH_CONTRAST = 'ar-aaa-high-contrast';
	const CLASS_INVERT_COLORS = 'ar-aaa-invert-colors';
	const CLASS_DARK_CONTRAST = 'ar-aaa-dark-contrast';
	const CLASS_HIGHLIGHT_LINKS = 'ar-aaa-highlight-links';
	const CLASS_ENHANCED_FOCUS = 'ar-aaa-enhanced-focus';
	const CLASS_ANIMATIONS_STOPPED = 'ar-aaa-animations-stopped';
	const CLASS_DYSLEXIA_FONT = 'ar-aaa-dyslexia-font';
	const CLASS_READING_MODE = 'ar-aaa-reading-mode';
	const CLASS_TEMP_HIGHLIGHT = 'ar-aaa-temp-highlight';
	const CLASS_TEXT_SCALED = 'ar-text-scaled-by-menu';
	const CLASS_LETTER_SPACING = 'ar-aaa-letter-spacing';
	const CLASS_WORD_SPACING = 'ar-aaa-word-spacing';
	const CLASS_LINE_HEIGHT = 'ar-aaa-line-height';
	const CLASS_LARGE_CURSOR = 'ar-aaa-large-cursor';
	const CLASS_MONOCHROME = 'ar-aaa-monochrome';
	const CLASS_LOW_SATURATION = 'ar-aaa-low-saturation';
	const CLASS_HIDE_IMAGES = 'ar-aaa-hide-images';
	const CLASS_HIGHLIGHT_HEADINGS = 'ar-aaa-highlight-headings';
	const CLASS_TOOLTIPS = 'ar-aaa-tooltips';
	const CLASS_TEXT_ALIGN_LEFT = 'ar-aaa-text-left';
	const CLASS_TEXT_ALIGN_CENTER = 'ar-aaa-text-center';
	const CLASS_TEXT_ALIGN_RIGHT = 'ar-aaa-text-right';
	Menu.isOpen = false;
	Menu.isDyslexiaFontActive = false;
	Menu.activeContrastMode = 'default';
	Menu.areLinksHighlighted = false;
	Menu.areHeadingsHighlighted = false;
	Menu.isFocusEnhanced = false;
	Menu.areAnimationsStopped = false;
	Menu.isReadingAloud = false;
	Menu.fontScaleLevel = 0;
	Menu.isReadingModeActive = false;
	Menu.isReadingMaskActive = false;
	Menu.isReadingLineActive = false;
	Menu.isStructurePanelOpen = false;
	Menu.isPanelDragging = false;
	Menu.isButtonDragging = false;
	Menu.buttonDragOccurred = false;
	Menu.buttonWasDragged = false;
	Menu.panelWasDragged = false;
	Menu.isLetterSpacingActive = false;
	Menu.isWordSpacingActive = false;
	Menu.isLineHeightActive = false;
	Menu.isLargeCursorActive = false;
	Menu.isMonochromeActive = false;
	Menu.isLowSaturationActive = false;
	Menu.isHideImagesActive = false;
	Menu.isTooltipsActive = false;
	Menu.textAlignment = 'default';
	Menu._originalFontSizes = new Map();
	Menu._initialButtonX = 0;
	Menu._initialButtonY = 0;
	Menu._initialPanelX = 0;
	Menu._initialPanelY = 0;
	Menu._initialMouseX = 0;
	Menu._initialMouseY = 0;
	Menu._panelRelativeOffsetX = 0;
	Menu._panelRelativeOffsetY = 0;
	Menu.readingMaskTop = null;
	Menu.readingMaskBottom = null;
	Menu.readingLine = null;
	Menu.pageStructurePanel = null;
	Menu.profiles = {
		'motor': {
			settings: {
				enhancedFocus: true,
				stopAnimations: true
			},
			labelKey: 'profileMotor',
			iconPath: '<path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"/>'
		},
		'adhd': {
			settings: {
				stopAnimations: true,
				readingMode: true,
				readingLine: true
			},
			labelKey: 'profileADHD',
			iconPath: '<path d="M11.5,6C8.46,6 5.83,7.43 4.42,9.59L2.93,8.1L1.87,9.16L3.87,11.16C3.67,11.46 3.5,11.72 3.5,12C3.5,12.28 3.67,12.54 3.87,12.84L1.87,14.84L2.93,15.9L4.42,14.41C5.83,16.57 8.46,18 11.5,18C14.54,18 17.17,16.57 18.58,14.41L20.07,15.9L21.13,14.84L19.13,12.84C19.33,12.54 19.5,12.28 19.5,12C19.5,11.72 19.33,11.46 19.13,11.16L21.13,9.16L20.07,8.1L18.58,9.59C17.17,7.43 14.54,6 11.5,6M11.5,8A4.5,4.5 0 0,1 16,12.5A4.5,4.5 0 0,1 11.5,17A4.5,4.5 0 0,1 7,12.5A4.5,4.5 0 0,1 11.5,8M11.5,10A2.5,2.5 0 0,0 9,12.5A2.5,2.5 0 0,0 11.5,15A2.5,2.5 0 0,0 14,12.5A2.5,2.5 0 0,0 11.5,10Z"/>'
		},
		'epileptic': {
			settings: { stopAnimations: true },
			labelKey: 'profileEpileptic',
			iconPath: '<path d="M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1Z"/>'
		},
		'vision': {
			settings: {
				fontScaleLevel: 2,
				highlightLinks: true,
				activeContrastMode: 'dark'
			},
			labelKey: 'profileVision',
			iconPath: '<path d="M12,4.5C7,4.5 2.73,7.61 1,12c1.73,4.39 6,7.5 11,7.5s9.27-3.11 11-7.5C21.27,7.61 17,4.5 12,4.5zM12,17a4.5,4.5 0 1,1 0-9 4.5,4.5 0 0,1 0,9zm0-7a2.5,2.5 0 0,0 0,5 2.5,2.5 0 0,0 0-5z"/>'
		}
	};
	Menu.translations = {
		'he': {
			menuTitle: '×›×œ×™ × ×’×™×©×•×ª',
			increaseText: '×”×’×“×œ ×˜×§×¡×˜',
			decreaseText: '×”×§×˜×Ÿ ×˜×§×¡×˜',
			highContrast: '× ×™×’×•×“×™×•×ª ×’×‘×•×”×” (×‘×”×™×¨)',
			invertColors: '×”×™×¤×•×š ×¦×‘×¢×™×',
			darkContrast: '× ×™×’×•×“×™×•×ª ×’×‘×•×”×” (×›×”×”)',
			highlightLinks: '×”×“×’×© ×§×™×©×•×¨×™×',
			enhancedFocus: '×ž×™×§×•×“ ×ž×©×•×¤×¨',
			stopAnimations: '×¢×¦×•×¨ ×× ×™×ž×¦×™×•×ª',
			dyslexiaFont: '×’×•×¤×Ÿ ×“×™×¡×œ×§×˜×™',
			readAloud: '×§×¨× ×‘×§×•×œ',
			readingMode: '×ž×¦×‘ ×§×¨×™××”',
			readingMask: '×ž×¡×›×ª ×§×¨×™××”',
			readingLine: '×§×• ×§×¨×™××”',
			pageStructure: '×ž×‘× ×” ×¢×ž×•×“',
			pageStructureTitle: '×ž×‘× ×” ×¢×ž×•×“',
			headings: '×›×•×ª×¨×•×ª',
			landmarks: '× ×§×•×“×•×ª ×¦×™×•×Ÿ',
			links: '×§×™×©×•×¨×™×',
			noItemsFound: '×œ× × ×ž×¦××• ×¤×¨×™×˜×™×.',
			profilesTitle: '×¤×¨×•×¤×™×œ×™ × ×’×™×©×•×ª',
			profileMotor: '×œ×§×•×™×•×ª ×ž×•×˜×•×¨×™×•×ª',
			profileADHD: '×”×¤×¨×¢×ª ×§×©×‘',
			profileEpileptic: '××¤×™×œ×¤×¡×™×”',
			profileVision: '×œ×§×•×ª ×¨××™×™×”',
			resetAll: '××™×¤×•×¡ ×”×›×œ',
			closeMenu: '×¡×’×•×¨ ×ª×¤×¨×™×˜',
			closeStructurePanel: '×¡×’×•×¨ ×ž×‘× ×” ×¢×ž×•×“',
			accessibilityIcon: '××™×™×§×•×Ÿ × ×’×™×©×•×ª',
			textSize: '×’×•×“×œ ×˜×§×¡×˜',
			contrast: '× ×™×’×•×“×™×•×ª',
			highlight: '×”×“×’×©×”',
			animation: '×× ×™×ž×¦×™×”',
			fontStyle: '×¡×’× ×•×Ÿ ×’×•×¤×Ÿ',
			reset: '××™×¤×•×¡',
			readAloudIcon: '××™×™×§×•×Ÿ ×§×¨×™××” ×‘×§×•×œ',
			readingModeIcon: '××™×™×§×•×Ÿ ×ž×¦×‘ ×§×¨×™××”',
			readingMaskIcon: '××™×™×§×•×Ÿ ×ž×¡×›×ª ×§×¨×™××”',
			readingLineIcon: '××™×™×§×•×Ÿ ×§×• ×§×¨×™××”',
			pageStructureIcon: '××™×™×§×•×Ÿ ×ž×‘× ×” ×¢×ž×•×“',
			profileIcon: '××™×™×§×•×Ÿ ×¤×¨×•×¤×™×œ',
			speechNotSupported: '×¡×™× ×ª×–×ª ×“×™×‘×•×¨ ××™× ×” × ×ª×ž×›×ª ×‘×“×¤×“×¤×Ÿ ×–×”.',
			mainContent: '×ª×•×›×Ÿ ×¨××©×™',
			navigation: '× ×™×•×•×˜',
			header: '×›×•×ª×¨×ª ×¢×œ×™×•× ×”',
			footer: '×›×•×ª×¨×ª ×ª×—×ª×•× ×”',
			complementary: '×ª×•×›×Ÿ ×ž×©×œ×™× (×¡×¨×’×œ ×¦×“)',
			form: '×˜×•×¤×¡',
			search: '×—×™×¤×•×©',
			region: '××–×•×¨',
			unlabeled: '×œ×œ× ×ª×•×•×™×ª',
			letterSpacing: '×¨×™×•×•×— ××•×ª×™×•×ª',
			wordSpacing: '×¨×™×•×•×— ×ž×™×œ×™×',
			lineHeight: '×’×•×‘×” ×©×•×¨×”',
			largeCursor: '×¡×ž×Ÿ ×’×“×•×œ',
			monochrome: '×ž×•× ×•×›×¨×•×',
			lowSaturation: '×¨×•×•×™×” × ×ž×•×›×”',
			hideImages: '×”×¡×ª×¨ ×ª×ž×•× ×•×ª',
			textSpacing: '×¨×™×•×•×— ×˜×§×¡×˜',
			cursorOptions: '××¤×©×¨×•×™×•×ª ×¡×ž×Ÿ',
			colorFilters: '×¤×™×œ×˜×¨×™ ×¦×‘×¢',
			highlightHeadings: '×”×“×’×© ×›×•×ª×¨×•×ª',
			textAlignLeft: '×™×™×©×•×¨ ×œ×©×ž××œ',
			textAlignCenter: '×™×™×©×•×¨ ×œ×ž×¨×›×–',
			textAlignRight: '×™×™×©×•×¨ ×œ×™×ž×™×Ÿ',
			tooltips: '×”×¦×’ ×¨×ž×–×™×',
			keyboardShortcuts: '×§×™×¦×•×¨×™ ×ž×§×œ×“×ª',
			screenReaderMode: '×ž×¦×‘ ×§×•×¨× ×ž×¡×š',
			printFriendly: '×™×“×™×“×•×ª×™ ×œ×”×“×¤×¡×”',
			textOptions: '××¤×©×¨×•×™×•×ª ×˜×§×¡×˜',
			visualOptions: '××¤×©×¨×•×™×•×ª ×—×–×•×ª×™×•×ª',
			readingOptions: '××¤×©×¨×•×™×•×ª ×§×¨×™××”',
			navigationOptions: '××¤×©×¨×•×™×•×ª × ×™×•×•×˜'
		},
		'en': {
			menuTitle: 'Accessibility Tools',
			increaseText: 'Increase Text',
			decreaseText: 'Decrease Text',
			highContrast: 'High Contrast (Light)',
			invertColors: 'Invert Colors',
			darkContrast: 'High Contrast (Dark)',
			highlightLinks: 'Highlight Links',
			enhancedFocus: 'Enhanced Focus',
			stopAnimations: 'Stop Animations',
			dyslexiaFont: 'Dyslexia Font',
			readAloud: 'Read Aloud',
			readingMode: 'Reading Mode',
			readingMask: 'Reading Mask',
			readingLine: 'Reading Line',
			pageStructure: 'Page Structure',
			pageStructureTitle: 'Page Structure',
			headings: 'Headings',
			landmarks: 'Landmarks',
			links: 'Links',
			noItemsFound: 'No items found.',
			profilesTitle: 'Accessibility Profiles',
			profileMotor: 'Motor Impairment',
			profileADHD: 'ADHD Focus',
			profileEpileptic: 'Epilepsy Safe',
			profileVision: 'Low Vision',
			resetAll: 'Reset All',
			closeMenu: 'Close Menu',
			closeStructurePanel: 'Close Structure Panel',
			accessibilityIcon: 'Accessibility Icon',
			textSize: 'Text Size',
			contrast: 'Contrast',
			highlight: 'Highlight',
			animation: 'Animation',
			fontStyle: 'Font Style',
			reset: 'Reset',
			readAloudIcon: 'Read Aloud Icon',
			readingModeIcon: 'Reading Mode Icon',
			readingMaskIcon: 'Reading Mask Icon',
			readingLineIcon: 'Reading Line Icon',
			pageStructureIcon: 'Page Structure Icon',
			profileIcon: 'Profile Icon',
			speechNotSupported: 'Speech synthesis not supported in this browser.',
			mainContent: 'Main Content',
			navigation: 'Navigation',
			header: 'Header',
			footer: 'Footer',
			complementary: 'Sidebar',
			form: 'Form',
			search: 'Search',
			region: 'Region',
			unlabeled: 'Unlabeled',
			letterSpacing: 'Letter Spacing',
			wordSpacing: 'Word Spacing',
			lineHeight: 'Line Height',
			largeCursor: 'Large Cursor',
			monochrome: 'Monochrome',
			lowSaturation: 'Low Saturation',
			hideImages: 'Hide Images',
			textSpacing: 'Text Spacing',
			cursorOptions: 'Cursor Options',
			colorFilters: 'Color Filters',
			highlightHeadings: 'Highlight Headings',
			textAlignLeft: 'Align Left',
			textAlignCenter: 'Align Center',
			textAlignRight: 'Align Right',
			tooltips: 'Show Tooltips',
			keyboardShortcuts: 'Keyboard Shortcuts',
			screenReaderMode: 'Screen Reader Mode',
			printFriendly: 'Print Friendly',
			textOptions: 'Text Options',
			visualOptions: 'Visual Options',
			readingOptions: 'Reading Options',
			navigationOptions: 'Navigation Options'
		}
	};
	Menu._getLocalizedString = function (key) {
		let lang = document.documentElement.lang || navigator.language || 'en';
		lang = lang.split('-')[0];
		if (Menu.translations[lang] && Menu.translations[lang][key]) {
			return Menu.translations[lang][key];
		}
		return Menu.translations['en'][key] || key;
	};
	function getClientCoords(event) {
		if (event.touches && event.touches.length > 0) {
			return {
				clientX: event.touches[0].clientX,
				clientY: event.touches[0].clientY
			};
		}
		return {
			clientX: event.clientX,
			clientY: event.clientY
		};
	}
	function logAction(message, isUserAction = false) {
		console.log(`[ARMenu] ${ message } ${ isUserAction ? '(User Action)' : '' }`);
	}
	function showCustomMessage(message) {
		const existingModal = document.getElementById('ar-aaa-message-modal');
		if (existingModal) {
			existingModal.remove();
		}
		const modal = document.createElement('div');
		modal.id = 'ar-aaa-message-modal';
		modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 2px solid black;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 2147483647;
            text-align: center;
            font-family: 'Inter', Arial, sans-serif;
            max-width: 90%;
            width: 300px;
        `;
		const messageText = document.createElement('p');
		messageText.textContent = message;
		messageText.style.marginBottom = '15px';
		messageText.style.color = 'black';
		const closeButton = document.createElement('button');
		closeButton.textContent = 'OK';
		closeButton.style.cssText = `
            padding: 8px 20px;
            background-color: #000000;
            color: #ffffff;
            border: 1px solid #000000;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            font-family: 'Inter', Arial, sans-serif;
        `;
		closeButton.addEventListener('click', () => modal.remove());
		modal.appendChild(messageText);
		modal.appendChild(closeButton);
		document.body.appendChild(modal);
		closeButton.focus();
	}
	Menu.init = function () {
		if (document.getElementById(MENU_BUTTON_ID)) {
			logAction('Already initialized.');
			return;
		}
		this._createMenuButton();
		if (typeof Menu.panel !== 'undefined' && typeof Menu.panel.createMenuPanel === 'function') {
			Menu.panel.createMenuPanel();
			Menu.panel.createReadingAidElements();
			Menu.panel.createPageStructurePanel();
			this._attachEventListeners();
		} else {
			console.error('ARMenu: panel.js not loaded or not properly initialized.');
			return;
		}
		this._loadSettings();
		logAction('Initialized successfully.');
	};
	Menu._createMenuButton = function () {
		const btn = document.createElement('button');
		btn.id = MENU_BUTTON_ID;
		btn.setAttribute('aria-label', this._getLocalizedString('menuTitle'));
		btn.setAttribute('aria-expanded', 'false');
		btn.setAttribute('aria-controls', MENU_PANEL_ID);
		const accessibilityIconSVG = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"/></svg>';
		btn.innerHTML = `<span class="ar-aaa-menu-icon" role="img" aria-label="${ this._getLocalizedString('accessibilityIcon') }">${ accessibilityIconSVG }</span>`;
		btn.style.right = '20px';
		btn.style.top = '50%';
		btn.style.transform = 'translateY(-50%)';
		btn.style.left = 'auto';
		btn.style.bottom = 'auto';
		document.body.appendChild(btn);
		btn.addEventListener('mousedown', this._handleButtonMouseDown.bind(this));
		btn.addEventListener('touchstart', this._handleButtonMouseDown.bind(this), { passive: false });
	};
	Menu._attachEventListeners = function () {
		const menuButton = document.getElementById(MENU_BUTTON_ID);
		const menuPanel = document.getElementById(MENU_PANEL_ID);
		if (menuButton) {
			menuButton.addEventListener('click', this._handleMenuButtonClick.bind(this));
			menuButton.addEventListener('touchend', this._handleMenuButtonClick.bind(this), { passive: false });
		}
		if (menuPanel) {
			menuPanel.addEventListener('click', this._handlePanelActionClick.bind(this));
			menuPanel.addEventListener('keydown', this._handlePanelKeydown.bind(this));
			menuPanel.addEventListener('mousedown', this._handlePanelMouseDown.bind(this));
			menuPanel.addEventListener('touchstart', this._handlePanelMouseDown.bind(this), { passive: false });
		}
		document.addEventListener('mousemove', this._handleDocumentMouseMove.bind(this));
		document.addEventListener('mousemove', this._handleReadingAidMouseMove.bind(this));
		document.addEventListener('mouseup', this._handleDocumentMouseUp.bind(this));
		document.addEventListener('touchmove', this._handleDocumentMouseMove.bind(this), { passive: false });
		document.addEventListener('touchend', this._handleDocumentMouseUp.bind(this));
		document.addEventListener('keydown', this._handleTabKeyFocusTrap.bind(this));
		window.addEventListener('resize', this._handleWindowResize.bind(this));
		document.addEventListener('DOMContentLoaded', () => {
			if (Menu.pageStructurePanel) {
				Menu.pageStructurePanel.addEventListener('keydown', this._handleStructurePanelKeydown.bind(this));
			}
		});
	};
	Menu._handleStructurePanelKeydown = function (event) {
		if (event.key === 'Escape' && Menu.isStructurePanelOpen) {
			this._togglePageStructurePanel(false);
		}
	};
	Menu._handleReadingAidMouseMove = function (event) {
		if (Menu.isReadingMaskActive && Menu.readingMaskTop && Menu.readingMaskBottom) {
			const mouseY = event.clientY;
			const maskHeight = 80;
			Menu.readingMaskTop.style.height = `${ mouseY - maskHeight / 2 }px`;
			Menu.readingMaskBottom.style.height = `${ window.innerHeight - (mouseY + maskHeight / 2) }px`;
		}
		if (Menu.isReadingLineActive && Menu.readingLine) {
			Menu.readingLine.style.top = `${ event.clientY }px`;
		}
	};
	Menu._handleWindowResize = function () {
		const button = document.getElementById(MENU_BUTTON_ID);
		const panel = document.getElementById(MENU_PANEL_ID);
		if (!button)
			return;
		if (Menu.buttonWasDragged) {
			const buttonWidth = button.offsetWidth;
			const buttonHeight = button.offsetHeight;
			let currentLeft = parseFloat(button.style.left);
			let currentTop = parseFloat(button.style.top);
			const newButtonX = Math.max(EDGE_MARGIN_PX, Math.min(currentLeft, window.innerWidth - buttonWidth - EDGE_MARGIN_PX));
			const newButtonY = Math.max(EDGE_MARGIN_PX, Math.min(currentTop, window.innerHeight - buttonHeight - EDGE_MARGIN_PX));
			if (parseFloat(button.style.left) !== newButtonX || parseFloat(button.style.top) !== newButtonY) {
				button.style.left = `${ newButtonX }px`;
				button.style.top = `${ newButtonY }px`;
			}
			if (this.isOpen && panel && Menu.panelWasDragged) {
				const panelWidth = panel.offsetWidth;
				const panelHeight = panel.offsetHeight;
				let panelNewLeft = newButtonX + Menu._panelRelativeOffsetX;
				let panelNewTop = newButtonY + Menu._panelRelativeOffsetY;
				panelNewLeft = Math.max(EDGE_MARGIN_PX, Math.min(panelNewLeft, window.innerWidth - panelWidth - EDGE_MARGIN_PX));
				panelNewTop = Math.max(EDGE_MARGIN_PX, Math.min(panelNewTop, window.innerHeight - panelHeight - EDGE_MARGIN_PX));
				panel.style.left = `${ panelNewLeft }px`;
				panel.style.top = `${ panelNewTop }px`;
				panel.style.right = 'auto';
				panel.style.bottom = 'auto';
				Menu._panelRelativeOffsetX = panelNewLeft - newButtonX;
				Menu._panelRelativeOffsetY = panelNewTop - newButtonY;
			} else if (this.isOpen && panel) {
				this._positionPanelRelativeToButton(button, panel);
			}
		} else if (this.isOpen && panel) {
			this._positionPanelRelativeToButton(button, panel);
		}
	};
    Menu._positionPanelRelativeToButton = function (button, panel) {
        if (!button || !panel) return;
    
        const buttonRect = button.getBoundingClientRect();
        const panelHeight = panel.offsetHeight;
        const panelWidth = panel.offsetWidth;
    
        const spaceAbove = buttonRect.top;
        const spaceBelow = window.innerHeight - buttonRect.bottom;
    
        let newTop;
    
        // Decide whether to place the panel above or below the button
        // Place it where there is more space, but prefer placing it above if space is ample.
        if (spaceAbove > panelHeight + 10 || spaceAbove > spaceBelow) {
            // Place above the button
            newTop = buttonRect.top - panelHeight - 10;
        } else {
            // Place below the button
            newTop = buttonRect.bottom + 10;
        }
    
        // Determine horizontal position based on document direction
        const docDir = document.documentElement.dir || window.getComputedStyle(document.documentElement).direction;
        let newLeft;
        if (docDir === 'rtl') {
            newLeft = buttonRect.right - panelWidth;
        } else {
            newLeft = buttonRect.left;
        }
    
        // Ensure the panel stays within all window boundaries
        newTop = Math.max(EDGE_MARGIN_PX, Math.min(newTop, window.innerHeight - panelHeight - EDGE_MARGIN_PX));
        newLeft = Math.max(EDGE_MARGIN_PX, Math.min(newLeft, window.innerWidth - panelWidth - EDGE_MARGIN_PX));
    
        // Apply final positions
        panel.style.top = `${newTop}px`;
        panel.style.left = `${newLeft}px`;
        panel.style.bottom = 'auto';
        panel.style.right = 'auto';
    
        // Update the relative offset for dragging logic
        Menu._panelRelativeOffsetX = newLeft - buttonRect.left;
        Menu._panelRelativeOffsetY = newTop - buttonRect.top;
    };
	Menu._handleMenuButtonClick = function (event) {
		if (Menu.buttonDragOccurred) {
			Menu.buttonDragOccurred = false;
			return;
		}
		this.toggleMenu();
	};
	Menu._handlePanelActionClick = function (event) {
		console.log('Menu panel click detected:', event.target);
		const targetButton = event.target.closest('button');
		if (targetButton && targetButton.dataset.action) {
			console.log('Action button clicked:', targetButton.dataset.action);
			try {
				this.handleAction(targetButton.dataset.action, targetButton);
			} catch (e) {
				console.error('Error handling menu action:', targetButton.dataset.action, e);
			}
		} else {
			console.log('Click did not originate from a button with a data-action attribute.');
		}
	};
	Menu._handlePanelKeydown = function (event) {
		if (event.key === 'Escape' && this.isOpen) {
			this.toggleMenu();
		}
	};
	Menu._handleTabKeyFocusTrap = function (event) {
		if (!this.isOpen && !Menu.isStructurePanelOpen)
			return;
		const activePanel = Menu.isStructurePanelOpen ? Menu.pageStructurePanel : document.getElementById(MENU_PANEL_ID);
		if (!activePanel)
			return;
		const focusableElements = Array.from(activePanel.querySelectorAll('button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"]):not([disabled])')).filter(el => el.offsetWidth > 0 || el.offsetHeight > 0 || el === document.activeElement);
		if (focusableElements.length === 0)
			return;
		const firstFocusableEl = focusableElements[0];
		const lastFocusableEl = focusableElements[focusableElements.length - 1];
		if (event.key === 'Tab') {
			if (event.shiftKey) {
				if (document.activeElement === firstFocusableEl) {
					lastFocusableEl.focus();
					event.preventDefault();
				}
			} else {
				if (document.activeElement === lastFocusableEl) {
					firstFocusableEl.focus();
					event.preventDefault();
				} else if (!focusableElements.includes(document.activeElement)) {
					firstFocusableEl.focus();
					event.preventDefault();
				}
			}
		}
	};
	Menu._startDragging = function (event, isButtonDrag) {
		const button = document.getElementById(MENU_BUTTON_ID);
		const panel = document.getElementById(MENU_PANEL_ID);
		if (!button || !panel)
			return;
		let draggedElement = isButtonDrag ? button : panel;
		if (!isButtonDrag) {
			const target = event.target;
			if (target.closest('button')) {
				this.isPanelDragging = false;
				return;
			}
			const isPanelItself = target === panel;
			const isPanelTitle = target === panel.querySelector('h3');
			if (!isPanelItself && !isPanelTitle) {
				this.isPanelDragging = false;
				return;
			}
		}
		this.isButtonDragging = isButtonDrag;
		this.isPanelDragging = !isButtonDrag;
		if (isButtonDrag) {
			Menu.buttonDragOccurred = false;
			Menu.buttonWasDragged = true;
		} else {
			Menu.panelWasDragged = true;
		}
		draggedElement.classList.add('dragging');
		const coords = getClientCoords(event);
		const buttonRect = button.getBoundingClientRect();
		const panelRect = panel.getBoundingClientRect();
		Menu._initialButtonX = buttonRect.left;
		Menu._initialButtonY = buttonRect.top;
		Menu._initialPanelX = panelRect.left;
		Menu._initialPanelY = panelRect.top;
		Menu._initialMouseX = coords.clientX;
		Menu._initialMouseY = coords.clientY;
		if (isButtonDrag && button.style.transform !== 'none') {
			button.style.transform = 'none';
		}
		if (Menu.isOpen) {
			Menu._panelRelativeOffsetX = panelRect.left - buttonRect.left;
			Menu._panelRelativeOffsetY = panelRect.top - buttonRect.top;
		} else {
			const estimatedPanelHeight = panel.offsetHeight || 300;
			const estimatedPanelWidth = panel.offsetWidth || 320;
			const docDir = document.documentElement.dir || window.getComputedStyle(document.documentElement).direction;
			if (docDir === 'rtl') {
				Menu._panelRelativeOffsetX = buttonRect.width - estimatedPanelWidth;
			} else {
				Menu._panelRelativeOffsetX = 0;
			}
			Menu._panelRelativeOffsetY = -estimatedPanelHeight - 10;
		}
		if (event.type === 'touchstart') {
			event.preventDefault();
		}
	};
	Menu._handleButtonMouseDown = function (event) {
		Menu.buttonDragOccurred = false;
		this._startDragging(event, true);
	};
	Menu._handlePanelMouseDown = function (event) {
		this._startDragging(event, false);
	};
    Menu._handleDocumentMouseMove = function(event) {
        if (!this.isButtonDragging && !this.isPanelDragging) return;
    
        const button = document.getElementById(MENU_BUTTON_ID);
        const panel = document.getElementById(MENU_PANEL_ID);
        if (!button || !panel) return;
    
        event.preventDefault();
    
        const coords = getClientCoords(event);
        const deltaX = coords.clientX - Menu._initialMouseX;
        const deltaY = coords.clientY - Menu._initialMouseY;
    
        if (this.isButtonDragging) {
            const isDesktop = document.body.classList.contains("desktop");
            if (isDesktop || (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
                Menu.buttonDragOccurred = true;
            }
        }
    
        const buttonRect = button.getBoundingClientRect();
        let newButtonX, newButtonY;
    
        if (this.isOpen) {
            // LOGIC FOR WHEN MENU IS OPEN (moves button and panel together)
            const panelHeight = Menu._panelHeight || panel.offsetHeight;
            const panelWidth = Menu._panelWidth || panel.offsetWidth;
            let newPanelX, newPanelY;
    
            if (this.isButtonDragging) {
                newButtonX = Menu._initialButtonX + deltaX;
                newButtonY = Menu._initialButtonY + deltaY;
                newPanelX = newButtonX + Menu._panelRelativeOffsetX;
                newPanelY = newButtonY + Menu._panelRelativeOffsetY;
    
                const clampedPanelX = Math.max(EDGE_MARGIN_PX, Math.min(newPanelX, window.innerWidth - panelWidth - EDGE_MARGIN_PX));
                const clampedPanelY = Math.max(EDGE_MARGIN_PX, Math.min(newPanelY, window.innerHeight - panelHeight - EDGE_MARGIN_PX));
    
                if (clampedPanelX !== newPanelX) newButtonX = clampedPanelX - Menu._panelRelativeOffsetX;
                if (clampedPanelY !== newPanelY) newButtonY = clampedPanelY - Menu._panelRelativeOffsetY;
    
                newPanelX = clampedPanelX;
                newPanelY = clampedPanelY;
    
            } else { // isPanelDragging
                newPanelX = Menu._initialPanelX + deltaX;
                newPanelY = Menu._initialPanelY + deltaY;
    
                newPanelX = Math.max(EDGE_MARGIN_PX, Math.min(newPanelX, window.innerWidth - panelWidth - EDGE_MARGIN_PX));
                newPanelY = Math.max(EDGE_MARGIN_PX, Math.min(newPanelY, window.innerHeight - panelHeight - EDGE_MARGIN_PX));
    
                newButtonX = newPanelX - Menu._panelRelativeOffsetX;
                newButtonY = newPanelY - Menu._panelRelativeOffsetY;
            }
    
            // Apply panel position and update offset
            panel.style.left = `${newPanelX}px`;
            panel.style.top = `${newPanelY}px`;
            panel.style.right = 'auto';
            panel.style.bottom = 'auto';
            Menu._panelRelativeOffsetX = newPanelX - newButtonX;
            Menu._panelRelativeOffsetY = newPanelY - newButtonY;
    
        } else {
            // SIMPLIFIED LOGIC FOR WHEN MENU IS CLOSED (moves button only)
            newButtonX = Menu._initialButtonX + deltaX;
            newButtonY = Menu._initialButtonY + deltaY;
        }
    
        // Always constrain the button's final position
        newButtonX = Math.max(EDGE_MARGIN_PX, Math.min(newButtonX, window.innerWidth - buttonRect.width - EDGE_MARGIN_PX));
        newButtonY = Math.max(EDGE_MARGIN_PX, Math.min(newButtonY, window.innerHeight - buttonRect.height - EDGE_MARGIN_PX));
    
        // Apply button position
        button.style.left = `${newButtonX}px`;
        button.style.top = `${newButtonY}px`;
        button.style.transform = 'none';
        button.style.right = 'auto';
        button.style.bottom = 'auto';
    };
	Menu._handleDocumentMouseUp = function () {
		let settingsChanged = false;
		if (this.isButtonDragging) {
			this.isButtonDragging = false;
			const button = document.getElementById(MENU_BUTTON_ID);
			if (button)
				button.classList.remove('dragging');
			settingsChanged = true;
		}
		if (this.isPanelDragging) {
			this.isPanelDragging = false;
			const panel = document.getElementById(MENU_PANEL_ID);
			if (panel)
				panel.classList.remove('dragging');
			settingsChanged = true;
		}
		if (settingsChanged) {
			this._saveSettings();
		}
	};
	Menu.toggleMenu = function () {
        const panel = document.getElementById(MENU_PANEL_ID);
        const button = document.getElementById(MENU_BUTTON_ID);
        if (!panel || !button) return;
    
        this.isOpen = !this.isOpen;
        panel.style.display = this.isOpen ? 'block' : 'none';
        panel.classList.toggle('ar-aaa-menu-open', this.isOpen);
        panel.setAttribute('aria-hidden', String(!this.isOpen));
        button.setAttribute('aria-expanded', String(this.isOpen));
    
        if (this.isOpen) {
            // ADDED: Store the panel's true dimensions when it's visible
            Menu._panelHeight = panel.offsetHeight;
            Menu._panelWidth = panel.offsetWidth;
    
            if (!Menu.panelWasDragged || !panel.style.left || !panel.style.top) {
                this._positionPanelRelativeToButton(button, panel);
            }
            const firstFocusableButton = panel.querySelector('button:not([disabled])');
            if (firstFocusableButton) {
                firstFocusableButton.focus();
            }
        } else {
            button.focus();
        }
        logAction(`Menu ${this.isOpen ? 'opened' : 'closed'}`);
        this._saveSettings();
    };
	Menu.handleAction = function (action, targetButton) {
		logAction(`Action: ${ action }`, true);
		if (action === 'close-menu') {
			this.toggleMenu();
			return;
		}
		if (action === 'close-structure-panel') {
			this._togglePageStructurePanel(false);
			return;
		}
		if (action.startsWith('profile-')) {
			const profileName = action.substring('profile-'.length);
			this._applyProfile(profileName);
			this._saveSettings();
			return;
		}
		switch (action) {
		case 'increase-text':
		case 'decrease-text':
			this._handleTextSizeAction(action, targetButton);
			break;
		case 'contrast-high':
		case 'contrast-invert':
		case 'contrast-dark':
			this._handleContrastAction(action, targetButton);
			break;
		case 'highlight-links':
		case 'enhanced-focus':
		case 'highlight-headings':
			this._handleHighlightAction(action, targetButton);
			break;
		case 'read-aloud':
			this._handleReadAloudAction(targetButton);
			break;
		case 'reading-mode':
			this._handleReadingModeAction(targetButton);
			break;
		case 'reading-mask':
			this._handleReadingMaskAction(targetButton);
			break;
		case 'reading-line':
			this._handleReadingLineAction(targetButton);
			break;
		case 'stop-animations':
			this._handleStopAnimationsAction(targetButton);
			break;
		case 'toggle-dyslexia-font':
			this._handleDyslexiaFontAction(targetButton);
			break;
		case 'letter-spacing':
			this._handleLetterSpacingAction(targetButton);
			break;
		case 'word-spacing':
			this._handleWordSpacingAction(targetButton);
			break;
		case 'line-height':
			this._handleLineHeightAction(targetButton);
			break;
		case 'large-cursor':
			this._handleLargeCursorAction(targetButton);
			break;
		case 'monochrome':
			this._handleMonochromeAction(targetButton);
			break;
		case 'low-saturation':
			this._handleLowSaturationAction(targetButton);
			break;
		case 'hide-images':
			this._handleHideImagesAction(targetButton);
			break;
		case 'tooltips':
			this._handleTooltipsAction(targetButton);
			break;
		case 'reset-all':
			this._resetAllSettings();
			break;
		}
		if (action !== 'read-aloud') {
			this._saveSettings();
		}
	};
	Menu._togglePageStructurePanel = function (forceShow) {
		if (!Menu.pageStructurePanel)
			return;
		Menu.isStructurePanelOpen = forceShow !== undefined ? forceShow : !Menu.isStructurePanelOpen;
		Menu.pageStructurePanel.style.display = Menu.isStructurePanelOpen ? 'block' : 'none';
		Menu.pageStructurePanel.setAttribute('aria-hidden', String(!Menu.isStructurePanelOpen));
		if (Menu.isStructurePanelOpen) {
			if (typeof Menu.panel !== 'undefined' && typeof Menu.panel.populatePageStructurePanel === 'function') {
				Menu.panel.populatePageStructurePanel(null);
			}
			const firstFocusable = Menu.pageStructurePanel.querySelector('button, [href]');
			if (firstFocusable)
				firstFocusable.focus();
		} else {
			const menuButton = document.getElementById(MENU_BUTTON_ID);
			if (menuButton && Menu.isOpen) {
				const mainPanelFirstButton = document.getElementById(MENU_PANEL_ID) && document.getElementById(MENU_PANEL_ID).querySelector('button');
				if (mainPanelFirstButton)
					mainPanelFirstButton.focus();
				else
					menuButton.focus();
			} else if (menuButton) {
				menuButton.focus();
			}
		}
	};
	Menu._applyProfile = function (profileName) {
		const profile = Menu.profiles[profileName];
		if (!profile) {
			logAction(`Profile "${ profileName }" not found.`);
			return;
		}
		logAction(`Applying profile: ${ profileName }`);
		this._resetAllSettings(true);
		const panel = document.getElementById(MENU_PANEL_ID);
		if (!panel)
			return;
		if (profile.settings.fontScaleLevel !== undefined) {
			Menu.fontScaleLevel = profile.settings.fontScaleLevel;
			this._applyFontScaleToElements();
		}
		if (profile.settings.activeContrastMode) {
			panel.querySelectorAll('button[data-action^="contrast-"]').forEach(btn => {
				this._updateButtonActiveState(btn, false);
			});
			const contrastButton = panel.querySelector(`button[data-action="contrast-${ profile.settings.activeContrastMode }"]`);
			if (contrastButton)
				this._handleContrastAction(`contrast-${ profile.settings.activeContrastMode }`, contrastButton);
		}
		if (profile.settings.highlightLinks) {
			const hlButton = panel.querySelector('button[data-action="highlight-links"]');
			if (hlButton && !Menu.areLinksHighlighted)
				this._handleHighlightAction('highlight-links', hlButton);
		}
		if (profile.settings.enhancedFocus) {
			const efButton = panel.querySelector('button[data-action="enhanced-focus"]');
			if (efButton && !Menu.isFocusEnhanced)
				this._handleHighlightAction('enhanced-focus', efButton);
		}
		if (profile.settings.stopAnimations) {
			const saButton = panel.querySelector('button[data-action="stop-animations"]');
			if (saButton) {
				Menu.areAnimationsStopped = false;
				this._handleStopAnimationsAction(saButton);
			}
		}
		if (profile.settings.dyslexiaFont) {
			const dfButton = panel.querySelector('button[data-action="toggle-dyslexia-font"]');
			if (dfButton && !Menu.isDyslexiaFontActive)
				this._handleDyslexiaFontAction(dfButton);
		}
		if (profile.settings.readingMode) {
			const rmButton = panel.querySelector('button[data-action="reading-mode"]');
			if (rmButton && !Menu.isReadingModeActive)
				this._handleReadingModeAction(rmButton);
		}
		if (profile.settings.readingMask) {
			const rmaskButton = panel.querySelector('button[data-action="reading-mask"]');
			if (rmaskButton && !Menu.isReadingMaskActive)
				this._handleReadingMaskAction(rmaskButton);
		}
		if (profile.settings.readingLine) {
			const rlineButton = panel.querySelector('button[data-action="reading-line"]');
			if (rlineButton && !Menu.isReadingLineActive)
				this._handleReadingLineAction(rlineButton);
		}
	};
	Menu._updateButtonActiveState = function (buttonElement, isActive) {
		if (!buttonElement)
			return;
		const action = buttonElement.dataset.action;
		if (action && action.startsWith('contrast-')) {
			const parentGroup = buttonElement.closest('.ar-aaa-button-row') || buttonElement.closest('.ar-aaa-menu-group');
			if (parentGroup) {
				parentGroup.querySelectorAll('button[data-action^="contrast-"]').forEach(btn => {
					btn.classList.remove('ar-aaa-menu-btn-active');
				});
			}
			if (isActive) {
				buttonElement.classList.add('ar-aaa-menu-btn-active');
			}
		} else {
			buttonElement.classList.toggle('ar-aaa-menu-btn-active', isActive);
		}
	};
	Menu._applyFontScaleToElements = function () {
		let elements = [];
		if (typeof window.ar_getElementsForMenuTextStyleAdjustments === 'function') {
			elements = window.ar_getElementsForMenuTextStyleAdjustments();
		}
		if (!elements || elements.length === 0) {
			elements = Array.from(document.querySelectorAll('html > body :is(p, li, span, div:not(#' + MENU_PANEL_ID + ', #' + MENU_BUTTON_ID + ', [class*="icon"]),' + 'h1, h2, h3, h4, h5, h6, a, label, td, th, caption, strong, em, b, i, small, big, sub, sup):not(:has(p, li, span, div, h1, h2, h3, h4, h5, h6, a, label, td, th, caption, strong, em, b, i, small, big, sub, sup))')).filter(el => el.closest(`#${ MENU_PANEL_ID }`) === null && el.closest(`#${ MENU_BUTTON_ID }`) === null);
		}
		elements.forEach(el => {
			if (!document.body.contains(el))
				return;
			if (!Menu._originalFontSizes.has(el)) {
				const initialComputedPx = parseFloat(window.getComputedStyle(el).fontSize);
				Menu._originalFontSizes.set(el, {
					inline: el.style.fontSize || '',
					initialPx: initialComputedPx
				});
			}
			const sizeData = Menu._originalFontSizes.get(el);
			let newSize = sizeData.initialPx * Math.pow(FONT_SIZE_MULTIPLIER, Menu.fontScaleLevel);
			if (newSize < 8)
				newSize = 8;
			if (newSize > 72)
				newSize = 72;
			el.classList.add(CLASS_TEXT_SCALED);
			el.style.setProperty('--ar-scaled-font-size', newSize + 'px');
		});
	};
	Menu._handleTextSizeAction = function (action, button) {
		if (action === 'increase-text') {
			Menu.fontScaleLevel++;
		} else if (action === 'decrease-text') {
			Menu.fontScaleLevel--;
		}
		this._applyFontScaleToElements();
	};
	Menu._handleContrastAction = function (action, button) {
		const htmlEl = document.documentElement;
		const bodyEl = document.body;
		const isHighContrastAction = action === 'contrast-high';
		const isInvertColorsAction = action === 'contrast-invert';
		const isDarkContrastAction = action === 'contrast-dark';
		let newMode = 'default';
		if (isHighContrastAction) {
			newMode = this.activeContrastMode === 'high' ? 'default' : 'high';
		} else if (isInvertColorsAction) {
			newMode = this.activeContrastMode === 'inverted' ? 'default' : 'inverted';
		} else if (isDarkContrastAction) {
			newMode = this.activeContrastMode === 'dark' ? 'default' : 'dark';
		}
		htmlEl.classList.remove(CLASS_INVERT_COLORS);
		bodyEl.classList.remove(CLASS_HIGH_CONTRAST, CLASS_DARK_CONTRAST);
		const parentGroup = button.closest('.ar-aaa-button-row') || button.closest('.ar-aaa-menu-group');
		if (parentGroup) {
			parentGroup.querySelectorAll('button[data-action^="contrast-"]').forEach(btn => {
				this._updateButtonActiveState(btn, false);
			});
		}
		if (newMode === 'high') {
			bodyEl.classList.add(CLASS_HIGH_CONTRAST);
			this._updateButtonActiveState(button, true);
		} else if (newMode === 'inverted') {
			htmlEl.classList.add(CLASS_INVERT_COLORS);
			this._updateButtonActiveState(button, true);
		} else if (newMode === 'dark') {
			bodyEl.classList.add(CLASS_DARK_CONTRAST);
			this._updateButtonActiveState(button, true);
		}
		this.activeContrastMode = newMode;
		logAction(`Contrast mode set to: ${ this.activeContrastMode }`);
	};
	Menu._handleHighlightAction = function (action, button) {
		const body = document.body;
		if (action === 'highlight-links') {
			this.areLinksHighlighted = !this.areLinksHighlighted;
			body.classList.toggle(CLASS_HIGHLIGHT_LINKS, this.areLinksHighlighted);
			this._updateButtonActiveState(button, this.areLinksHighlighted);
			logAction(`Highlight links ${ this.areLinksHighlighted ? 'enabled' : 'disabled' }. Class on body: ${ body.classList.contains(CLASS_HIGHLIGHT_LINKS) }`);
		} else if (action === 'enhanced-focus') {
			this.isFocusEnhanced = !this.isFocusEnhanced;
			body.classList.toggle(CLASS_ENHANCED_FOCUS, this.isFocusEnhanced);
			this._updateButtonActiveState(button, this.isFocusEnhanced);
			logAction(`Enhanced focus ${ this.isFocusEnhanced ? 'enabled' : 'disabled' }. Class on body: ${ body.classList.contains(CLASS_ENHANCED_FOCUS) }`);
		} else if (action === 'highlight-headings') {
			this.areHeadingsHighlighted = !this.areHeadingsHighlighted;
			body.classList.toggle(CLASS_HIGHLIGHT_HEADINGS, this.areHeadingsHighlighted);
			this._updateButtonActiveState(button, this.areHeadingsHighlighted);
			logAction(`Highlight headings ${ this.areHeadingsHighlighted ? 'enabled' : 'disabled' }. Class on body: ${ body.classList.contains(CLASS_HIGHLIGHT_HEADINGS) }`);
		}
	};
	Menu._handleReadAloudAction = function (button) {
		if (!('speechSynthesis' in window)) {
			showCustomMessage(this._getLocalizedString('speechNotSupported'));
			button.disabled = true;
			return;
		}
		if (Menu.isReadingAloud) {
			window.speechSynthesis.cancel();
			Menu.isReadingAloud = false;
			this._updateButtonActiveState(button, false);
			logAction('Speech cancelled by user', true);
			return;
		}
		let textToRead = '';
		const selectedText = window.getSelection().toString().trim();
		if (selectedText) {
			textToRead = selectedText;
			logAction('Reading selected text.');
		} else {
			const mainContent = document.querySelector('main');
			if (mainContent) {
				textToRead = mainContent.innerText;
			} else {
				const bodyClone = document.body.cloneNode(true);
				bodyClone.querySelectorAll('script, style, noscript, #' + MENU_BUTTON_ID + ', #' + MENU_PANEL_ID).forEach(el => el.remove());
				textToRead = bodyClone.innerText;
			}
			logAction('Reading main content or body fallback.');
		}
		if (textToRead.trim() === '') {
			logAction('No text found to read.');
			return;
		}
		window.speechSynthesis.cancel();
		const utterance = new SpeechSynthesisUtterance(textToRead);
		const docLang = document.documentElement.lang || 'en';
		utterance.lang = docLang;
		utterance.onstart = () => {
			Menu.isReadingAloud = true;
			this._updateButtonActiveState(button, true);
			logAction('Speech started');
		};
		utterance.onend = () => {
			Menu.isReadingAloud = false;
			this._updateButtonActiveState(button, false);
			logAction('Speech finished');
		};
		utterance.onerror = event => {
			Menu.isReadingAloud = false;
			this._updateButtonActiveState(button, false);
			console.error('Speech synthesis error:', event.error);
			logAction('Speech error');
		};
		window.speechSynthesis.speak(utterance);
	};
	Menu._handleReadingModeAction = function (button) {
		Menu.isReadingModeActive = !Menu.isReadingModeActive;
		document.body.classList.toggle(CLASS_READING_MODE, Menu.isReadingModeActive);
		this._updateButtonActiveState(button, Menu.isReadingModeActive);
		logAction('Reading mode ' + (Menu.isReadingModeActive ? 'enabled' : 'disabled'), true);
		//this._togglePageStructurePanel(Menu.isReadingModeActive);
	};
	Menu._handleReadingMaskAction = function (button) {
		Menu.isReadingMaskActive = !Menu.isReadingMaskActive;
		if (Menu.readingMaskTop && Menu.readingMaskBottom) {
			Menu.readingMaskTop.style.display = Menu.isReadingMaskActive ? 'block' : 'none';
			Menu.readingMaskBottom.style.display = Menu.isReadingMaskActive ? 'block' : 'none';
		}
		this._updateButtonActiveState(button, Menu.isReadingMaskActive);
		logAction('Reading mask ' + (Menu.isReadingMaskActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleReadingLineAction = function (button) {
		Menu.isReadingLineActive = !Menu.isReadingLineActive;
		if (Menu.readingLine) {
			Menu.readingLine.style.display = Menu.isReadingLineActive ? 'block' : 'none';
		}
		this._updateButtonActiveState(button, Menu.isReadingLineActive);
		logAction('Reading line ' + (Menu.isReadingLineActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleStopAnimationsAction = function (button) {
		this.areAnimationsStopped = !this.areAnimationsStopped;
		document.body.classList.toggle(CLASS_ANIMATIONS_STOPPED, this.areAnimationsStopped);
		this._updateButtonActiveState(button, this.areAnimationsStopped);
		if (this.areAnimationsStopped) {
			const gifsToFreeze = Array.from(document.querySelectorAll('img[src*=".gif"]:not([data-ar-gif-frozen="true"])')).filter(img => {
				try {
					return new URL(img.src, window.location.href).pathname.toLowerCase().endsWith('.gif');
				} catch (e) {
					return (img.src || '').toLowerCase().includes('.gif');
				}
			});
			gifsToFreeze.forEach(img => {
				if (typeof window.ar_isVisuallyHidden === 'function' && window.ar_isVisuallyHidden(img))
					return;
				img.dataset.arOriginalSrc = img.src;
				img.dataset.arOriginalAlt = img.alt || '';
				img.dataset.arOriginalDisplay = img.style.display || '';
				img.dataset.arOriginalWidth = img.offsetWidth + 'px';
				img.dataset.arOriginalHeight = img.offsetHeight + 'px';
				const tempImage = new Image();
				tempImage.crossOrigin = 'Anonymous';
				tempImage.onload = () => {
					const canvas = document.createElement('canvas');
					canvas.width = tempImage.naturalWidth || parseInt(img.dataset.arOriginalWidth) || img.width || 50;
					canvas.height = tempImage.naturalHeight || parseInt(img.dataset.arOriginalHeight) || img.height || 50;
					canvas.className = img.className;
					canvas.style.cssText = img.style.cssText;
					canvas.style.width = img.dataset.arOriginalWidth;
					canvas.style.height = img.dataset.arOriginalHeight;
					if (window.getComputedStyle(img).display === 'inline') {
						canvas.style.display = 'inline-block';
					} else {
						canvas.style.display = img.dataset.arOriginalDisplay || 'block';
					}
					canvas.setAttribute('role', 'img');
					canvas.setAttribute('aria-label', img.dataset.arOriginalAlt || `Frozen animation: ${ img.src.split('/').pop() }`);
					canvas.dataset.arFrozenGifCanvas = 'true';
					if (!img.id) {
						img.id = typeof window.ar_generateUniqueElementId === 'function' ? window.ar_generateUniqueElementId('ar-original-gif-') : `ar-gif-${ Date.now() }-${ Math.random().toString(36).substr(2, 5) }`;
					}
					canvas.dataset.arOriginalImgId = img.id;
					const ctx = canvas.getContext('2d');
					try {
						ctx.drawImage(tempImage, 0, 0, canvas.width, canvas.height);
						img.style.display = 'none';
						img.dataset.arGifFrozen = 'true';
						if (img.parentNode) {
							img.parentNode.insertBefore(canvas, img.nextSibling);
						}
					} catch (e) {
						console.error('ARMenu: Failed to draw GIF to canvas. Freezing by replacing src.', e);
						img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
						img.style.display = img.dataset.arOriginalDisplay || '';
						img.dataset.arGifFrozen = 'true';
						img.dataset.arGifFrozenFallback = 'true';
					}
				};
				tempImage.onerror = () => {
					console.error('ARMenu: Failed to load GIF for freezing. Replacing src.');
					img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
					img.dataset.arGifFrozen = 'true';
					img.dataset.arGifFrozenFallback = 'true';
				};
				tempImage.src = img.dataset.arOriginalSrc;
			});
		} else {
			document.querySelectorAll('canvas[data-ar-frozen-gif-canvas="true"]').forEach(canvas => {
				const originalImgId = canvas.dataset.arOriginalImgId;
				if (originalImgId) {
					const originalImg = document.getElementById(originalImgId);
					if (originalImg) {
						originalImg.style.display = originalImg.dataset.arOriginalDisplay || '';
						[
							'arGifFrozen',
							'arOriginalSrc',
							'arOriginalAlt',
							'arOriginalDisplay',
							'arOriginalWidth',
							'arOriginalHeight',
							'arGifFrozenFallback'
						].forEach(attr => delete originalImg.dataset[attr]);
					}
				}
				if (canvas.parentNode) {
					canvas.parentNode.removeChild(canvas);
				}
			});
			document.querySelectorAll('img[data-ar-gif-frozen-fallback="true"]').forEach(img => {
				if (img.dataset.arOriginalSrc) {
					img.src = img.dataset.arOriginalSrc;
				}
				[
					'arGifFrozen',
					'arGifFrozenFallback',
					'arOriginalSrc',
					'arOriginalAlt',
					'arOriginalDisplay',
					'arOriginalWidth',
					'arOriginalHeight'
				].forEach(attr => delete img.dataset[attr]);
			});
		}
	};
	Menu._handleDyslexiaFontAction = function (button) {
		this.isDyslexiaFontActive = !this.isDyslexiaFontActive;
		document.body.classList.toggle(CLASS_DYSLEXIA_FONT, this.isDyslexiaFontActive);
		this._updateButtonActiveState(button, this.isDyslexiaFontActive);
	};
	Menu._handleLetterSpacingAction = function (button) {
		this.isLetterSpacingActive = !this.isLetterSpacingActive;
		document.body.classList.toggle(CLASS_LETTER_SPACING, this.isLetterSpacingActive);
		this._updateButtonActiveState(button, this.isLetterSpacingActive);
		logAction('Letter spacing ' + (this.isLetterSpacingActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleWordSpacingAction = function (button) {
		this.isWordSpacingActive = !this.isWordSpacingActive;
		document.body.classList.toggle(CLASS_WORD_SPACING, this.isWordSpacingActive);
		this._updateButtonActiveState(button, this.isWordSpacingActive);
		logAction('Word spacing ' + (this.isWordSpacingActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleLineHeightAction = function (button) {
		this.isLineHeightActive = !this.isLineHeightActive;
		document.body.classList.toggle(CLASS_LINE_HEIGHT, this.isLineHeightActive);
		this._updateButtonActiveState(button, this.isLineHeightActive);
		logAction('Line height ' + (this.isLineHeightActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleLargeCursorAction = function (button) {
		this.isLargeCursorActive = !this.isLargeCursorActive;
		document.body.classList.toggle(CLASS_LARGE_CURSOR, this.isLargeCursorActive);
		this._updateButtonActiveState(button, this.isLargeCursorActive);
		logAction('Large cursor ' + (this.isLargeCursorActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleMonochromeAction = function (button) {
		this.isMonochromeActive = !this.isMonochromeActive;
		// Turn off low saturation if monochrome is activated
		if (this.isMonochromeActive && this.isLowSaturationActive) {
			this.isLowSaturationActive = false;
			document.body.classList.remove(CLASS_LOW_SATURATION);
			const lowSatButton = document.querySelector(`#${MENU_PANEL_ID} button[data-action="low-saturation"]`);
			if (lowSatButton) this._updateButtonActiveState(lowSatButton, false);
		}
		document.body.classList.toggle(CLASS_MONOCHROME, this.isMonochromeActive);
		this._updateButtonActiveState(button, this.isMonochromeActive);
		logAction('Monochrome ' + (this.isMonochromeActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleLowSaturationAction = function (button) {
		this.isLowSaturationActive = !this.isLowSaturationActive;
		// Turn off monochrome if low saturation is activated
		if (this.isLowSaturationActive && this.isMonochromeActive) {
			this.isMonochromeActive = false;
			document.body.classList.remove(CLASS_MONOCHROME);
			const monoButton = document.querySelector(`#${MENU_PANEL_ID} button[data-action="monochrome"]`);
			if (monoButton) this._updateButtonActiveState(monoButton, false);
		}
		document.body.classList.toggle(CLASS_LOW_SATURATION, this.isLowSaturationActive);
		this._updateButtonActiveState(button, this.isLowSaturationActive);
		logAction('Low saturation ' + (this.isLowSaturationActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleHideImagesAction = function (button) {
		this.isHideImagesActive = !this.isHideImagesActive;
		document.body.classList.toggle(CLASS_HIDE_IMAGES, this.isHideImagesActive);
		this._updateButtonActiveState(button, this.isHideImagesActive);
		logAction('Hide images ' + (this.isHideImagesActive ? 'enabled' : 'disabled'), true);
	};
	Menu._handleTooltipsAction = function (button) {
		this.isTooltipsActive = !this.isTooltipsActive;
		document.body.classList.toggle(CLASS_TOOLTIPS, this.isTooltipsActive);
		this._updateButtonActiveState(button, this.isTooltipsActive);
		logAction('Tooltips ' + (this.isTooltipsActive ? 'enabled' : 'disabled'), true);
	};
	Menu._resetAllSettings = function (calledByProfile = false) {
		Menu.fontScaleLevel = 0;
		document.querySelectorAll('.' + CLASS_TEXT_SCALED).forEach(el => {
			el.classList.remove(CLASS_TEXT_SCALED);
			el.style.removeProperty('--ar-scaled-font-size');
			if (Menu._originalFontSizes.has(el)) {
				const sizeState = Menu._originalFontSizes.get(el);
				if (sizeState.inline) {
					el.style.fontSize = sizeState.inline;
				} else {
					el.style.removeProperty('font-size');
				}
			} else {
				el.style.removeProperty('font-size');
			}
		});
		Menu._originalFontSizes.clear();
		if (Menu.isReadingAloud && 'speechSynthesis' in window) {
			window.speechSynthesis.cancel();
		}
		Menu.isReadingAloud = false;
		Menu.isReadingModeActive = false;
		Menu.isReadingMaskActive = false;
		Menu.isReadingLineActive = false;
		this.activeContrastMode = 'default';
		this.areLinksHighlighted = false;
		this.isFocusEnhanced = false;
		this.areAnimationsStopped = false;
		this.isDyslexiaFontActive = false;
		this.isLetterSpacingActive = false;
		this.isWordSpacingActive = false;
		this.isLineHeightActive = false;
		this.isLargeCursorActive = false;
		this.isMonochromeActive = false;
		this.isLowSaturationActive = false;
		this.isHideImagesActive = false;
		this.isTooltipsActive = false;
		this.areHeadingsHighlighted = false;
		this.textAlignment = 'default';
		document.documentElement.classList.remove(CLASS_INVERT_COLORS);
		document.body.classList.remove(CLASS_HIGH_CONTRAST, CLASS_DARK_CONTRAST, CLASS_HIGHLIGHT_LINKS, CLASS_ENHANCED_FOCUS, CLASS_ANIMATIONS_STOPPED, CLASS_DYSLEXIA_FONT, CLASS_READING_MODE, CLASS_LETTER_SPACING, CLASS_WORD_SPACING, CLASS_LINE_HEIGHT, CLASS_LARGE_CURSOR, CLASS_MONOCHROME, CLASS_LOW_SATURATION, CLASS_HIDE_IMAGES, CLASS_HIGHLIGHT_HEADINGS, CLASS_TOOLTIPS, CLASS_TEXT_ALIGN_LEFT, CLASS_TEXT_ALIGN_CENTER, CLASS_TEXT_ALIGN_RIGHT);
		if (Menu.readingMaskTop)
			Menu.readingMaskTop.style.display = 'none';
		if (Menu.readingMaskBottom)
			Menu.readingMaskBottom.style.display = 'none';
		if (Menu.readingLine)
			Menu.readingLine.style.display = 'none';
		if (Menu.isStructurePanelOpen) {
			//this._togglePageStructurePanel(false);
		}
		const panel = document.getElementById(MENU_PANEL_ID);
		if (panel) {
			panel.querySelectorAll('button[data-action]').forEach(btn => {
				this._updateButtonActiveState(btn, false);
			});
		}
		if (!calledByProfile) {
			logAction('All settings reset.');
			this._saveSettings();
		}
	};
	Menu._saveSettings = function () {
		const button = document.getElementById(MENU_BUTTON_ID);
		const panel = document.getElementById(MENU_PANEL_ID);
		let buttonPosition = {
			left: button ? button.style.left : null,
			top: button ? button.style.top : null,
			right: button ? button.style.right : null,
			bottom: button ? button.style.bottom : null,
			transform: button ? button.style.transform : null,
			wasDragged: Menu.buttonWasDragged
		};
		let panelPosition = null;
		if (Menu.isOpen && panel && Menu.panelWasDragged) {
			panelPosition = {
				left: panel.style.left,
				top: panel.style.top
			};
		}
		const settings = {
			activeContrastMode: Menu.activeContrastMode,
			areLinksHighlighted: Menu.areLinksHighlighted,
			areHeadingsHighlighted: Menu.areHeadingsHighlighted,
			isFocusEnhanced: Menu.isFocusEnhanced,
			areAnimationsStopped: Menu.areAnimationsStopped,
			isDyslexiaFontActive: Menu.isDyslexiaFontActive,
			fontScaleLevel: Menu.fontScaleLevel,
			isOpen: Menu.isOpen,
			buttonPosition: buttonPosition,
			panelPosition: panelPosition,
			panelWasDragged: Menu.panelWasDragged,
			isReadingModeActive: Menu.isReadingModeActive,
			isReadingMaskActive: Menu.isReadingMaskActive,
			isReadingLineActive: Menu.isReadingLineActive,
			isLetterSpacingActive: Menu.isLetterSpacingActive,
			isWordSpacingActive: Menu.isWordSpacingActive,
			isLineHeightActive: Menu.isLineHeightActive,
			isLargeCursorActive: Menu.isLargeCursorActive,
			isMonochromeActive: Menu.isMonochromeActive,
			isLowSaturationActive: Menu.isLowSaturationActive,
			isHideImagesActive: Menu.isHideImagesActive,
			isTooltipsActive: Menu.isTooltipsActive,
			textAlignment: Menu.textAlignment
		};
		try {
			localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
			logAction('Settings saved.');
		} catch (e) {
			console.error('Error saving settings to localStorage:', e);
		}
	};
	Menu._loadSettings = function () {
		try {
			const savedSettingsJSON = localStorage.getItem(STORAGE_KEY);
			if (!savedSettingsJSON) {
				logAction('No saved settings found.');
				return;
			}
			const savedSettings = JSON.parse(savedSettingsJSON);
			if (!savedSettings) {
				logAction('Saved settings are invalid. Using defaults.');
				localStorage.removeItem(STORAGE_KEY);
				return;
			}
			logAction('Loading saved settings.');
			Menu.activeContrastMode = savedSettings.activeContrastMode || 'default';
			if (Menu.activeContrastMode === 'high')
				document.body.classList.add(CLASS_HIGH_CONTRAST);
			else if (Menu.activeContrastMode === 'dark')
				document.body.classList.add(CLASS_DARK_CONTRAST);
			else if (Menu.activeContrastMode === 'inverted')
				document.documentElement.classList.add(CLASS_INVERT_COLORS);
			Menu.areLinksHighlighted = savedSettings.areLinksHighlighted || false;
			if (Menu.areLinksHighlighted)
				document.body.classList.add(CLASS_HIGHLIGHT_LINKS);
			Menu.isFocusEnhanced = savedSettings.isFocusEnhanced || false;
			if (Menu.isFocusEnhanced)
				document.body.classList.add(CLASS_ENHANCED_FOCUS);
			if (savedSettings.areAnimationsStopped) {
				const stopAnimButton = document.querySelector(`#${ MENU_PANEL_ID } button[data-action="stop-animations"]`);
				if (stopAnimButton) {
					Menu.areAnimationsStopped = false;
					this._handleStopAnimationsAction(stopAnimButton);
				}
			}
			Menu.isDyslexiaFontActive = savedSettings.isDyslexiaFontActive || false;
			if (Menu.isDyslexiaFontActive)
				document.body.classList.add(CLASS_DYSLEXIA_FONT);
			Menu.fontScaleLevel = savedSettings.fontScaleLevel || 0;
			if (Menu.fontScaleLevel !== 0) {
				this._applyFontScaleToElements();
			}
			Menu.isReadingModeActive = savedSettings.isReadingModeActive || false;
			if (Menu.isReadingModeActive)
				document.body.classList.add(CLASS_READING_MODE);
			Menu.isReadingMaskActive = savedSettings.isReadingMaskActive || false;
			if (Menu.isReadingMaskActive && Menu.readingMaskTop && Menu.readingMaskBottom) {
				Menu.readingMaskTop.style.display = 'block';
				Menu.readingMaskBottom.style.display = 'block';
			}
			Menu.isReadingLineActive = savedSettings.isReadingLineActive || false;
			if (Menu.isReadingLineActive && Menu.readingLine) {
				Menu.readingLine.style.display = 'block';
			}
			Menu.isLetterSpacingActive = savedSettings.isLetterSpacingActive || false;
			if (Menu.isLetterSpacingActive)
				document.body.classList.add(CLASS_LETTER_SPACING);
			Menu.isWordSpacingActive = savedSettings.isWordSpacingActive || false;
			if (Menu.isWordSpacingActive)
				document.body.classList.add(CLASS_WORD_SPACING);
			Menu.isLineHeightActive = savedSettings.isLineHeightActive || false;
			if (Menu.isLineHeightActive)
				document.body.classList.add(CLASS_LINE_HEIGHT);
			Menu.isLargeCursorActive = savedSettings.isLargeCursorActive || false;
			if (Menu.isLargeCursorActive)
				document.body.classList.add(CLASS_LARGE_CURSOR);
			Menu.isMonochromeActive = savedSettings.isMonochromeActive || false;
			if (Menu.isMonochromeActive)
				document.body.classList.add(CLASS_MONOCHROME);
			Menu.isLowSaturationActive = savedSettings.isLowSaturationActive || false;
			if (Menu.isLowSaturationActive)
				document.body.classList.add(CLASS_LOW_SATURATION);
			Menu.isHideImagesActive = savedSettings.isHideImagesActive || false;
			if (Menu.isHideImagesActive)
				document.body.classList.add(CLASS_HIDE_IMAGES);
			Menu.isTooltipsActive = savedSettings.isTooltipsActive || false;
			if (Menu.isTooltipsActive)
				document.body.classList.add(CLASS_TOOLTIPS);
			Menu.areHeadingsHighlighted = savedSettings.areHeadingsHighlighted || false;
			if (Menu.areHeadingsHighlighted)
				document.body.classList.add(CLASS_HIGHLIGHT_HEADINGS);
			const button = document.getElementById(MENU_BUTTON_ID);
			if (button && savedSettings.buttonPosition) {
				Menu.buttonWasDragged = savedSettings.buttonPosition.wasDragged || false;
				if (Menu.buttonWasDragged && savedSettings.buttonPosition.left && savedSettings.buttonPosition.top) {
					button.style.left = savedSettings.buttonPosition.left;
					button.style.top = savedSettings.buttonPosition.top;
					button.style.right = 'auto';
					button.style.bottom = 'auto';
					button.style.transform = 'none';
				} else if (savedSettings.buttonPosition.right && savedSettings.buttonPosition.top && savedSettings.buttonPosition.transform) {
					button.style.right = savedSettings.buttonPosition.right;
					button.style.top = savedSettings.buttonPosition.top;
					button.style.transform = savedSettings.buttonPosition.transform;
					button.style.left = 'auto';
					button.style.bottom = 'auto';
				}
			}
			const panel = document.getElementById(MENU_PANEL_ID);
			if (panel) {
				this._updateButtonActiveState(panel.querySelector('[data-action="contrast-high"]'), Menu.activeContrastMode === 'high');
				this._updateButtonActiveState(panel.querySelector('[data-action="contrast-invert"]'), Menu.activeContrastMode === 'inverted');
				this._updateButtonActiveState(panel.querySelector('[data-action="contrast-dark"]'), Menu.activeContrastMode === 'dark');
				this._updateButtonActiveState(panel.querySelector('[data-action="highlight-links"]'), Menu.areLinksHighlighted);
				this._updateButtonActiveState(panel.querySelector('[data-action="enhanced-focus"]'), Menu.isFocusEnhanced);
				this._updateButtonActiveState(panel.querySelector('[data-action="stop-animations"]'), Menu.areAnimationsStopped);
				this._updateButtonActiveState(panel.querySelector('[data-action="toggle-dyslexia-font"]'), Menu.isDyslexiaFontActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="reading-mode"]'), Menu.isReadingModeActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="reading-mask"]'), Menu.isReadingMaskActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="reading-line"]'), Menu.isReadingLineActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="letter-spacing"]'), Menu.isLetterSpacingActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="word-spacing"]'), Menu.isWordSpacingActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="line-height"]'), Menu.isLineHeightActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="large-cursor"]'), Menu.isLargeCursorActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="monochrome"]'), Menu.isMonochromeActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="low-saturation"]'), Menu.isLowSaturationActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="hide-images"]'), Menu.isHideImagesActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="tooltips"]'), Menu.isTooltipsActive);
				this._updateButtonActiveState(panel.querySelector('[data-action="highlight-headings"]'), Menu.areHeadingsHighlighted);
			}
			Menu.panelWasDragged = savedSettings.panelWasDragged || false;
			if (savedSettings.isOpen) {
				Menu.isOpen = false;
				this.toggleMenu();
				if (panel && Menu.panelWasDragged && savedSettings.panelPosition && savedSettings.panelPosition.left && savedSettings.panelPosition.top) {
					panel.style.left = savedSettings.panelPosition.left;
					panel.style.top = savedSettings.panelPosition.top;
					panel.style.right = 'auto';
					panel.style.bottom = 'auto';
					if (button) {
						const panelRect = panel.getBoundingClientRect();
						const buttonRect = button.getBoundingClientRect();
						Menu._panelRelativeOffsetX = panelRect.left - buttonRect.left;
						Menu._panelRelativeOffsetY = panelRect.top - buttonRect.top;
					}
				}
			}
			this._handleWindowResize();
			if (Menu.isReadingModeActive) {
				//this._togglePageStructurePanel(true);
			}
		} catch (e) {
			console.error('Error loading settings from localStorage:', e);
			localStorage.removeItem(STORAGE_KEY);
		}
	};
  	function isAccessibilityMenuElement(el) {
		return el.closest(`#${ MENU_BUTTON_ID }`) || el.closest(`#${ MENU_PANEL_ID }`) || el.closest(`#${ PAGE_STRUCTURE_PANEL_ID }`);
	}
	if (typeof Menu._getLocalizedString === 'undefined') {
		console.error('ARMenu: _getLocalizedString is not defined. Ensure action.js is loaded before panel.js.');
		Menu._getLocalizedString = key => key;
	}
	Menu.panel = Menu.panel || {};
	Menu.panel.createMenuPanel = function () {
		const panel = document.createElement('div');
		panel.id = MENU_PANEL_ID;
		panel.setAttribute('role', 'dialog');
		panel.setAttribute('aria-modal', 'true');
		panel.setAttribute('aria-labelledby', 'ar-aaa-menu-title');
		panel.style.display = 'none';
		panel.innerHTML = Menu.panel.getMenuPanelHTML();
		document.body.appendChild(panel);
	};
	Menu.panel.createReadingAidElements = function () {
		Menu.readingMaskTop = document.createElement('div');
		Menu.readingMaskTop.className = READING_MASK_TOP_ID;
		document.body.appendChild(Menu.readingMaskTop);
		Menu.readingMaskBottom = document.createElement('div');
		Menu.readingMaskBottom.className = READING_MASK_BOTTOM_ID;
		document.body.appendChild(Menu.readingMaskBottom);
		Menu.readingLine = document.createElement('div');
		Menu.readingLine.className = READING_LINE_ID;
		document.body.appendChild(Menu.readingLine);
	};
	Menu.panel.createPageStructurePanel = function () {
		Menu.pageStructurePanel = document.createElement('div');
		Menu.pageStructurePanel.id = PAGE_STRUCTURE_PANEL_ID;
		Menu.pageStructurePanel.setAttribute('role', 'dialog');
		Menu.pageStructurePanel.setAttribute('aria-modal', 'false');
		Menu.pageStructurePanel.setAttribute('aria-labelledby', 'ar-aaa-structure-title');
		Menu.pageStructurePanel.style.display = 'none';
		Menu.pageStructurePanel.classList.add('ar-aaa-page-structure-panel');
		let panelHTML = `<h3 id="ar-aaa-structure-title">${ Menu._getLocalizedString('pageStructureTitle') }</h3>`;
		panelHTML += `<div class="ar-structure-category" id="ar-aaa-structure-headings"><h4>${ Menu._getLocalizedString('headings') }</h4><ul></ul></div>`;
		panelHTML += `<div class="ar-structure-category" id="ar-aaa-structure-landmarks"><h4>${ Menu._getLocalizedString('landmarks') }</h4><ul></ul></div>`;
		panelHTML += `<div class="ar-structure-category" id="ar-aaa-structure-links"><h4>${ Menu._getLocalizedString('links') }</h4><ul></ul></div>`;
		panelHTML += `<button class="ar-aaa-structure-close-btn" data-action="close-structure-panel">${ Menu._getLocalizedString('closeStructurePanel') }</button>`;
		Menu.pageStructurePanel.innerHTML = panelHTML;
		document.body.appendChild(Menu.pageStructurePanel);
		Menu.pageStructurePanel.querySelector('.ar-aaa-structure-close-btn').addEventListener('click', () => {
			Menu._togglePageStructurePanel(false);
			if (Menu.isReadingModeActive) {
				document.body.classList.remove('ar-aaa-reading-mode');
				Menu.isReadingModeActive = false;
				const rmButton = document.querySelector(`#${ MENU_PANEL_ID } button[data-action="reading-mode"]`);
				if (rmButton)
					Menu._updateButtonActiveState(rmButton, false);
			}
		});
		Menu.pageStructurePanel.addEventListener('keydown', event => {
			if (event.key === 'Escape') {
				Menu._togglePageStructurePanel(false);
				if (Menu.isReadingModeActive) {
					document.body.classList.remove('ar-aaa-reading-mode');
					Menu.isReadingModeActive = false;
					const rmButton = document.querySelector(`#${ MENU_PANEL_ID } button[data-action="reading-mode"]`);
					if (rmButton)
						Menu._updateButtonActiveState(rmButton, false);
				}
			}
		});
	};
	Menu.panel._getIconSVG = function (pathData, label = '') {
		return `<span class="ar-aaa-menu-icon" role="img" aria-label="${ label }"><svg viewBox="0 0 24 24">${ pathData }</svg></span>`;
	};
	Menu.panel.getMenuPanelHTML = function () {
		const ICONS = {
			textSize: Menu.panel._getIconSVG('<path d="M2.5,4V7H7.5V19H10.5V7H15.5V4M10.5,10.5H13.5V13.5H10.5V10.5Z"/>', Menu._getLocalizedString('textSize')),
			contrast: Menu.panel._getIconSVG('<path d="M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6V18M20,15L19.3,14C19.5,13.4 19.6,12.7 19.6,12C19.6,11.3 19.5,10.6 19.3,10L20,9L17.3,4L16.7,5C15.9,4.3 14.9,3.8 13.8,3.5L13.5,2H10.5L10.2,3.5C9.1,3.8 8.1,4.3 7.3,5L6.7,4L4,9L4.7,10C4.5,10.6 4.4,11.3 4.4,12C4.4,12.7 4.5,13.4 4.7,14L4,15L6.7,20L7.3,19C8.1,19.7 9.1,20.2 10.2,20.5L10.5,22H13.5L13.8,20.5C14.9,20.2 15.9,19.7 16.7,19L17.3,20L20,15Z"/>', Menu._getLocalizedString('contrast')),
			highlight: Menu.panel._getIconSVG('<path d="M16.2,12L12,16.2L7.8,12L12,7.8M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4Z"/>', Menu._getLocalizedString('highlight')),
			readAloud: Menu.panel._getIconSVG('<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>', Menu._getLocalizedString('readAloudIcon')),
			readingMode: Menu.panel._getIconSVG('<path d="M5 5v14h14V5H5zm8 12H7v-2h6v2zm4-4H7v-2h10v2zm0-4H7V7h10v2z"/>', Menu._getLocalizedString('readingModeIcon')),
			readingMask: Menu.panel._getIconSVG('<path d="M11.5,6C8.46,6 5.83,7.43 4.42,9.59L2.93,8.1L1.87,9.16L3.87,11.16C3.67,11.46 3.5,11.72 3.5,12C3.5,12.28 3.67,12.54 3.87,12.84L1.87,14.84L2.93,15.9L4.42,14.41C5.83,16.57 8.46,18 11.5,18C14.54,18 17.17,16.57 18.58,14.41L20.07,15.9L21.13,14.84L19.13,12.84C19.33,12.54 19.5,12.28 19.5,12C19.5,11.72 19.33,11.46 19.13,11.16L21.13,9.16L20.07,8.1L18.58,9.59C17.17,7.43 14.54,6 11.5,6M11.5,8A4.5,4.5 0 0,1 16,12.5A4.5,4.5 0 0,1 11.5,17A4.5,4.5 0 0,1 7,12.5A4.5,4.5 0 0,1 11.5,8M11.5,10A2.5,2.5 0 0,0 9,12.5A2.5,2.5 0 0,0 11.5,15A2.5,2.5 0 0,0 14,12.5A2.5,2.5 0 0,0 11.5,10Z"/>', Menu._getLocalizedString('readingMaskIcon')),
			readingLine: Menu.panel._getIconSVG('<path d="M19 13H5v-2h14v2z"/>', Menu._getLocalizedString('readingLineIcon')),
			pageStructure: Menu.panel._getIconSVG('<path d="M3,3H9V7H3V3M15,3H21V7H15V3M3,10H9V14H3V10M15,10H21V14H15V10M3,17H9V21H3V17M15,17H21V21H15V17Z"/>', Menu._getLocalizedString('pageStructureIcon')),
			animation: Menu.panel._getIconSVG('<path d="M8,5V19L19,12L8,5Z"/>', Menu._getLocalizedString('animation')),
			fontStyle: Menu.panel._getIconSVG('<path d="M9.25,4V5.5H6.75V4H5.25V5.5H2.75V4H1.25V14.5H2.75V16H5.25V14.5H7.75V16H10.25V14.5H11.75V4H9.25M17.75,4V14.5H19.25V16H21.75V14.5H24.25V4H21.75V5.5H19.25V4H17.75M10.25,7H7.75V13H10.25V7M16.25,7H13.75V13H16.25V7Z"/>', Menu._getLocalizedString('fontStyle')),
			reset: Menu.panel._getIconSVG('<path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/>', Menu._getLocalizedString('reset')),
			close: Menu.panel._getIconSVG('<path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>', Menu._getLocalizedString('closeMenu')),
			letterSpacing: Menu.panel._getIconSVG('<path d="M22,10V12H19.85C19.5,16 16.5,19 12.5,19.4V22H10.5V19.4C6.5,19 3.5,16 3.15,12H1V10H3.15C3.5,6 6.5,3 10.5,2.6V0H12.5V2.6C16.5,3 19.5,6 19.85,10H22M5.17,10H7.5V12H5.17C5.5,14.9 7.6,17 10.5,17.33V15H12.5V17.33C15.4,17 17.5,14.9 17.83,12H15.5V10H17.83C17.5,7.1 15.4,5 12.5,4.67V7H10.5V4.67C7.6,5 5.5,7.1 5.17,10Z"/>', Menu._getLocalizedString('letterSpacing')),
			wordSpacing: Menu.panel._getIconSVG('<path d="M3,5H9V11H3V5M5,7V9H7V7H5M11,7H21V9H11V7M11,15H21V17H11V15M3,13H9V19H3V13M5,15V17H7V15H5Z"/>', Menu._getLocalizedString('wordSpacing')),
			lineHeight: Menu.panel._getIconSVG('<path d="M10,13H22V11H10M10,19H22V17H10M10,7H22V5H10M6,7H8.5L5,3.5L1.5,7H4V17H1.5L5,20.5L8.5,17H6V7Z"/>', Menu._getLocalizedString('lineHeight')),
			cursor: Menu.panel._getIconSVG('<path d="M13.64,21.97C13.14,22.21 12.54,22 12.31,21.5L10.13,16.76L7.62,18.78C7.45,18.92 7.24,19 7,19A1,1 0 0,1 6,18V3A1,1 0 0,1 7,2C7.24,2 7.47,2.09 7.64,2.23L7.65,2.22L19.14,11.86C19.57,12.22 19.62,12.85 19.27,13.27C19.12,13.45 18.91,13.57 18.7,13.61L15.54,14.23L17.74,18.96C18,19.46 17.76,20.05 17.26,20.28L13.64,21.97Z"/>', Menu._getLocalizedString('largeCursor')),
			monochrome: Menu.panel._getIconSVG('<path d="M17.66,7.93L12,2.27L6.34,7.93C3.22,11.05 3.22,16.12 6.34,19.24C7.9,20.8 9.95,21.58 12,21.58C14.05,21.58 16.1,20.8 17.66,19.24C20.78,16.12 20.78,11.05 17.66,7.93M12,19.59C10.07,19.59 8.14,18.89 6.69,17.43C3.83,14.57 3.83,9.86 6.69,7L12,1.69V19.59Z"/>', Menu._getLocalizedString('monochrome')),
			saturation: Menu.panel._getIconSVG('<path d="M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M12,19A7,7 0 0,1 5,12A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15Z"/>', Menu._getLocalizedString('lowSaturation')),
			hideImages: Menu.panel._getIconSVG('<path d="M21,5H3A2,2 0 0,0 1,7V17A2,2 0 0,0 3,19H21A2,2 0 0,0 23,17V7A2,2 0 0,0 21,5M21,17H3V7H21M15,13L12.5,15.5L10.5,14L7,17H17L15,13M8,10A1.5,1.5 0 0,1 9.5,11.5A1.5,1.5 0 0,1 8,13A1.5,1.5 0 0,1 6.5,11.5A1.5,1.5 0 0,1 8,10M2.39,1.73L1.11,3L3,4.89V7H1V17A2,2 0 0,0 3,19H19.11L20.84,20.73L22.11,19.46L2.39,1.73Z"/>', Menu._getLocalizedString('hideImages')),
			headingHighlight: Menu.panel._getIconSVG('<path d="M3,4H5V10H9V4H11V18H9V12H5V18H3V4M13,8H15.31L15.63,5H17.63L17.31,8H19.31L19.04,10H17.04L16.72,13H18.72L18.45,15H16.45L16.13,18H14.13L14.45,15H12.45L12.13,18H10.13L10.45,15H8.45L8.72,13H10.72L11.04,10H9.04L9.31,8H11.31L11.63,5H13.63L13.31,8M14.18,13L14.5,10H12.5L12.18,13H14.18Z"/>', Menu._getLocalizedString('highlightHeadings')),
			tooltips: Menu.panel._getIconSVG('<path d="M11,18H13V16H11V18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,6A4,4 0 0,0 8,10H10A2,2 0 0,1 12,8A2,2 0 0,1 14,10C14,12 11,11.75 11,15H13C13,12.75 16,12.5 16,10A4,4 0 0,0 12,6Z"/>', Menu._getLocalizedString('tooltips'))
		};
		let html = `<h3 id="ar-aaa-menu-title">${ Menu._getLocalizedString('menuTitle') }</h3>`;
		
		// Quick Profiles Section
		html += `<div class="ar-aaa-menu-group">
			<div class="ar-aaa-menu-section-header">${ Menu._getLocalizedString('profilesTitle') }</div>
			<div class="ar-aaa-button-row">`;
		for (const profileKey in Menu.profiles) {
			const profile = Menu.profiles[profileKey];
			html += `<button data-action="profile-${ profileKey }">${ Menu.panel._getIconSVG(profile.iconPath, Menu._getLocalizedString('profileIcon')) } ${ Menu._getLocalizedString(profile.labelKey) }</button>`;
		}
		html += `</div></div>`;
		
		// Text Size Section
		html += `<div class="ar-aaa-menu-group">
			<div class="ar-aaa-menu-section-header">${ Menu._getLocalizedString('textOptions') }</div>
			<div class="ar-aaa-button-row">
				<button data-action="increase-text">${ ICONS.textSize } ${ Menu._getLocalizedString('increaseText') }</button>
				<button data-action="decrease-text">${ ICONS.textSize } ${ Menu._getLocalizedString('decreaseText') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="letter-spacing">${ ICONS.letterSpacing } ${ Menu._getLocalizedString('letterSpacing') }</button>
				<button data-action="word-spacing">${ ICONS.wordSpacing } ${ Menu._getLocalizedString('wordSpacing') }</button>
				<button data-action="line-height">${ ICONS.lineHeight } ${ Menu._getLocalizedString('lineHeight') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="toggle-dyslexia-font" class="ar-aaa-fullwidth-btn">${ ICONS.fontStyle } ${ Menu._getLocalizedString('dyslexiaFont') }</button>
			</div>
		</div>`;
		
		// Visual Options Section
		html += `<div class="ar-aaa-menu-group">
			<div class="ar-aaa-menu-section-header">${ Menu._getLocalizedString('visualOptions') }</div>
			<div class="ar-aaa-button-row">
				<button data-action="contrast-high">${ ICONS.contrast } ${ Menu._getLocalizedString('highContrast') }</button>
				<button data-action="contrast-invert">${ ICONS.contrast } ${ Menu._getLocalizedString('invertColors') }</button>
				<button data-action="contrast-dark">${ ICONS.contrast } ${ Menu._getLocalizedString('darkContrast') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="monochrome">${ ICONS.monochrome } ${ Menu._getLocalizedString('monochrome') }</button>
				<button data-action="low-saturation">${ ICONS.saturation } ${ Menu._getLocalizedString('lowSaturation') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="highlight-links">${ ICONS.highlight } ${ Menu._getLocalizedString('highlightLinks') }</button>
				<button data-action="highlight-headings">${ ICONS.headingHighlight } ${ Menu._getLocalizedString('highlightHeadings') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="hide-images">${ ICONS.hideImages } ${ Menu._getLocalizedString('hideImages') }</button>
				<button data-action="tooltips">${ ICONS.tooltips } ${ Menu._getLocalizedString('tooltips') }</button>
			</div>
		</div>`;
		
		// Navigation & Focus Section
		html += `<div class="ar-aaa-menu-group">
			<div class="ar-aaa-menu-section-header">${ Menu._getLocalizedString('navigationOptions') }</div>
			<div class="ar-aaa-button-row">
				<button data-action="enhanced-focus">${ ICONS.highlight } ${ Menu._getLocalizedString('enhancedFocus') }</button>
				<button data-action="large-cursor">${ ICONS.cursor } ${ Menu._getLocalizedString('largeCursor') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="stop-animations" class="ar-aaa-fullwidth-btn">${ ICONS.animation } ${ Menu._getLocalizedString('stopAnimations') }</button>
			</div>
		</div>`;
		
		// Reading Aids Section
		html += `<div class="ar-aaa-menu-group">
			<div class="ar-aaa-menu-section-header">${ Menu._getLocalizedString('readingOptions') }</div>
			<div class="ar-aaa-button-row">
				<button data-action="read-aloud" class="ar-aaa-fullwidth-btn">${ ICONS.readAloud } ${ Menu._getLocalizedString('readAloud') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="reading-mode" class="ar-aaa-fullwidth-btn">${ ICONS.readingMode } ${ Menu._getLocalizedString('readingMode') }</button>
			</div>
			<div class="ar-aaa-button-row">
				<button data-action="reading-mask">${ ICONS.readingMask } ${ Menu._getLocalizedString('readingMask') }</button>
				<button data-action="reading-line">${ ICONS.readingLine } ${ Menu._getLocalizedString('readingLine') }</button>
			</div>
		</div>`;
		
		// Reset & Close Section
		html += `<div class="ar-aaa-menu-group">
			<div class="ar-aaa-button-row">
				<button data-action="reset-all" class="ar-aaa-fullwidth-btn ar-aaa-reset-btn">${ ICONS.reset } ${ Menu._getLocalizedString('resetAll') }</button>
				<button data-action="close-menu" class="ar-aaa-fullwidth-btn">${ ICONS.close } ${ Menu._getLocalizedString('closeMenu') }</button>
			</div>
		</div>`;
		
		return html;
	};
	Menu.panel.populatePageStructurePanel = function (customSelectors) {
		if (!Menu.pageStructurePanel)
			return;
		const selectors = customSelectors || {
		    headings: 'h1:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h2:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h3:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h4:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
			  'h5:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *), ' +
		    	  'h6:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
		    landmarks: [
			  'main:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="main"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'nav:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="navigation"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'header:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="banner"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'footer:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="contentinfo"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'aside:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="complementary"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'form:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="form"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="search"]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'section[aria-label]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  'section[aria-labelledby]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="region"][aria-label]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)',
			  '[role="region"][aria-labelledby]:not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)'
		    ].join(', '),
		    links: 'a[href]:not([href=""]):not([href="#"]):not([href^="javascript:"]):not([aria-hidden="true"]):not(.ar-aaa-visually-hidden):not(#aaa-menu-panel *):not(#aaa-menu-button *)'
		};
		
		const listedElements = new Set();
		const isHiddenOrEmpty = el => {
			if (!el || el.nodeType !== Node.ELEMENT_NODE)
				return true;
			if (window.getComputedStyle(el).display === 'none' || window.getComputedStyle(el).visibility === 'hidden' || el.offsetWidth === 0 || el.offsetHeight === 0) {
				return true;
			}
			if (el.matches('h1,h2,h3,h4,h5,h6,a[href]')) {
				return !ar_hasAccessibleNameForElement(el);
			}
			return false;
		};
		const getAccessibleName = el => {
			if (!el)
				return '';
			if (el.hasAttribute('aria-label') && el.getAttribute('aria-label').trim()) {
				return el.getAttribute('aria-label').trim();
			}
			if (el.hasAttribute('aria-labelledby')) {
				const labelledbyIds = el.getAttribute('aria-labelledby').split(/\s+/);
				for (const id of labelledbyIds) {
					const lblEl = document.getElementById(id);
					if (lblEl && lblEl.textContent.trim()) {
						return lblEl.textContent.trim();
					}
				}
			}
			if (el.textContent && el.textContent.trim()) {
				let text = el.textContent.trim().replace(/\s+/g, ' ');
				const tempDiv = document.createElement('div');
				tempDiv.textContent = text;
				text = tempDiv.textContent.trim().replace(/\s+/g, ' ');
				if (text.length > 100) {
					text = text.substring(0, 97) + '...';
				}
				return text;
			}
			if (el.tagName === 'A') {
				const img = el.querySelector('img[alt]');
				if (img && img.alt.trim()) {
					return img.alt.trim();
				}
			}
			if (el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'TEXTAREA') {
				if (el.placeholder && el.placeholder.trim())
					return el.placeholder.trim();
				if (el.title && el.title.trim())
					return el.title.trim();
			}
			return '';
		};
		const isElementAlreadyListedOrCovered = el => {
			if (listedElements.has(el))
				return true;
			let current = el.parentElement;
			while (current) {
				if (listedElements.has(current)) {
					const currentRole = current.getAttribute('role') || current.tagName.toLowerCase();
					if ([
							'main',
							'navigation',
							'banner',
							'contentinfo',
							'complementary',
							'form',
							'region',
							'search'
						].includes(currentRole)) {
						if (getAccessibleName(current) && !el.matches('h1, h2, h3, h4, h5, h6, a[href], button, input, select, textarea, [role="button"], [role="link"]')) {
							return true;
						}
					}
				}
				current = current.parentElement;
			}
			return false;
		};
		const addToList = (el, text, type) => {
			if (isAccessibilityMenuElement(el)) {
				return null;
			}
			if (isHiddenOrEmpty(el)) {
				return null;
			}
			if (isElementAlreadyListedOrCovered(el)) {
				return null;
			}
			const li = document.createElement('li');
			const button = document.createElement('button');
			const display_text = text.substring(0, 70) + (text.length > 70 ? '...' : '');
			button.textContent = display_text;
			button.title = text;
			button.addEventListener('click', () => {
				el.scrollIntoView({
					behavior: 'smooth',
					block: 'center'
				});
				el.classList.add(CLASS_TEMP_HIGHLIGHT);
				setTimeout(() => {
					el.classList.remove(CLASS_TEMP_HIGHLIGHT);
				}, 2000);
			});
			li.appendChild(button);
			listedElements.add(el);
			return li;
		};
		const createListSection = (selector, containerId, itemType) => {
			const container = Menu.pageStructurePanel.querySelector(`#${ containerId } ul`);
			if (!container)
				return;
			container.innerHTML = '';
			let elements = Array.from(document.querySelectorAll(selector));
			elements = elements.filter(el => !isAccessibilityMenuElement(el));
			const itemsToAdd = [];
			elements.forEach(el => {
				let text = getAccessibleName(el);
				if (!( !text || text.length < 2 || text.toLowerCase().includes('read more') || text.toLowerCase().includes('click here') )){
					const parentText = el.parentElement ? el.parentElement.textContent.trim().replace(/\s+/g, ' ') : '';
					if (parentText.length > 10 && parentText.length < 100) {
						text = `${ parentText.substring(0, Math.min(parentText.length, 50)) }...`;
					}
					if (text && text.trim() !== '') {
						const listItem = addToList(el, text, itemType);
						if (listItem) {
							itemsToAdd.push(listItem);
						}
					}
				}
			});
			if (itemsToAdd.length === 0) {
				container.innerHTML = `<li>${ Menu._getLocalizedString('noItemsFound') }</li>`;
			} else {
				itemsToAdd.forEach(li => container.appendChild(li));
			}
		};
		listedElements.clear();
		createListSection(selectors.headings,'ar-aaa-structure-headings','Heading');
		createListSection(selectors.landmarks, 'ar-aaa-structure-landmarks', 'Landmarks');
		createListSection(selectors.links,'ar-aaa-structure-links','Links');
	};
}(AR_AccessibilityMenu));

var AR_CheckModules = AR_CheckModules || {};
(function (AR_CheckModulesProto) {
	AR_CheckModulesProto.checkContentStructure = function (globalState) {
		ar_logSection('Structure and Relationships');
		this._checkVisualHeadings(globalState);
		this._checkPseudoLists();
		this._checkParagraphsWithOnlyImages();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkVisualHeadings = function (globalState) {
		document.querySelectorAll('div, span, p').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || el.closest('h1, h2, h3, h4, h5, h6'))
					return;
				const style = window.getComputedStyle(el);
				const fontSize = parseFloat(style.fontSize);
				const fontWeight = style.fontWeight;
				const isSemanticallyHeading = [
					'H1',
					'H2',
					'H3',
					'H4',
					'H5',
					'H6'
				].includes(el.tagName);
				const hasHeadingRole = el.getAttribute('role') === 'heading';
				if (fontSize >= 20 && (parseInt(fontWeight) >= 600 || fontWeight === 'bold' || fontWeight === 'bolder') && el.textContent.trim().length > 0) {
					if (!isSemanticallyHeading && !hasHeadingRole) {
						let level = 2;
						const h1 = document.querySelector('h1');
						if (h1) {
							const h1FontSize = parseFloat(window.getComputedStyle(h1).fontSize);
							if (fontSize > h1FontSize * 0.85) {
								level = 1
							} else if (fontSize < h1FontSize * 0.6) {
								level = 3
							}
						}
						ar_setAttributeAndLog(el, 'role', 'heading', 'Moderate', 'Visually strong text not semantic heading. Auto-added role="heading".', 'Use H1-H6 or ensure correct aria-level.', 'Operable', '2.4.6 Headings and Labels', 'AA');
						ar_setAttributeAndLog(el, 'aria-level', level.toString(), 'Info', `Auto-set aria-level="${ level }". Review.`, 'Ensure aria-level matches visual hierarchy.', 'Operable', '2.4.6 Headings and Labels', 'AA')
					} else if (hasHeadingRole && !el.hasAttribute('aria-level')) {
						ar_setAttributeAndLog(el, 'aria-level', '2', 'Minor', 'role="heading" without aria-level. Auto-set to "2".', 'Provide aria-level.', 'Operable', '2.4.6 Headings and Labels', 'AA')
					}
				} else if (hasHeadingRole && (fontSize < 16 || parseInt(fontWeight) < 500)) {
					ar_removeAttributeAndLog(el, 'role', 'Minor', 'Element with role="heading" does not appear visually as a heading. Auto-removed role.', 'Remove role="heading" if not a visual heading.', 'Robust', '4.1.2', 'A');
					ar_removeAttributeAndLog(el, 'aria-level', 'Minor', 'Removed associated aria-level.', '', 'Robust', '4.1.2', 'A')
				}
			} catch (e) {
				console.error('Error: VisualHeadings Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkPseudoLists = function () {
		document.querySelectorAll('div, p').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || el.closest('ul, ol, dl'))
					return;
				const textContent = (el.textContent || '').trim();
				const isPseudoListItem = textContent.startsWith('\u2022 ') || textContent.startsWith('- ') || /^\d+\.\s/.test(textContent);
				if (isPseudoListItem) {
					let nextSibling = el.nextElementSibling;
					let similarSiblings = [el];
					while (nextSibling && !nextSibling.closest('ul,ol,dl')) {
						const siblingText = (nextSibling.textContent || '').trim();
						if (siblingText.startsWith('\u2022 ') || siblingText.startsWith('- ') || /^\d+\.\s/.test(siblingText)) {
							similarSiblings.push(nextSibling);
							nextSibling = nextSibling.nextElementSibling
						} else {
							break
						}
					}
					if (similarSiblings.length > 1) {
						const listType = /^\d+\.\s/.test(textContent) ? 'ol' : 'ul';
						const newList = document.createElement(listType);
						const parent = el.parentNode;
						if (parent) {
							parent.insertBefore(newList, el);
							similarSiblings.forEach(sibling => {
								const listItem = document.createElement('li');
								while (sibling.firstChild) {
									listItem.appendChild(sibling.firstChild)
								}
								sibling.remove();
								newList.appendChild(listItem)
							});
							ar_logAccessibilityIssue('Moderate', `Wrapped ${ similarSiblings.length } pseudo-list items in <${ listType }>.`, newList, 'Review auto-generated list structure. Ensure nested lists are handled correctly.', 'Perceivable', '1.3.1 Info and Relationships', true, 'A')
						}
					}
				}
			} catch (e) {
				console.error('Error: PseudoList Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkParagraphsWithOnlyImages = function () {
		document.querySelectorAll('p').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (el.children.length === 1 && el.children[0].tagName === 'IMG') {
					const img = el.children[0];
					if (((img.alt || '').trim() === '' || img.getAttribute('role') === 'presentation') && !ar_hasAccessibleNameForElement(img)) {
						if (el.getAttribute('role') !== 'presentation') {
							ar_setAttributeAndLog(el, 'role', 'presentation', 'Minor', 'Paragraph contains only a decorative image. Added role="presentation" to the paragraph.', 'If the paragraph is purely a decorative container for the image, role="presentation" is appropriate. Otherwise, ensure the image has proper alt text.', 'Perceivable', '1.3.1 Info and Relationships', true, 'A')
						}
					} else if (el.getAttribute('role') === 'presentation' && ar_hasAccessibleNameForElement(img)) {
						ar_removeAttributeAndLog(el, 'role', 'Minor', 'Paragraph with role="presentation" contains informative image. Auto-removed role.', 'Remove role="presentation" if image is informative.', 'Robust', '4.1.2', 'A')
					}
				}
			} catch (e) {
				console.error('Error: ParagraphsWithOnlyImages Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto.checkMediaIntegrity = function () {
		ar_logSection('Media Integrity (Images, Links)');
		this._checkBrokenImages();
		this._checkEmptyLinks();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkBrokenImages = function () {
		document.querySelectorAll('img').forEach(img => {
			if (img.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(img) && !img.hasAttribute('alt') || img.src.includes('placehold.co') && img.alt.startsWith('Placeholder for broken image')) {
					if (ar_isVisuallyHidden(img) && !img.hasAttribute('alt')) {
						ar_setAttributeAndLog(img, 'alt', '', 'Info', 'Visually hidden image was missing alt attribute. Auto-set alt="".', 'Ensure decorative hidden images have an empty alt attribute.', 'Perceivable', '1.1.1 Non-text Content', 'A')
					}
					return
				}
				if (!img.complete || img.naturalWidth === 0 || img.naturalHeight === 0) {
					if (img.src.includes('placehold.co') && img.src.includes('Broken%20Image'))
						return;
					const originalSrc = img.src;
					const altText = img.alt && img.alt.trim() !== '' ? img.alt.trim() : 'Broken Image';
					const placeholderWidth = Math.max(50, img.width || parseInt(img.style.width, 10) || 150);
					const placeholderHeight = Math.max(50, img.height || parseInt(img.style.height, 10) || 100);
					const placeholderSrc = AR_CONFIG.PLACEHOLDER_IMAGE_URL.replace('{width}', placeholderWidth.toString()).replace('{height}', placeholderHeight.toString()).replace('{text}', encodeURIComponent(altText.substring(0, 50)));
					img.setAttribute('data-original-src', originalSrc);
					img.src = placeholderSrc;
					img.alt = `Placeholder for broken image: ${ ar_escapeHtml(altText) }`;
					ar_logAccessibilityIssue('Critical', 'Broken image detected. Replaced with a placeholder.', img, `Original src: ${ originalSrc }. Verify the image source or ensure the alt text is sufficiently descriptive if the image cannot be restored.`, 'Perceivable', '1.1.1 Non-text Content', true, 'A')
				}
			} catch (e) {
				console.error('Error: BrokenImage Check:', e, img)
			}
		})
	};
	AR_CheckModulesProto._checkEmptyLinks = function () {
		document.querySelectorAll('a[href]').forEach(a => {
			if (a.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(a))
					return;
				const href = a.getAttribute('href');
				const hasName = ar_hasAccessibleNameForElement(a);
				if (!hasName && (href === '#' || href === '' || !href || href.trim().toLowerCase() === 'javascript:void(0);')) {
					const titleAttr = (a.getAttribute('title') || '').trim();
					if (titleAttr.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT) {
						ar_setAttributeAndLog(a, 'aria-label', ar_escapeHtml(titleAttr), 'Minor', 'Link with no discernible text content but a title attribute. Auto-set aria-label from title.', 'Review auto-generated aria-label. Prefer descriptive link text over title attribute for links.', 'Perceivable', '2.4.4 Link Purpose (In Context)', 'A')
					} else {
						const rect = a.getBoundingClientRect();
						if (rect.width < 10 && rect.height < 10 && rect.width > 0 && rect.height > 0) {
							ar_setAttributeAndLog(a, 'aria-hidden', 'true', 'Minor', 'Small, empty, non-functional link auto-hidden with aria-hidden="true".', 'Remove or provide a descriptive name if the link is functional.', 'Perceivable', '2.4.4 Link Purpose (In Context)', true, 'A')
						} else {
							ar_setAttributeAndLog(a, 'aria-label', 'Link - Description Needed', 'Critical', 'Link has no discernible text or accessible name. Auto-added a generic aria-label.', 'Provide descriptive text content or an aria-label for the link.', 'Perceivable', '2.4.4 Link Purpose (In Context)', true, 'A')
						}
					}
				}
			} catch (e) {
				console.error('Error: EmptyLink Check:', e, a)
			}
		})
	};
	AR_CheckModulesProto.checkImageAltText = function () {
		ar_logSection('Image Alternative Text');
		document.querySelectorAll('img').forEach(img => {
			if (img.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(img) && img.hasAttribute('alt') || img.src.includes('placehold.co') && img.alt.startsWith('Placeholder for broken image'))
					return;
				if (img.naturalWidth === 0 && !img.src.startsWith('data:image/svg+xml') && !img.src.includes('placehold.co')) {
					if (img.complete && !img.hasAttribute('alt')) {
						ar_setAttributeAndLog(img, 'alt', 'Broken image (description needed)', 'Critical', 'Image appears broken and is missing alt text.', 'Fix image source or provide descriptive alt text.', 'Perceivable', '1.1.1', 'A')
					}
					return
				}
				if (!img.hasAttribute('alt')) {
					const generatedAlt = this._generateAltTextAttempt(img);
					ar_setAttributeAndLog(img, 'alt', ar_escapeHtml(generatedAlt), 'Critical', `Image missing alt attribute. Auto-set to "${ ar_escapeHtml(generatedAlt) }".`, '**Manual review required.**', 'Perceivable', '1.1.1 Non-text Content', 'A')
				} else {
					const alt = (img.alt || '').trim();
					if (alt === '') {
						this._checkDecorativeImageContext(img)
					} else {
						this._checkInformativeAltText(img, alt)
					}
				}
			} catch (e) {
				console.error('Error: ImageAltText Check:', e, img)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._generateAltTextAttempt = function (img) {
		if (img.getAttribute('aria-hidden') === 'true') return;
		let altText = 'Image (description needed)';
		const src = (img.src || '').toLowerCase();
		let className = (img.className || '')
		if(typeof className === "object"){
			className = className.baseVal;
		}			
		className = className.toLowerCase();
		if (AR_CONFIG.AVATAR_KEYWORDS.some(kw => src.includes(kw) || className.includes(kw))) {
			altText = 'User avatar'
		} else {
			const filenameMatch = src.match(/[^/\\&?]+\.\w{3,4}(?=([?&].*$|$))/);
			if (filenameMatch) {
				const filename = filenameMatch[0].substring(0, filenameMatch[0].lastIndexOf('.')).replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
				if (filename.length > 3 && filename.length < 50 && !/\d{4,}/.test(filename) && !/(icon|logo|banner|image|pic)/i.test(filename)) {
					altText = filename.charAt(0).toUpperCase() + filename.slice(1)
				}
			}
		}
		if (img.title && img.title.trim().length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT && !/(image|graphic|picture|photo)/i.test(img.title.trim())) {
			altText = img.title.trim()
		} else if (img.parentElement && img.parentElement.textContent && img.parentElement.textContent.trim().length > 10 && img.parentElement.textContent.trim().length < 100) {
			const parentText = img.parentElement.textContent.trim().replace(/\s+/g, ' ');
			if (!/(image|graphic|picture|photo)/i.test(parentText)) {
				altText = parentText.substring(0, Math.min(parentText.length, 50)) + (parentText.length > 50 ? '...' : '')
			}
		}
		return ar_escapeHtml(altText)
	};
	AR_CheckModulesProto._checkDecorativeImageContext = function (img) {
		if (img.getAttribute('aria-hidden') === 'true') return;
		const src = (img.src || '').toLowerCase();
		if (/(chart|graph|diagram|stats|figure)/.test(src) && (img.offsetWidth > 50 || img.offsetHeight > 50)) {
			ar_setAttributeAndLog(img, 'alt', 'Image (description needed, was decorative)', 'Moderate', `Image has alt="" but src suggests it might be informative. Auto-set placeholder.`, 'Verify if decorative. Provide descriptive alt text if informative.', 'Perceivable', '1.1.1', 'A')
		}
		if (/(spacer|1x1)\.(gif|png|jpg)/i.test(src) && img.getAttribute('role') !== 'presentation') {
			ar_setAttributeAndLog(img, 'role', 'presentation', 'Minor', 'Spacer image with alt="". Auto-added role="presentation".', 'Spacers: alt="" and role="presentation".', 'Perceivable', '1.1.1', true, 'A')
		}
	};
	AR_CheckModulesProto._checkInformativeAltText = function (img, alt) {
		if (img.getAttribute('aria-hidden') === 'true') return;
		const filenameFromSrc = (img.src || '').split('/').pop().split('.')[0].replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ').toLowerCase();
		if (alt.toLowerCase() === filenameFromSrc && alt.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_NON_EMPTY_ALT_TEXT) {
			ar_setAttributeAndLog(img, 'alt', `Image: ${ ar_escapeHtml(alt) } (description needed, was filename)`, 'Minor', `Alt text "${ ar_escapeHtml(alt) }" is filename. Auto-updated.`, 'Replace filename with description.', 'Perceivable', '1.1.1', 'A')
		}
		const genericAlts = [
			'image',
			'graphic',
			'picture',
			'photo',
			'logo',
			'icon',
			'banner'
		];
		if (genericAlts.includes(alt.toLowerCase()) && (img.offsetWidth > 30 || img.offsetHeight > 30)) {
			ar_logAccessibilityIssue('Minor', `Alt text "${ ar_escapeHtml(alt) }" is generic.`, img, 'Provide more specific alt text.', 'Perceivable', '1.1.1', false, 'A')
		}
	};
	AR_CheckModulesProto.checkIframeTitles = function () {
		ar_logSection('Iframe Titles');
		document.querySelectorAll('iframe').forEach(iframe => {
			if (iframe.getAttribute('aria-hidden') === 'true') return;
			try {
				if (!iframe.title || iframe.title.trim() === '') {
					const generatedTitle = this._generateIframeTitleAttempt(iframe);
					ar_setAttributeAndLog(iframe, 'title', ar_escapeHtml(generatedTitle), 'Critical', `Iframe missing title. Auto-set to "${ ar_escapeHtml(generatedTitle) }".`, '**Manual review required.**', 'Operable', '2.4.1, 4.1.2', 'A')
				}
			} catch (e) {
				console.error('Error: IframeTitles Check:', e, iframe)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._generateIframeTitleAttempt = function (iframe) {
		if (iframe.getAttribute('aria-hidden') === 'true') return;
		let title = 'Embedded content';
		if (iframe.src) {
			try {
				const url = new URL(iframe.src);
				const hostname = url.hostname.toLowerCase();
				const allowedYouTubeHosts = [
					'youtube.com',
					'youtu.be'
				];
				const allowedVimeoHosts = ['vimeo.com'];
				const allowedGoogleMapsHosts = [
					'maps.google.com',
					'google.com/maps'
				];
				if (allowedYouTubeHosts.some(h => hostname.endsWith(h)))
					title = 'YouTube video player';
				else if (allowedVimeoHosts.some(h => hostname.endsWith(h)))
					title = 'Vimeo video player';
				else if (allowedGoogleMapsHosts.some(h => hostname.endsWith(h)))
					title = 'Google Maps embed';
				else if (url.pathname.endsWith('.pdf'))
					title = `Embedded PDF document: ${ url.pathname.split('/').pop() }`;
				else if (hostname && hostname !== 'about:blank')
					title = `Embedded content from ${ hostname.replace('www.', '') }`
			} catch (e) {
			}
		}
		return ar_escapeHtml(title)
	};
	AR_CheckModulesProto.checkTableAccessibility = function () {
		ar_logSection('Table Accessibility');
		document.querySelectorAll('table').forEach(table => {
			if (table.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(table))
					return;
				const role = table.getAttribute('role');
				if (role === 'presentation' || role === 'none') {
					this._checkPresentationTable(table);
					return
				}
				this._checkDataTableCaption(table);
				this._checkTableHeaders(table);
				this._checkLayoutTableHeuristic(table)
			} catch (e) {
				console.error('Error: TableAccessibility Check:', e, table)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._checkDataTableCaption = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		if (!table.querySelector('caption') && table.querySelectorAll('th').length > 0) {
			const caption = document.createElement('caption');
			caption.textContent = 'Table data (auto-caption)';
			Object.assign(caption.style, {
				position: 'absolute',
				left: '-9999px',
				width: '1px',
				height: '1px',
				overflow: 'hidden'
			});
			table.prepend(caption);
			ar_logAccessibilityIssue('Moderate', 'Data table missing <caption>. Auto-added generic hidden caption.', table, '**Manual review required.** Provide a descriptive caption.', 'Perceivable', '1.3.1', true, 'A')
		}
	};
	AR_CheckModulesProto._checkTableHeaders = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		table.querySelectorAll('thead th').forEach(thEl => {
			if (!thEl.hasAttribute('scope')) {
				ar_setAttributeAndLog(thEl, 'scope', 'col', 'Minor', '<th> in <thead> missing scope. Auto-set "col".', 'Add scope="col".', 'Perceivable', '1.3.1', 'A')
			}
		});
		table.querySelectorAll('tbody tr > th:first-child, tfoot tr > th:first-child').forEach(thEl => {
			const parentRow = thEl.closest('tr');
			if (parentRow && parentRow.querySelectorAll('th').length === 1 && !thEl.hasAttribute('scope')) {
				ar_setAttributeAndLog(thEl, 'scope', 'row', 'Minor', 'First <th> in row missing scope. Auto-set "row".', 'Add scope="row".', 'Perceivable', '1.3.1', 'A')
			}
		})
	};
	AR_CheckModulesProto._checkLayoutTableHeuristic = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		const thCount = table.querySelectorAll('th').length;
		const tdCount = table.querySelectorAll('td').length;
		const border = table.getAttribute('border');
		if (thCount === 0 && tdCount > 0 && (!border || border === '0') && !table.querySelector('caption') && !table.hasAttribute('role') && !table.hasAttribute('summary')) {
			if (table.rows.length < 5 && Array.from(table.rows).every(r => r.cells.length < 5)) {
				ar_setAttributeAndLog(table, 'role', 'presentation', 'Minor', 'Table appears to be used for layout. Auto-added role="presentation".', 'If this is a data table, remove role and add proper semantics (<th>, <caption>).', 'Perceivable', '1.3.1', true, 'A')
			}
		}
	};
	AR_CheckModulesProto._checkPresentationTable = function (table) {
		if (table.getAttribute('aria-hidden') === 'true') return;
		if (table.querySelector('caption')) {
			ar_logAccessibilityIssue('Minor', 'Table with role="presentation" has <caption>.', table, 'Remove <caption> from tables used for layout.', 'Perceivable', '1.3.1', false, 'A')
		}
		if (table.hasAttribute('summary')) {
			ar_logAccessibilityIssue('Minor', 'Table with role="presentation" has summary.', table, 'Remove summary from tables used for layout.', 'Perceivable', '1.3.1', false, 'A')
		}
		table.querySelectorAll('th, [scope]').forEach(el => {
			ar_logAccessibilityIssue('Minor', `Table with role="presentation" contains <${ el.tagName.toLowerCase() }> or scope attribute.`, el, `Remove <th> or scope. Use <td> elements for layout tables.`, 'Perceivable', '1.3.1', false, 'A')
		})
	};
	AR_CheckModulesProto.checkOverlayFocusBlocking = function () {
		ar_logSection('Overlapping Elements (Modals/Popups)');
		document.querySelectorAll('body > div, body > section, body > aside, [role="dialog"], [role="alertdialog"]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const style = window.getComputedStyle(el);
				const rect = el.getBoundingClientRect();
				const isOverlay = (style.position === 'fixed' || style.position === 'absolute') && (rect.width >= window.innerWidth * 0.7 || rect.height >= window.innerHeight * 0.7) && parseFloat(style.zIndex) >= 1000 && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity > 0;
				if (isOverlay) {
					this._ensureModalAriaAttributes(el);
					this._manageBackgroundContentInteractivity(el)
				} else if (el.getAttribute('aria-modal') === 'true' || el.getAttribute('role') === 'dialog' || el.getAttribute('role') === 'alertdialog') {
					this._restoreBackgroundContentInteractivity(el)
				}
			} catch (e) {
				console.error('Error: OverlayFocusBlocking Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._ensureModalAriaAttributes = function (modalElement) {
		if (modalElement.getAttribute('aria-hidden') === 'true') return;
		if (modalElement.getAttribute('aria-modal') !== 'true') {
			ar_setAttributeAndLog(modalElement, 'aria-modal', 'true', 'Critical', 'Potential modal lacks aria-modal="true". Auto-fixed.', 'Ensure focus trap & ESC handling. Set aria-modal="true" for modal dialogs.', 'Operable', '4.1.2 / 2.4.3', 'A')
		}
		const role = modalElement.getAttribute('role');
		if (role !== 'dialog' && role !== 'alertdialog') {
			ar_setAttributeAndLog(modalElement, 'role', 'dialog', 'Critical', 'Potential modal lacks role="dialog/alertdialog". Auto-fixed.', 'Use role="dialog" or "alertdialog" for modal dialogs.', 'Operable', '4.1.2', 'A')
		}
	};
	AR_CheckModulesProto._manageBackgroundContentInteractivity = function (modalElement) {
		if (modalElement.getAttribute('aria-hidden') === 'true') return;
		if (modalElement.getAttribute('aria-modal') === 'true') {
			let hiddenElementsCount = 0;
			Array.from(document.body.children).forEach(child => {
				if (child !== modalElement && !modalElement.contains(child) && ![
						'SCRIPT',
						'STYLE',
						'LINK'
					].includes(child.tagName.toUpperCase()) && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID) {
					if (child.getAttribute('aria-hidden') !== 'true') {
						if (child.hasAttribute('aria-hidden')) {
							child.setAttribute('data-ar-original-aria-hidden', child.getAttribute('aria-hidden'))
						}
						child.setAttribute('aria-hidden', 'true');
						hiddenElementsCount++
					}
				}
			});
			if (hiddenElementsCount > 0) {
				ar_logAccessibilityIssue('Info', `Modal: ${ hiddenElementsCount } background elements auto-set aria-hidden="true".`, modalElement, 'Ensure these elements are made visible on modal close. Implement a robust focus trap.', 'Operable', '2.4.3', true, 'A')
			}
		}
	};
	AR_CheckModulesProto._restoreBackgroundContentInteractivity = function (modalElement) {
		if (modalElement.getAttribute('aria-hidden') === 'true') return;
		if (ar_isVisuallyHidden(modalElement)) {
			let restoredElementsCount = 0;
			Array.from(document.body.children).forEach(child => {
				if (child.getAttribute('aria-hidden') === 'true' && child.hasAttribute('data-ar-original-aria-hidden')) {
					child.setAttribute('aria-hidden', child.getAttribute('data-ar-original-aria-hidden'));
					child.removeAttribute('data-ar-original-aria-hidden');
					restoredElementsCount++
				} else if (child.getAttribute('aria-hidden') === 'true' && !child.hasAttribute('data-ar-original-aria-hidden') && child !== modalElement && !modalElement.contains(child)) {
					child.removeAttribute('aria-hidden');
					restoredElementsCount++
				}
			});
			if (restoredElementsCount > 0) {
				ar_logAccessibilityIssue('Info', `Modal: ${ restoredElementsCount } background elements auto-restored aria-hidden.`, modalElement, 'Verification of modal close logic is recommended.', 'Operable', '2.4.3', true, 'A')
			}
		}
	};
	AR_CheckModulesProto.checkInteractiveElementSize = function () {
		ar_logSection('Interactive Element Size');
		document.querySelectorAll(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const rect = el.getBoundingClientRect();
				if (rect.width > 0 && rect.height > 0 && (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX || rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX)) {
					const stylesToApply = {};
					const computedStyle = window.getComputedStyle(el);
					if (computedStyle.display === 'inline') {
						stylesToApply['display'] = 'inline-block'
					}
					if (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX) {
						stylesToApply['min-width'] = `${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px`
					}
					if (rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX) {
						stylesToApply['min-height'] = `${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px`
					}
					const currentPaddingV = parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
					const currentPaddingH = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
					if (rect.height < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX && currentPaddingV < 4) {
						stylesToApply['padding-top'] = stylesToApply['padding-bottom'] = '0.3em'
					}
					if (rect.width < AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX && currentPaddingH < 8) {
						stylesToApply['padding-left'] = stylesToApply['padding-right'] = '0.5em'
					}
					if (Object.keys(stylesToApply).length > 0) {
						ar_applyStylesAndLog(el, stylesToApply, 'Moderate', `Interactive element too small. Auto-adjusted.`, `Increase area to ${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }x${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px.`, 'Operable', '2.5.5 Target Size', 'AAA')
					} else {
						ar_logAccessibilityIssue('Moderate', `Interactive element too small. Could not auto-adjust.`, el, `Increase area to ${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }x${ AR_CONFIG.MINIMUM_INTERACTIVE_ELEMENT_SIZE_PX }px.`, 'Operable', '2.5.5 Target Size', false, 'AAA')
					}
				}
			} catch (e) {
				console.error('Error: InteractiveElementSize Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkHoverFocusContent = function () {
		ar_logSection('Content on Hover/Focus (ARIA Attributes)');
	
		const interactiveElements = document.querySelectorAll(
		    'button, a[href], [role="button"], [role="link"], [role="menuitem"]'
		);
	
		interactiveElements.forEach(el => {
		    if (el.getAttribute('aria-hidden') === 'true') return;
		    try {
			if (ar_isVisuallyHidden(el)) return;
	
			validateAriaHasPopup(el);
			validateAriaExpandedAndControls(el);
		    } catch (error) {
			console.error('Error in HoverFocusContent Check:', error, el);
		    }
		});
	
		console.log(
		    '\n\uD83D\uDCA1 Manual Verification for WCAG 1.4.13 (Content on Hover/Focus) is CRUCIAL: ' +
		    'Check for Dismissible, Hoverable, Persistent properties of popups.'
		);
		console.groupEnd();
	};
	AR_CheckModulesProto.checkAutoFormSubmission = function () {
		ar_logSection('Automatic Form Submission');
		document.querySelectorAll('form, input:not([type="hidden"]), select, textarea').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				[
					'onfocus',
					'onchange'
				].forEach(attrName => {
					const attrValue = el.getAttribute(attrName);
					if (attrValue && attrValue.toLowerCase().includes('submit()')) {
						ar_removeAttributeAndLog(el, attrName, 'Minor', `${ el.tagName } with ${ attrName } auto-submits. Auto-removed.`, 'Avoid automatic form submission on focus or change. Use an explicit submit button.', 'Operable', '3.2.2', 'A')
					}
				})
			} catch (e) {
				console.error('Error: AutoFormSubmission Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkDuplicateIds = function (globalState) {
		ar_logSection('Duplicate IDs');
		document.querySelectorAll('[id]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const id = el.getAttribute("id");
				if (!id || id.trim() === '')
					return;
				if (globalState.seenIds.has(id)) {
					const originalElement = globalState.seenIds.get(id);
					const newId = ar_generateUniqueElementId(`dup-${ id }-`);
					ar_setAttributeAndLog(el, 'id', newId, 'Critical', `Duplicate ID "#${ id }". Auto-fixed to "#${ newId }".`, `Original element:`, 'Robust', '4.1.1', 'A');
					console.warn('    Original element with conflicting ID:', originalElement);
					document.querySelectorAll(`[aria-controls*="${ id }"], [aria-labelledby*="${ id }"], [aria-describedby*="${ id }"], label[for="${ id }"]`).forEach(refEl => {
						if (refEl.id === newId)
							return;
						if (refEl.hasAttribute('aria-controls') && refEl.getAttribute('aria-controls') === id) {
							ar_setAttributeAndLog(refEl, 'aria-controls', newId, 'Moderate', `Updated 'aria-controls' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
						if (refEl.hasAttribute('aria-labelledby') && refEl.getAttribute('aria-labelledby') === id) {
							ar_setAttributeAndLog(refEl, 'aria-labelledby', newId, 'Moderate', `Updated 'aria-labelledby' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
						if (refEl.hasAttribute('aria-describedby') && refEl.getAttribute('aria-describedby') === id) {
							ar_setAttributeAndLog(refEl, 'aria-describedby', newId, 'Moderate', `Updated 'aria-describedby' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
						if (refEl.tagName === 'LABEL' && refEl.htmlFor === id) {
							ar_setAttributeAndLog(refEl, 'for', newId, 'Moderate', `Updated 'for' reference to the old ID from "#${ id }" to "#${ newId }".`, 'Ensure all references to the old ID are updated.', 'Robust', '4.1.2', true, 'A')
						}
					})
				} else {
					globalState.seenIds.set(id, el)
				}
			} catch (e) {
				console.error('Error: DuplicateIds Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkAccessibleNames = function () {
		ar_logSection('Accessible Names for Interactive Elements');
		document.querySelectorAll(`${ AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS }, [role="img"]`).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || ar_hasAccessibleNameForElement(el))
					return;
				const generatedName = this._generateAccessibleNameCandidate(el);
				if (generatedName && generatedName.trim() !== '') {
					ar_setAttributeAndLog(el, 'aria-label', ar_escapeHtml(generatedName), 'Moderate', `Lacked accessible name. Auto-fixed with aria-label: "${ ar_escapeHtml(generatedName) }".`, '**Manual review required.**', 'Perceivable', '2.4.4 / 4.1.2', 'A')
				} else {
					ar_logAccessibilityIssue('Critical', `Lacked accessible name. Could not auto-generate.`, el, 'Provide descriptive text, title, aria-label, or associate with a <label>.', 'Perceivable', '2.4.4 / 4.1.2', false, 'A')
				}
			} catch (e) {
				console.error('Error: AccessibleNames Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._generateAccessibleNameCandidate = function (el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		let label = '';
		const tagName = el.tagName.toLowerCase();
		const type = (el.type || '').toLowerCase();
		if (el.placeholder && el.placeholder.trim())
			label = el.placeholder.trim();
		else if (el.title && el.title.trim())
			label = el.title.trim();
		if (tagName === 'input' && [
				'button',
				'submit',
				'reset'
			].includes(type) && el.value && el.value.trim()) {
			label = el.value.trim()
		} else if (tagName === 'input' && type === 'image' && el.src) {
			const filename = el.src.split('/').pop().split('.')[0].replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
			label = filename.length > 3 && filename.length < 30 ? `Submit ${ filename }` : 'Submit query';
			ar_setAttributeAndLog(el, 'alt', ar_escapeHtml(label), 'Moderate', `Input type="image" missing alt. Auto-set.`, '**Manual review.**', 'Perceivable', '1.1.1', 'A');
			return ar_escapeHtml(label)
		} else if (tagName === 'img' || el.getAttribute('role') === 'img') {
			label = this._generateAltTextAttempt(el) || 'Image (description needed)'
		} else if (tagName === 'a') {
			const textContent = (el.textContent || '').trim();
			if (textContent.length > 2 && textContent.length < 50) {
				label = `Link: ${ textContent }`
			} else {
				let contextText = '';
				if (el.previousElementSibling && el.previousElementSibling.textContent) {
					contextText += el.previousElementSibling.textContent.trim()
				}
				if (el.nextElementSibling && el.nextElementSibling.textContent) {
					contextText += ' ' + el.nextElementSibling.textContent.trim()
				}
				if (el.parentElement && el.parentElement.textContent) {
					contextText += ' ' + el.parentElement.textContent.trim()
				}
				contextText = contextText.replace(/\s+/g, ' ').trim();
				if (contextText.length > 10 && contextText.length < 100) {
					label = `Link: ${ contextText.substring(0, Math.min(contextText.length, AR_CONFIG.MAX_WORDS_FROM_CONTEXT_FOR_GENERIC_LINK_ARIA_LABEL * 5)).replace(/\s+/g, ' ') }...`
				} else {
					label = 'Link - Description Needed'
				}
			}
		} else if (tagName === 'button') {
			const textContent = (el.textContent || '').trim();
			if (textContent.length > 2 && textContent.length < 50) {
				label = textContent
			} else {
				let iconLabel = '';
				for (const prefix of AR_CONFIG.COMMON_ICON_CLASS_PREFIXES) {
					for (const cssClass of Array.from(el.classList)) {
						if (cssClass.startsWith(prefix)) {
							const potentialLabel = cssClass.substring(prefix.length).replace(AR_CONFIG.FILENAME_CLEANUP_REGEX, ' ');
							if (potentialLabel.length > 2) {
								iconLabel = `${ potentialLabel.charAt(0).toUpperCase() + potentialLabel.slice(1) } button`;
								break
							}
						}
					}
					if (iconLabel)
						break
				}
				label = iconLabel || 'Button - Action Needed'
			}
		}
		if (!label || label.startsWith('Unnamed') || label.includes('Description Needed')) {
			label = `${ el.getAttribute('role') || tagName } - Description Needed`
		}
		if (label.length > AR_CONFIG.MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL) {
			label = label.substring(0, AR_CONFIG.MAX_CHAR_LENGTH_FOR_AUTOGENERATED_ARIA_LABEL - 3) + '...'
		}
		return ar_escapeHtml(label)
	};
	AR_CheckModulesProto.checkLangAttribute = function () {
		ar_logSection('Language Attribute (HTML)');
		const htmlEl = document.documentElement;
		if (!htmlEl.lang || !htmlEl.lang.trim()) {
			ar_setAttributeAndLog(htmlEl, 'lang', 'en', 'Critical', '<html> missing lang attribute. Auto-set to "en".', '**Manual review required.** Verify "en" is the correct language for the page.', 'Understandable', '3.1.1 Language of Page', 'A')
		}
		console.groupEnd()
	};
	AR_CheckModulesProto.checkTabindexUsage = function () {
		ar_logSection('Tabindex Usage');
		document.querySelectorAll('[tabindex]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const tabindexValue = parseInt(el.getAttribute('tabindex'), 10);
				if (tabindexValue > 0) {
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Moderate', `Positive tabindex="${ tabindexValue }" found. Auto-fixed to "0".`, 'Avoid positive tabindex. Use a logical document order instead.', 'Operable', '2.4.3', 'A')
				}
				const role = el.getAttribute('role');
				const isNativeInteractive = el.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS);
				const commonInteractiveRoles = [
					'button',
					'link',
					'menuitem',
					'tab',
					'checkbox',
					'radio',
					'option',
					'switch',
					'slider',
					'treeitem',
					'textbox',
					'combobox',
					'listbox'
				];
				if (role && commonInteractiveRoles.includes(role) && !isNativeInteractive && tabindexValue < 0) {
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Minor', `Custom control [role="${ role }"] is not focusable (tabindex="-1"). Auto-added tabindex="0".`, 'Ensure custom controls are focusable and in the tab order.', 'Operable', '2.1.1', 'A')
				}
				if (role && commonInteractiveRoles.includes(role) && tabindexValue === -1 && !el.disabled && el.getAttribute('aria-disabled') !== 'true') {
					ar_setAttributeAndLog(el, 'tabindex', '0', 'Minor', `Active custom control [role="${ role }"] has tabindex="-1". Auto-set to "0".`, 'Ensure active interactive controls are included in the tab order.', 'Operable', '2.1.1', 'A')
				}
			} catch (e) {
				console.error('Error: TabindexUsage Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkAriaMisuse = function () {
		ar_logSection('ARIA Misuse');
		this._checkAriaHiddenOnFocusable();
		this._checkRedundantAriaRoles();
		this._checkInvalidAriaRelationshipIDs();
		this._checkRedundantAriaLabels();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkAriaHiddenOnFocusable = function () {
		document.querySelectorAll('[aria-hidden="true"]').forEach(el => {
			try {
				const isElementFocusable = el.tabIndex >= 0 || el.matches(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS);
				const hasFocusableDescendant = el.querySelector(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS.split(',').map(s => `${ s.trim() }:not([tabindex="-1"])`).join(',')) !== null;
				if (isElementFocusable || hasFocusableDescendant) {
					ar_removeAttributeAndLog(el, 'aria-hidden', 'Critical', '`aria-hidden="true"` found on or containing focusable element. Auto-removed.', 'Do not use aria-hidden="true" on elements that are focusable or contain focusable descendants.', 'Perceivable', '4.1.2 / 1.3.1', true, 'A')
				}
			} catch (e) {
				console.error('Error: AriaHiddenOnFocusable Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkRedundantAriaRoles = function () {
		document.querySelectorAll('[role]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const role = el.getAttribute('role').toLowerCase();
				const tagName = el.tagName.toLowerCase();
				const type = (el.type || '').toLowerCase();
				const implicitRoles = {
					'button': 'button',
					'a': 'link',
					'input[type=button]': 'button',
					'input[type=submit]': 'button',
					'input[type=reset]': 'button',
					'input[type=checkbox]': 'checkbox',
					'input[type=radio]': 'radio',
					'input[type=text]': 'textbox',
					'input[type=email]': 'textbox',
					'input[type=password]': 'textbox',
					'input[type=search]': 'searchbox',
					'input[type=tel]': 'textbox',
					'input[type=url]': 'textbox',
					'select': 'listbox',
					'textarea': 'textbox',
					'img': 'img',
					'h1': 'heading',
					'h2': 'heading',
					'h3': 'heading',
					'h4': 'heading',
					'h5': 'heading',
					'h6': 'heading',
					'ul': 'list',
					'ol': 'list',
					'li': 'listitem',
					'nav': 'navigation',
					'header': 'banner',
					'footer': 'contentinfo',
					'main': 'main',
					'aside': 'complementary',
					'form': 'form',
					'section': 'region',
					'article': 'article',
					'dialog': 'dialog',
					'figure': 'figure',
					'figcaption': 'figcaption',
					'table': 'table',
					'tbody': 'rowgroup',
					'tfoot': 'rowgroup',
					'thead': 'rowgroup',
					'tr': 'row',
					'td': 'cell',
					'th': 'columnheader'
				};
				let nativeRole = implicitRoles[tagName];
				if (tagName === 'input' && type) {
					nativeRole = implicitRoles[`input[type=${ type }]`] || nativeRole
				}
				if (tagName === 'a' && !el.hasAttribute('href')) {
					nativeRole = null
				}
				if (tagName === 'img' && (!el.hasAttribute('alt') || el.alt.trim() === '')) {
					nativeRole = null
				}
				if (tagName === 'section' && !ar_hasAccessibleNameForElement(el)) {
					nativeRole = null
				}
				if (nativeRole === role) {
					if (tagName === 'img' && (role === 'presentation' || role === 'none') && (!el.hasAttribute('alt') || el.alt.trim() === '')) {
						return
					}
					ar_removeAttributeAndLog(el, 'role', 'Minor', `Redundant ARIA role="${ role }" on <${ tagName }>. Auto-removed.`, 'Native HTML element implicitly conveys the same semantic meaning.', 'Robust', '4.1.2', 'A')
				}
				if (role === 'text' && el.matches(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS)) {
					ar_removeAttributeAndLog(el, 'role', 'Critical', 'Interactive element has `role="text"`. Auto-removed.', 'Remove role="text" from interactive elements.', 'Robust', '4.1.2', 'A')
				}
				if ((role === 'presentation' || role === 'none') && (el.tabIndex >= 0 || el.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS))) {
					const parentRole = el.parentElement ? el.parentElement.getAttribute('role') : null;
					if (!(role === 'presentation' && tagName === 'li' && (parentRole === 'tablist' || parentRole === 'listbox' || parentRole === 'menu'))) {
						ar_removeAttributeAndLog(el, 'role', 'Moderate', `Focusable element has role="${ role }". Auto-removed.`, `Focusable elements should not have role="presentation" or "none" as this removes their semantics.`, 'Robust', '4.1.2', 'A')
					}
				}
			} catch (e) {
				console.error('Error: RedundantAriaRoles Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkRedundantAriaLabels = function () {
		document.querySelectorAll('[aria-label], [aria-labelledby]').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				const ariaLabel = el.getAttribute('aria-label');
				const ariaLabelledby = el.getAttribute('aria-labelledby');
				const visibleText = (el.textContent || '').trim().replace(/\s+/g, ' ');
				if (ariaLabel && visibleText.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_REDUNDANT_TITLE_CHECK && ariaLabel.trim().toLowerCase() === visibleText.toLowerCase()) {
					ar_removeAttributeAndLog(el, 'aria-label', 'Minor', `Redundant aria-label="${ ar_escapeHtml(ariaLabel) }" duplicates visible text. Auto-removed.`, 'Remove aria-label if it duplicates visible text content.', 'Robust', '4.1.2', 'A')
				}
				if (ariaLabelledby) {
					const labelledbyElements = ariaLabelledby.split(/\s+/).map(id => document.getElementById(id)).filter(Boolean);
					const labelledbyText = labelledbyElements.map(lblEl => (lblEl.textContent || '').trim().replace(/\s+/g, ' ')).join(' ').trim();
					if (labelledbyText.length > AR_CONFIG.MIN_CHAR_LENGTH_FOR_REDUNDANT_TITLE_CHECK && labelledbyText.toLowerCase() === visibleText.toLowerCase()) {
						ar_removeAttributeAndLog(el, 'aria-labelledby', 'Minor', `Redundant aria-labelledby="${ ar_escapeHtml(ariaLabelledby) }" duplicates visible text. Auto-removed.`, 'Remove aria-labelledby if it duplicates visible text content.', 'Robust', '4.1.2', 'A')
					}
				}
			} catch (e) {
				console.error('Error: RedundantAriaLabels Check:', e, el)
			}
		})
	};
	AR_CheckModulesProto._checkInvalidAriaRelationshipIDs = function () {
		[
			'aria-labelledby',
			'aria-describedby',
			'aria-controls',
			'aria-owns',
			'aria-flowto'
		].forEach(attr => {
			document.querySelectorAll(`[${ attr }]`).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
				try {
					const raw = el.getAttribute(attr) || "";
					const idRefs = raw.split(/\s+/).map(id => id.trim()).filter(id => id.length > 0);
					const validIdRefs = idRefs.filter(id => document.getElementById(id));
					if (validIdRefs.length !== idRefs.length) {
						if (validIdRefs.length > 0) {
							ar_setAttributeAndLog(el, attr, validIdRefs.join(' '), 'Minor', `${ attr } has invalid ID(s). Auto-removed invalid references.`, `Ensure ${ attr } points to existing element IDs.`, 'Robust', '4.1.2', 'A')
						} else {
							ar_removeAttributeAndLog(el, attr, 'Minor', `${ attr } only contains invalid ID(s). Auto-removed attribute.`, `Ensure ${ attr } points to existing element IDs.`, 'Robust', '4.1.2', 'A')
						}
					}
				} catch (e) {
					console.error(`Error: InvalidAriaRelationshipIDs Check for ${ attr }:`, e, el)
				}
			})
		})
	};
	AR_CheckModulesProto.checkContrastRatioForAllElements = function (targetElement = null) {
		if (!targetElement)
			ar_logSection('Text Contrast Ratios');
		const elementsToCheck = targetElement ? [targetElement] : Array.from(document.querySelectorAll(AR_SELECTOR_STRINGS.TEXT_CONTAINER_ELEMENTS_AFFECTED_BY_MENU));
		elementsToCheck.forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el) || el.textContent.trim().length === 0 || el.offsetWidth === 0 || el.offsetHeight === 0 || el.closest(`#${ AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID }`))
					return;
				const style = window.getComputedStyle(el);
				const fgOriginalRgba = ar_parseCssColorString(style.color);
				if (fgOriginalRgba[3] === 0)
					return;
				const bgEffectiveRgba = ar_getEffectiveBackgroundColorOfElement(el);
				const fgPerceivedRgba = ar_blendColors(fgOriginalRgba, bgEffectiveRgba);
				const currentContrast = ar_getContrastRatioBetweenColors(fgPerceivedRgba, bgEffectiveRgba);
				const isLargeText = ar_isTextLargeForWCAG(el);
				const requiredContrast = isLargeText ? AR_CONFIG.CONTRAST_RATIO_AA_LARGE_TEXT : AR_CONFIG.CONTRAST_RATIO_AA_NORMAL_TEXT;
				const originalFgColorString = `rgba(${ fgOriginalRgba.join(',') })`;
				const originalBgColorString = `rgb(${ bgEffectiveRgba.slice(0, 3).join(',') })`;
				if (currentContrast < requiredContrast && currentContrast > 1.00) {
					const initialFailureKey = `${ el.id || el.dataset.arGeneratedId || ar_generateUniqueElementId('contrast-el-') }::CONTRAST_FAILURE_INITIAL::${ originalFgColorString }-${ originalBgColorString }`;
					if (!ar_loggedIssuesTracker.has(initialFailureKey)) {
						ar_logAccessibilityIssue('Critical', `Low contrast: ${ currentContrast.toFixed(2) }:1 (Req: ${ requiredContrast }:1).`, el, `Original: ${ originalFgColorString } on ${ originalBgColorString }. Attempting autofix.`, 'Perceivable', '1.4.3 Contrast (Minimum)', false, 'AA')
					}
					const fixed = this._attemptContrastFix(el, fgOriginalRgba, bgEffectiveRgba, requiredContrast, originalFgColorString, originalBgColorString);
					if (fixed.success) {
						ar_logAccessibilityIssue('Info', `Low contrast auto-fixed. New text: ${ fixed.newFgCss }, New BG: ${ fixed.newBgCss || 'unchanged' }. New contrast: ${ fixed.newContrast.toFixed(2) }:1. Strategy: ${ fixed.strategy }.`, el, `Original: ${ originalFgColorString }, ${ originalBgColorString }.`, 'Perceivable', '1.4.3', true, 'AA');
						ar_loggedIssuesTracker.add(initialFailureKey)
					} else {
						const failKey = `${ initialFailureKey }::AUTOFIX_FAILED`;
						if (!ar_loggedIssuesTracker.has(failKey)) {
							ar_logAccessibilityIssue('Critical', `Low contrast ${ currentContrast.toFixed(2) }:1. Autofix failed. Best achieved: ${ fixed.newContrast ? fixed.newContrast.toFixed(2) + ':1' : 'N/A' }.`, el, `Original: ${ originalFgColorString } on ${ originalBgColorString }. Manually adjust text or background color.`, 'Perceivable', '1.4.3', false, 'AA');
							ar_loggedIssuesTracker.add(failKey)
						}
					}
				}
			} catch (e) {
				console.error('Error: ContrastRatio Check:', e, el)
			}
		});
		if (!targetElement)
			console.groupEnd()
	};
	AR_CheckModulesProto._attemptContrastFix = function (el, fgRgba, bgRgba, requiredContrast, origFgCss, origBgCss) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		function clamp(val, min, max) {
			return Math.max(min, Math.min(max, val));
		}
		function luminance([r, g, b]) {
			const norm = [
				r,
				g,
				b
			].map(v => {
				v /= 255;
				return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
			});
			return 0.2126 * norm[0] + 0.7152 * norm[1] + 0.0722 * norm[2];
		}
		function contrast(rgb1, rgb2) {
			const lum1 = luminance(rgb1);
			const lum2 = luminance(rgb2);
			return (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05);
		}
		function rgbToHsl(r, g, b) {
			r /= 255;
			g /= 255;
			b /= 255;
			const max = Math.max(r, g, b), min = Math.min(r, g, b);
			let h, s, l = (max + min) / 2;
			if (max === min) {
				h = s = 0;
			} else {
				const d = max - min;
				s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
				switch (max) {
				case r:
					h = (g - b) / d + (g < b ? 6 : 0);
					break;
				case g:
					h = (b - r) / d + 2;
					break;
				case b:
					h = (r - g) / d + 4;
					break;
				}
				h /= 6;
			}
			return [
				h,
				s,
				l
			];
		}
		function hslToRgb(h, s, l) {
			let r, g, b;
			if (s === 0)
				r = g = b = l;
			else {
				function hue2rgb(p, q, t) {
					if (t < 0)
						t += 1;
					if (t > 1)
						t -= 1;
					if (t < 1 / 6)
						return p + (q - p) * 6 * t;
					if (t < 1 / 2)
						return q;
					if (t < 2 / 3)
						return p + (q - p) * (2 / 3 - t) * 6;
					return p;
				}
				const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				const p = 2 * l - q;
				r = hue2rgb(p, q, h + 1 / 3);
				g = hue2rgb(p, q, h);
				b = hue2rgb(p, q, h - 1 / 3);
			}
			return [
				Math.round(r * 255),
				Math.round(g * 255),
				Math.round(b * 255)
			];
		}
		let currentFg = fgRgba.slice(0, 3);
		let currentBg = bgRgba.slice(0, 3);
		let c = contrast(currentFg, currentBg);
		if (c >= requiredContrast) {
			return {
				success: true,
				newFgCss: origFgCss,
				newBgCss: origBgCss,
				newContrast: c,
				strategy: 'already_ok'
			};
		}
		let bestFg = currentFg, bestBg = currentBg, bestC = c, bestFgCss = origFgCss, bestBgCss = origBgCss, bestStrategy = 'none';
		const testColors = [
			[
				0,
				0,
				0
			],
			[
				255,
				255,
				255
			]
		];
		for (const testFg of testColors) {
			let testC = contrast(testFg, currentBg);
			if (testC > bestC) {
				bestC = testC;
				bestFg = testFg;
				bestFgCss = `rgb(${ testFg.join(',') })`;
				bestStrategy = 'bw_text';
			}
		}
		if (bestC >= requiredContrast) {
			el.style.setProperty('color', bestFgCss);
			return {
				success: true,
				newFgCss: bestFgCss,
				newBgCss: origBgCss,
				newContrast: bestC,
				strategy: bestStrategy
			};
		}
		let [h, s, l] = rgbToHsl(...currentFg);
		let step = 0.02, found = false, maxSteps = 20;
		for (let i = 1; i <= maxSteps; i++) {
			let lUp = clamp(l + step * i, 0, 1), lDn = clamp(l - step * i, 0, 1);
			let tryFg1 = hslToRgb(h, s, lUp), tryFg2 = hslToRgb(h, s, lDn);
			let c1 = contrast(tryFg1, currentBg), c2 = contrast(tryFg2, currentBg);
			if (c1 > bestC) {
				bestC = c1;
				bestFg = tryFg1;
				bestFgCss = `rgb(${ tryFg1.join(',') })`;
				bestStrategy = 'hsl_text';
			}
			if (c2 > bestC) {
				bestC = c2;
				bestFg = tryFg2;
				bestFgCss = `rgb(${ tryFg2.join(',') })`;
				bestStrategy = 'hsl_text';
			}
			if (bestC >= requiredContrast) {
				el.style.setProperty('color', bestFgCss);
				return {
					success: true,
					newFgCss: bestFgCss,
					newBgCss: origBgCss,
					newContrast: bestC,
					strategy: bestStrategy
				};
			}
		}
		const nonBgChangeTags = [
			'BODY',
			'MAIN',
			'HEADER',
			'FOOTER',
			'NAV',
			'ASIDE'
		];
		if (!nonBgChangeTags.includes(el.tagName.toUpperCase())) {
			let [bh, bs, bl] = rgbToHsl(...currentBg);
			for (let i = 1; i <= maxSteps; i++) {
				let blUp = clamp(bl + step * i, 0, 1), blDn = clamp(bl - step * i, 0, 1);
				let tryBg1 = hslToRgb(bh, bs, blUp), tryBg2 = hslToRgb(bh, bs, blDn);
				for (const testFg of testColors) {
					let c1 = contrast(testFg, tryBg1);
					if (c1 > bestC) {
						bestC = c1;
						bestFg = testFg;
						bestBg = tryBg1;
						bestFgCss = `rgb(${ testFg.join(',') })`;
						bestBgCss = `rgb(${ tryBg1.join(',') })`;
						bestStrategy = 'hsl_bg_bw_text';
					}
					let c2 = contrast(testFg, tryBg2);
					if (c2 > bestC) {
						bestC = c2;
						bestFg = testFg;
						bestBg = tryBg2;
						bestFgCss = `rgb(${ testFg.join(',') })`;
						bestBgCss = `rgb(${ tryBg2.join(',') })`;
						bestStrategy = 'hsl_bg_bw_text';
					}
				}
			}
			if (bestC >= requiredContrast) {
				el.style.setProperty('color', bestFgCss);
				el.style.setProperty('background-color', bestBgCss);
				return {
					success: true,
					newFgCss: bestFgCss,
					newBgCss: bestBgCss,
					newContrast: bestC,
					strategy: bestStrategy
				};
			}
		}
		el.style.setProperty('color', origFgCss);
		if (origBgCss)
			el.style.setProperty('background-color', origBgCss);
		return {
			success: false,
			newFgCss: origFgCss,
			newBgCss: origBgCss,
			newContrast: bestC,
			strategy: 'failed'
		};
	};
	AR_CheckModulesProto.checkFormFieldLabels = function () {
		ar_logSection('Form Field Labels');
		document.querySelectorAll('input:not([type="hidden"]):not([type="submit"]):not([type="reset"]):not([type="button"]), select, textarea').forEach(field => {
			if (field.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(field) || ar_hasAccessibleNameForElement(field))
					return;
				const fieldId = field.id || ar_generateUniqueElementId('field-');
				if (!field.id)
					field.id = fieldId;
				let labelText = (field.getAttribute('title') || '').trim() || (field.placeholder || '').trim();
				if (ar_hasExplicitLabel(field) || ar_hasParentLabel(field)) {
					return
				}
				if ((field.type === 'radio' || field.type === 'checkbox') && field.nextSibling && field.nextSibling.nodeType === Node.TEXT_NODE && (field.nextSibling.textContent || '').trim().length > 0) {
					const textNode = field.nextSibling;
					const newLabel = document.createElement('label');
					newLabel.htmlFor = fieldId;
					newLabel.appendChild(document.createTextNode((textNode.textContent || '').trim()));
					textNode.parentNode.insertBefore(newLabel, textNode.nextSibling);
					textNode.parentNode.removeChild(textNode);
					ar_logAccessibilityIssue('Moderate', `Radio/checkbox missing label. Auto-wrapped adjacent text.`, field, '**Manual review required.** Ensure the label accurately describes the input.', 'Perceivable', '3.3.2 / 1.3.1', true, 'A');
					return
				}
				if (labelText) {
					ar_setAttributeAndLog(field, 'aria-label', ar_escapeHtml(labelText), 'Moderate', `Field missing label. Auto-set aria-label from title/placeholder: "${ ar_escapeHtml(labelText) }".`, '**Manual review required.** Prefer visible <label> elements.', 'Perceivable', '3.3.2', 'A')
				} else {
					const newLabel = document.createElement('label');
					newLabel.htmlFor = fieldId;
					newLabel.textContent = field.name ? `Label for ${ field.name }` : `Label for field ${ fieldId }`;
					Object.assign(newLabel.style, {
						position: 'absolute',
						left: '-9999px',
						width: '1px',
						height: '1px',
						overflow: 'hidden'
					});
					if (field.parentElement) {
						field.parentElement.insertBefore(newLabel, field);
						ar_logAccessibilityIssue('Critical', `Field missing label. Auto-added generic hidden <label>.`, field, '**Manual review required.** Provide a descriptive and visible label for this form field.', 'Perceivable', '3.3.2', true, 'A')
					} else {
						ar_logAccessibilityIssue('Critical', `Field missing label. Could not auto-add <label> (no parent element).`, field, 'Provide a visible <label> element for this form field.', 'Perceivable', '3.3.2', false, 'A')
					}
				}
			} catch (e) {
				console.error('Error: FormFieldLabels Check:', e, field)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto.checkFormValidationAria = function () {
		ar_logSection('Form Validation ARIA');
		document.querySelectorAll('input:not([type="hidden"]), select, textarea').forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				this._checkRequiredAria(el);
				this._checkInvalidAria(el)
			} catch (e) {
				console.error('Error: FormValidationAria Check:', e, el)
			}
		});
		console.groupEnd()
	};
	AR_CheckModulesProto._checkRequiredAria = function (el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		const previousSiblingText = el.previousSibling && el.previousSibling.nodeType === Node.TEXT_NODE ? el.previousSibling.textContent.trim() : '';
		const parentLabel = el.closest('label');
		const labelText = parentLabel ? (parentLabel.textContent || '').trim() : '';
		const nextSiblingText = el.nextSibling && el.nextSibling.nodeType === Node.TEXT_NODE ? el.nextSibling.textContent.trim() : '';
		if ((previousSiblingText.endsWith('*') || labelText.includes('*') || nextSiblingText.startsWith('*')) && !el.hasAttribute('required') && el.getAttribute('aria-required') !== 'true') {
			ar_setAttributeAndLog(el, 'required', '', 'Minor', 'Field visually marked as required ("*") but missing `required` attribute. Auto-added `required`.', 'Ensure required fields have both `required` and `aria-required="true"`.', 'Robust', '3.3.2 / 4.1.2', 'A')
		}
		if (el.hasAttribute('required') && el.getAttribute('aria-required') !== 'true') {
			ar_setAttributeAndLog(el, 'aria-required', 'true', 'Moderate', 'Required field missing aria-required="true". Auto-fixed.', 'Add aria-required="true" for required form fields.', 'Robust', '4.1.2', 'A')
		}
	};
	AR_CheckModulesProto._checkInvalidAria = function (el) {
		if (el.getAttribute('aria-hidden') === 'true') return;
		const ariaInvalid = el.getAttribute('aria-invalid');
		if (ariaInvalid && ![
				'true',
				'false'
			].includes(ariaInvalid.toLowerCase())) {
			ar_setAttributeAndLog(el, 'aria-invalid', 'false', 'Minor', 'aria-invalid attribute has an invalid value. Auto-set to "false".', 'Use "true" or "false" for aria-invalid.', 'Robust', '4.1.2', 'A')
		}
		if (el.getAttribute('aria-invalid') === 'true' && !el.hasAttribute('aria-describedby')) {
			let errorMsgElement = null;
			const potentialErrorSibling = el.nextElementSibling;
			if (potentialErrorSibling && ((potentialErrorSibling.className || '').toLowerCase().includes('error') || (potentialErrorSibling.className || '').toLowerCase().includes('invalid') || potentialErrorSibling.getAttribute('role') === 'alert')) {
				errorMsgElement = potentialErrorSibling;
				if (!errorMsgElement.id) {
					errorMsgElement.id = ar_generateUniqueElementId('error-msg-')
				}
			} else {
				errorMsgElement = document.createElement('span');
				errorMsgElement.id = ar_generateUniqueElementId('error-msg-');
				errorMsgElement.textContent = 'Invalid input.';
				Object.assign(errorMsgElement.style, {
					position: 'absolute',
					left: '-9999px',
					width: '1px',
					height: '1px',
					overflow: 'hidden'
				});
				errorMsgElement.setAttribute('role', 'alert');
				if (el.parentNode) {
					el.parentNode.insertBefore(errorMsgElement, el.nextSibling)
				}
			}
			if (errorMsgElement && errorMsgElement.id) {
				ar_setAttributeAndLog(el, 'aria-describedby', errorMsgElement.id, 'Minor', `Input aria-invalid="true" missing aria-describedby. Auto-linked/added error message.`, 'Ensure invalid inputs are described by an error message via aria-describedby.', 'Understandable', '3.3.1', true, 'A')
			}
		}
	};
	AR_CheckModulesProto.checkLandmarkRoles = function (globalState) {
		ar_logSection('ARIA Landmark Roles / HTML5 Semantic Elements');
		this._identifyExistingLandmarks(globalState);
		this._ensureEssentialLandmarks(globalState);
		this._checkMultipleUniqueLandmarks(globalState);
		console.groupEnd()
	};
	AR_CheckModulesProto._identifyExistingLandmarks = function (globalState) {
		AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.forEach(role => {
			globalState.detectedLandmarkRoleCounts[role] = 0
		});
		AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.forEach(tag => {
			globalState.detectedLandmarkRoleCounts[tag] = globalState.detectedLandmarkRoleCounts[tag] || 0
		});
		document.querySelectorAll('*').forEach(el => {
			if (ar_isVisuallyHidden(el))
				return;
			const role = el.getAttribute('role');
			const tagName = el.tagName.toLowerCase();
			if (role && AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.includes(role)) {
				globalState.detectedLandmarkRoleCounts[role]++
			} else if (AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.includes(tagName)) {
				const implicitRole = {
					'main': 'main',
					'header': 'banner',
					'footer': 'contentinfo',
					'nav': 'navigation',
					'aside': 'complementary',
					'form': 'form',
					'section': el.hasAttribute('aria-label') || el.hasAttribute('aria-labelledby') ? 'region' : null
				}[tagName];
				if (implicitRole)
					globalState.detectedLandmarkRoleCounts[implicitRole]++
			}
		})
	};
	AR_CheckModulesProto._ensureEssentialLandmark = function (globalState, landmarkName, config) {
		const {selector, htmlTag, role, placement, contentHeuristic} = config;
		const body = document.body;
		if (globalState.detectedLandmarkRoleCounts[landmarkName] === 0) {
			let candidateElement = document.querySelector(htmlTag) || document.querySelector(`[role="${ role }"]`) || document.querySelector(selector);
			if (candidateElement) {
				if (candidateElement.tagName.toLowerCase() !== htmlTag && !candidateElement.getAttribute('role')) {
					ar_setAttributeAndLog(candidateElement, 'role', role, 'Moderate', `Missing ${ landmarkName } landmark. Auto-added role to <${ candidateElement.tagName.toLowerCase() }>.`, `Use <${ htmlTag }> or role="${ role }".`, 'Perceivable', '1.3.1', 'A');
					globalState.detectedLandmarkRoleCounts[landmarkName]++
				} else if (candidateElement.tagName.toLowerCase() === htmlTag && !candidateElement.getAttribute('role') && role !== htmlTag && landmarkName === role) {
					ar_setAttributeAndLog(candidateElement, 'role', role, 'Info', `<${ htmlTag }> candidate for ${ landmarkName }. Auto-added explicit role.`, `Consider explicit role for clarity.`, 'Perceivable', '1.3.1', 'A');
					globalState.detectedLandmarkRoleCounts[landmarkName]++
				} else if (!globalState.detectedLandmarkRoleCounts[landmarkName]) {
					globalState.detectedLandmarkRoleCounts[landmarkName]++
				}
			} else {
				const newLandmark = document.createElement(htmlTag);
				if (role !== htmlTag && role)
					newLandmark.setAttribute('role', role);
				let contentMoved = false;
				if (contentHeuristic) {
					const bodyChildren = Array.from(body.children);
					const headerEl = body.querySelector(AR_CheckModules._landmarkConfigs.banner.htmlTag + ', [role=banner]');
					const navEl = body.querySelector(AR_CheckModules._landmarkConfigs.navigation.htmlTag + ', [role=navigation]');
					const footerEl = body.querySelector(AR_CheckModules._landmarkConfigs.contentinfo.htmlTag + ', [role=contentinfo]');
					const childrenToMove = contentHeuristic(bodyChildren, headerEl, navEl, footerEl);
					if (childrenToMove.length > 0) {
						childrenToMove.forEach(child => {
							if (child.parentNode === body && child !== newLandmark && ![
									'SCRIPT',
									'STYLE',
									'LINK'
								].includes(child.tagName) && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID && !child.closest(AR_CheckModules._landmarkConfigs.banner.htmlTag) && !child.closest(AR_CheckModules._landmarkConfigs.navigation.htmlTag) && !child.closest(AR_CheckModules._landmarkConfigs.contentinfo.htmlTag) && !(child.tagName.toLowerCase() === 'main' && landmarkName !== 'main')) {
								newLandmark.appendChild(child);
								contentMoved = true
							}
						})
					}
				}
				if (placement === 'prepend' && body.firstChild)
					body.insertBefore(newLandmark, body.firstChild);
				else if (placement === 'append')
					body.appendChild(newLandmark);
				else if (placement === 'afterHeader') {
					const headerRef = body.querySelector(AR_CheckModules._landmarkConfigs.banner.htmlTag + ', [role=banner]');
					if (headerRef && headerRef.nextSibling)
						body.insertBefore(newLandmark, headerRef.nextSibling);
					else if (body.firstChild)
						body.insertBefore(newLandmark, body.firstChild);
					else
						body.appendChild(newLandmark)
				} else if (placement === 'beforeFooter') {
					const footerRef = body.querySelector(AR_CheckModules._landmarkConfigs.contentinfo.htmlTag + ', [role=contentinfo]');
					if (footerRef)
						body.insertBefore(newLandmark, footerRef);
					else
						body.appendChild(newLandmark)
				} else
					body.appendChild(newLandmark);
				ar_logAccessibilityIssue('Moderate', `Missing "${ landmarkName }" landmark. Aggressively Auto-created <${ htmlTag }>${ contentMoved ? ' and wrapped existing content.' : '.' }`, newLandmark, 'Verify the auto-generated structure. This is a significant DOM change.', 'Perceivable', '1.3.1', true, 'A');
				globalState.detectedLandmarkRoleCounts[landmarkName]++
			}
		}
	};
	AR_CheckModulesProto._landmarkConfigs = {
		'banner': {
			selector: AR_SELECTOR_STRINGS.COMMON_HEADER_SELECTORS,
			htmlTag: 'header',
			role: 'banner',
			placement: 'prepend',
			contentHeuristic: children => children.filter(c => c.tagName.toLowerCase() !== 'script' && c.tagName.toLowerCase() !== 'style' && c.tagName.toLowerCase() !== 'link' && !c.id.includes(AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID) && !c.id.includes(AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID)).slice(0, Math.min(children.length, 3))
		},
		'navigation': {
			selector: AR_SELECTOR_STRINGS.COMMON_NAV_SELECTORS,
			htmlTag: 'nav',
			role: 'navigation',
			placement: 'afterHeader',
			contentHeuristic: children => {
				const navCand = children.find(c => c.tagName === 'UL' && c.querySelectorAll('li > a[href]').length > 2);
				return navCand ? [navCand] : []
			}
		},
		'main': {
			selector: AR_SELECTOR_STRINGS.MAIN_CONTENT_TARGET_SELECTORS,
			htmlTag: 'main',
			role: 'main',
			placement: 'beforeFooter',
			contentHeuristic: (children, header, nav, footer) => {
				const mainContent = [];
				let inMainSection = false;
				for (const child of children) {
					if (child === header || child === nav || child.id === AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID || child.id === AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID || [
							'SCRIPT',
							'STYLE',
							'LINK'
						].includes(child.tagName)) {
						if (!inMainSection && child !== header && child !== nav) {
							continue
						}
					}
					if (child === footer) {
						break
					}
					inMainSection = true;
					mainContent.push(child)
				}
				return mainContent.length > 0 ? mainContent : children.filter(c => c !== header && c !== nav && c !== footer && ![
					'SCRIPT',
					'STYLE'
				].includes(c.tagName) && c.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && c.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID).slice(0, Math.max(1, children.length - (header ? 1 : 0) - (nav ? 1 : 0) - (footer ? 1 : 0) - 2))
			}
		},
		'contentinfo': {
			selector: AR_SELECTOR_STRINGS.COMMON_FOOTER_SELECTORS,
			htmlTag: 'footer',
			role: 'contentinfo',
			placement: 'append',
			contentHeuristic: children => children.length > 1 ? children.slice(Math.max(0, children.length - 2)) : children
		}
	};
	AR_CheckModulesProto._ensureEssentialLandmarks = function (globalState) {
		for (const landmarkName in this._landmarkConfigs) {
			this._ensureEssentialLandmark(globalState, landmarkName, this._landmarkConfigs[landmarkName])
		}
	};
	AR_CheckModulesProto._checkMultipleUniqueLandmarks = function (globalState) {
		[
			'main',
			'banner',
			'contentinfo'
		].forEach(roleName => {
			if (globalState.detectedLandmarkRoleCounts[roleName] > 1) {
				const elements = document.querySelectorAll(`${ this._landmarkConfigs[roleName].htmlTag }, [role="${ roleName }"]`);
				ar_logAccessibilityIssue('Minor', `Multiple "${ roleName }" landmarks (${ globalState.detectedLandmarkRoleCounts[roleName] }).`, elements.length > 0 ? elements[0] : document.body, `There should typically be only one "${ roleName }" landmark per page. Consider consolidating or using other roles.`, 'Perceivable', '1.3.1 / 2.4.1', false, 'A')
			}
		})
	};
	AR_CheckModulesProto.checkFocusIndicators = function () {
		ar_logSection('Focus Indicators');
		let styleTag = document.getElementById('ar-focus-style');
		if (!styleTag) {
			styleTag = document.createElement('style');
			styleTag.id = 'ar-focus-style';
			styleTag.textContent = `${ AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS.split(',').map(s => `${ s.trim() }:focus-visible`).join(',\n') } { outline: 3px solid #0056b3 !important; outline-offset: 2px !important; box-shadow: 0 0 0 3px rgba(112, 161, 255, 0.5) !important; }`;
			document.head.appendChild(styleTag);
			ar_logAccessibilityIssue('Info', 'Injected global CSS for :focus-visible. This provides a default focus indicator.', styleTag, 'Review custom focus styles to ensure they are visible and meet WCAG 2.4.7.', 'Operable', '2.4.7 / 2.4.11', true, 'AA')
		}
		document.querySelectorAll(AR_SELECTOR_STRINGS.INTERACTIVE_ELEMENTS).forEach(el => {
			if (el.getAttribute('aria-hidden') === 'true') return;
			try {
				if (ar_isVisuallyHidden(el))
					return;
				const computedStyle = window.getComputedStyle(el);
				const defaultOutlineNone = computedStyle.outlineStyle === 'none' || parseFloat(computedStyle.outlineWidth) === 0;
				const defaultBoxShadowNone = computedStyle.boxShadow === 'none' || computedStyle.boxShadow === '';
				if (defaultOutlineNone && defaultBoxShadowNone) {
					if (el.style.outline === 'none !important' || el.style.outlineStyle === 'none' && el.style.getPropertyPriority('outline-style') === 'important') {
						ar_logAccessibilityIssue('Moderate', 'Element has `outline: none !important;`. This can override default focus indicators.', el, 'Avoid using `!important` to remove outlines. Ensure a visible focus indicator is provided via `:focus-visible`.', 'Operable', '2.4.7', false, 'AA')
					}
				}
			} catch (e) {
				console.error('Error: FocusIndicators Check:', e, el)
			}
		});
		console.log('\n\uD83D\uDCA1 Manual Verification for Focus Indicators is CRUCIAL. Ensure custom focus styles are clearly visible and meet WCAG 2.4.7 and 2.4.11.');
		console.groupEnd()
	};
	AR_CheckModulesProto.checkSkipLinks = function (globalState) {
		ar_logSection('Skip Link');
		const existingSkipLink = document.querySelector('a[href^="#"]:first-child, a.skip-link:first-child, [data-skip-link="true"]:first-child');
		if (!existingSkipLink || ar_isVisuallyHidden(existingSkipLink)) {
			const newSkipLink = this._createSkipLinkElement();
			let mainContentTarget = this._findMainContentTarget();
			if (mainContentTarget) {
				if (!mainContentTarget.id)
					mainContentTarget.id = ar_generateUniqueElementId('main-content-target-');
				if (mainContentTarget.getAttribute('tabindex') === null && !mainContentTarget.matches(AR_SELECTOR_STRINGS.NATIVE_INTERACTIVE_TAGS) && mainContentTarget.getAttribute('role') !== 'region' && mainContentTarget.tagName !== 'MAIN') {
					ar_setAttributeAndLog(mainContentTarget, 'tabindex', '-1', 'Info', 'Main content target for skip link made focusable (tabindex="-1").', 'Ensure the main content area is focusable for skip links to work correctly.', 'Operable', '2.4.1', true, 'A')
				}
				newSkipLink.href = `#${ mainContentTarget.id }`;
				document.body.prepend(newSkipLink);
				ar_logAccessibilityIssue('Moderate', 'No visible "skip to main content" link found. Auto-injected.', newSkipLink, 'Ensure the skip link is the first focusable element, is visible on focus, and targets the main content area.', 'Operable', '2.4.1', true, 'A')
			} else {
				ar_logAccessibilityIssue('Moderate', 'No "skip to main content" link found and no clear main content target identified.', document.body, 'Implement a "skip to main content" link that targets the primary content area of the page.', 'Operable', '2.4.1', false, 'A')
			}
		}
		console.groupEnd()
	};
	AR_CheckModulesProto._createSkipLinkElement = function () {
		const skipLink = document.createElement('a');
		skipLink.textContent = 'Skip to main content';
		Object.assign(skipLink.style, {
			position: 'absolute',
			left: '-9999px',
			top: 'auto',
			width: '1px',
			height: '1px',
			overflow: 'hidden',
			zIndex: '99999',
			padding: '0.5em 1em',
			backgroundColor: '#f0f0f0',
			color: '#333',
			textDecoration: 'none',
			borderRadius: '3px',
			border: '1px solid #ccc',
			transition: 'left 0s 0.3s, top 0s 0.3s'
		});
		skipLink.onfocus = function () {
			Object.assign(this.style, {
				left: '10px',
				top: '10px',
				width: 'auto',
				height: 'auto',
				zIndex: '2147483647',
				boxShadow: '0 0 10px rgba(0,0,0,0.5)',
				transitionDelay: '0s'
			})
		};
		skipLink.onblur = function () {
			Object.assign(this.style, {
				left: '-9999px',
				top: 'auto',
				width: '1px',
				height: '1px',
				zIndex: '99999',
				boxShadow: 'none',
				transitionDelay: '0s 0.3s'
			})
		};
		return skipLink
	};
	AR_CheckModulesProto._findMainContentTarget = function () {
		let target = document.querySelector(AR_SELECTOR_STRINGS.MAIN_CONTENT_TARGET_SELECTORS) || document.querySelector('article') || document.querySelector('section[aria-label], section[aria-labelledby]');
		if (!target) {
			for (let i = 0; i < document.body.children.length; i++) {
				const child = document.body.children[i];
				if (!child.matches('script, style, link') && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_BUTTON_ID && child.id !== AR_CONFIG.ACCESSIBILITY_MENU_PANEL_ID && !child.classList.contains('skip-link')) {
					target = child;
					break
				}
			}
		}
		return target
	};
	AR_CheckModulesProto.checkDocumentGlobals = function () {
		ar_logSection('Global Document Setup');
		const head = document.head;
		const body = document.body;
		this._checkDocumentTitle(head, body);
		this._checkViewportMeta(head);
		this._checkMetaRefresh(head);
		if (!head.querySelector('#ar-focus-style'))
			AR_CheckModules.checkFocusIndicators();
		console.groupEnd()
	};
	AR_CheckModulesProto._checkDocumentTitle = function (head, body) {
		const titleElement = head.querySelector('title');
		if (!titleElement || !(titleElement.textContent || '').trim()) {
			const h1 = body.querySelector('h1');
			const h1Text = h1 && h1.textContent ? h1.textContent.trim().substring(0, 60) : '';
			let newTitleText = (h1Text || 'Untitled Page') + (h1Text ? '' : ' - AutoTitle');
			let newTitleEl = titleElement || document.createElement('title');
			ar_setAttributeAndLog(newTitleEl, 'textContent', ar_escapeHtml(newTitleText), 'Critical', `Document title missing or empty. Auto-generated: "${ ar_escapeHtml(newTitleText) }".`, '**Manual review required.** Provide a descriptive and unique title for the page.', 'Operable', '2.4.2 Page Titled', 'A');
			if (!titleElement)
				head.appendChild(newTitleEl)
		}
	};
	AR_CheckModulesProto._checkViewportMeta = function (head) {
		let viewportMeta = head.querySelector('meta[name="viewport"]');
		const currentContent = viewportMeta ? viewportMeta.content : '';
		let newContent = currentContent;
		let issueFound = false;
		if (!viewportMeta || !currentContent) {
			newContent = 'width=device-width, initial-scale=1.0, user-scalable=yes';
			issueFound = true;
			if (!viewportMeta) {
				viewportMeta = document.createElement('meta');
				viewportMeta.name = 'viewport';
				head.appendChild(viewportMeta)
			}
			ar_setAttributeAndLog(viewportMeta, 'content', newContent, 'Critical', 'Viewport meta tag missing or empty. Auto-added responsive viewport.', 'Ensure a proper viewport meta tag is present for responsive design and user zoom.', 'Perceivable', '1.4.10 / 1.4.4', 'AA');
			return
		}
		if (!currentContent.includes('width=device-width')) {
			newContent = `width=device-width${ newContent.length > 0 ? ',' : '' }${ newContent }`;
			issueFound = true
		}
		if (!/initial-scale\s*=\s*1(\.0*)?/.test(currentContent)) {
			newContent = `${ newContent }${ newContent.length > 0 ? ',' : '' }initial-scale=1.0`;
			issueFound = true
		}
		if (currentContent.includes('user-scalable=no')) {
			newContent = newContent.replace(/user-scalable=no[,]?/g, '');
			issueFound = true
		}
		if (/maximum-scale\s*=\s*1(\.0*)?/.test(currentContent)) {
			newContent = newContent.replace(/maximum-scale\s*=\s*1(\.0*)?[,]?/g, '');
			issueFound = true
		}
		if (!newContent.includes('user-scalable=yes') && !newContent.includes('user-scalable=no')) {
			newContent = `${ newContent }${ newContent.length > 0 ? ',' : '' }user-scalable=yes`;
			issueFound = true
		}
		newContent = newContent.replace(/,{2,}/g, ',').replace(/,\s*$/, '').trim();
		if (issueFound && newContent !== currentContent) {
			ar_setAttributeAndLog(viewportMeta, 'content', newContent, 'Moderate', `Viewport meta tag improper. Auto-corrected to "${ newContent }".`, 'Avoid `user-scalable=no` or `maximum-scale=1.0` to allow users to zoom.', 'Perceivable', '1.4.4 / 1.4.10', 'AA')
		}
	};
	AR_CheckModulesProto._checkMetaRefresh = function (head) {
		const metaRefresh = head.querySelector('meta[http-equiv="refresh"]');
		if (metaRefresh) {
			ar_logAccessibilityIssue('Critical', 'Meta refresh tag found. This can disorient users.', metaRefresh, 'Avoid using meta refresh. Use server-side redirects or JavaScript with user controls for timed updates.', 'Operable', '2.2.1 / 2.2.4', false, 'A')
		}
	}
}(AR_CheckModules))

function ar_setupMutationObserverForContrast() {
	const observer = new MutationObserver(mutationsList => {
		for (const mutation of mutationsList) {
			if (mutation.type === 'attributes' && (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
				if (mutation.target.nodeType === Node.ELEMENT_NODE) {
					AR_CheckModules.checkContrastRatioForAllElements(mutation.target)
				}
			} else if (mutation.type === 'childList') {
				mutation.addedNodes.forEach(node => {
					if (node.nodeType === Node.ELEMENT_NODE) {
						AR_CheckModules.checkContrastRatioForAllElements(node);
						node.querySelectorAll('*').forEach(descendant => AR_CheckModules.checkContrastRatioForAllElements(descendant))
					}
				})
			}
		}
	});
	observer.observe(document.body, {
		attributes: true,
		childList: true,
		subtree: true,
		attributeFilter: [
			'style',
			'class'
		]
	});
	console.log('\uD83D\uDCA1 MutationObserver for live contrast changes is active.')
}
async function ar_runAccessibilityScan() {
	ar_loggedIssuesTracker.clear();
	ar_accessibilityIssuesLog.length = 0;
	ar_totalScannedIssuesCounter = 0;
	ar_totalAutoFixedIssuesCounter = 0;
	console.log('%c Accessibility Resolver ', 'background:#0056b3;color:white;font-size:1.5em;font-weight:bold;padding:10px 20px;border-radius:5px;');
	console.log('Scanning for accessibility issues and applying auto-fixes...');
	console.time('AccessibilityScanDuration');
	const docElement = document.documentElement;
	const globalState = {
		lastHeadingLevel: 0,
		seenIds: new Map(),
		detectedLandmarkRoleCounts: {}
	};
	AR_SELECTOR_STRINGS.LANDMARK_ROLES_ARRAY.forEach(role => {
		globalState.detectedLandmarkRoleCounts[role] = 0
	});
	AR_SELECTOR_STRINGS.LANDMARK_HTML_TAGS_ARRAY.forEach(tag => {
		globalState.detectedLandmarkRoleCounts[tag] = globalState.detectedLandmarkRoleCounts[tag] || 0
	});
	AR_CheckModules.checkDocumentGlobals();
	AR_CheckModules.checkLangAttribute();
	AR_CheckModules.checkSkipLinks(globalState);
	AR_CheckModules.checkContentStructure(globalState);
	AR_CheckModules.checkMediaIntegrity();
	AR_CheckModules.checkImageAltText();
	AR_CheckModules.checkIframeTitles();
	AR_CheckModules.checkTableAccessibility();
	AR_CheckModules.checkOverlayFocusBlocking();
	AR_CheckModules.checkInteractiveElementSize();
	AR_CheckModules.checkAriaMisuse();
	AR_CheckModules.checkHoverFocusContent();
	AR_CheckModules.checkAutoFormSubmission();
	AR_CheckModules.checkDuplicateIds(globalState);
	AR_CheckModules.checkAccessibleNames();
	AR_CheckModules.checkTabindexUsage();
	AR_CheckModules.checkContrastRatioForAllElements();
	AR_CheckModules.checkFormFieldLabels();
	AR_CheckModules.checkFormValidationAria();
	AR_CheckModules.checkLandmarkRoles(globalState);
	AR_CheckModules.checkFocusIndicators();
	ar_setupMutationObserverForContrast();
	console.log('\n%c Accessibility Check and Auto-Fix Summary ', 'font-size:1.3em;font-weight:bold;color:#003973;padding:5px;background:#e3f2fd;border-bottom:2px solid #003973;display:block;text-align:center;');
	const unresolvedIssues = ar_accessibilityIssuesLog.filter(r => !r.isAutofixed);
	console.log(`%cTotal Issues Identified: %c${ ar_accessibilityIssuesLog.length }`, 'font-weight:bold;', 'font-weight:normal;');
	console.log(`%cAuto-Fixed: %c${ ar_totalAutoFixedIssuesCounter }`, 'font-weight:bold;color:green;', `font-weight:normal;color:${ ar_totalAutoFixedIssuesCounter > 0 ? 'green' : 'grey' };`);
	console.log(`%cUnresolved: %c${ unresolvedIssues.length }`, 'font-weight:bold;color:red;', `font-weight:normal;color:${ unresolvedIssues.length > 0 ? 'red' : 'green' };`);
	[
		'Critical',
		'Moderate',
		'Minor',
		'Info'
	].forEach(severity => {
		const issues = unresolvedIssues.filter(r => r.severity === severity && r.wcagLevel !== 'User');
		if (issues.length > 0) {
			const colorMap = {
				'Critical': '#c62828',
				'Moderate': '#ef6c00',
				'Minor': '#0277bd',
				'Info': '#546e7a'
			};
			console.groupCollapsed(`%c ${ severity } Unresolved: ${ issues.length } `, `color:white;background-color:${ colorMap[severity] };padding:3px 7px;border-radius:3px;font-weight:bold;`);
			issues.forEach(issue => {
				console.log(`%cMessage: %c${ issue.message }`, 'font-weight:bold;', '');
				if (issue.element instanceof HTMLElement)
					console.log('%cElement:', 'font-style:italic;', issue.element);
				if (issue.recommendation)
					console.log(`%cRecommendation: %c${ issue.recommendation }`, 'font-style:italic;color:#01579b;', '');
				if (issue.wcagGuideline)
					console.log(`%cWCAG: %c${ issue.wcagGuideline } (${ issue.wcagLevel })`, 'font-style:italic;color:#311b92;', '');
				console.log('---')
			});
			console.groupEnd()
		}
	});
	if (unresolvedIssues.filter(r => r.wcagLevel !== 'User').length > 0) {
		console.log("\n%cReview unresolved issues by expanding the groups above. The 'accessibilityScanGlobalResults' object in the console contains all findings.", 'color:#01579b;');
		window.accessibilityScanGlobalResults = ar_accessibilityIssuesLog
	} else if (ar_accessibilityIssuesLog.filter(r => r.wcagLevel !== 'User' && !r.isAutofixed).length === 0) {
		console.log('%c\uD83C\uDF89 All identified automated accessibility issues were either fixed or not detected in this scan!', 'color:green;font-weight:bold;font-size:1.1em;')
	}
	console.timeEnd('AccessibilityScanDuration');
	const generalObserver = new MutationObserver(() => {
		clearTimeout(ar_mainMutationObserverDebounceTimeout);
		ar_mainMutationObserverDebounceTimeout = setTimeout(() => {
			generalObserver.disconnect();
			console.warn('%cDOM has changed significantly. Re-run Accessibility Resolver for an accurate report.', 'color:orange;font-weight:bold;background:lightyellow;padding:5px;')
		}, AR_CONFIG.MUTATION_OBSERVER_DEBOUNCE_MILLISECONDS)
	});
	generalObserver.observe(docElement, {
		attributes: true,
		childList: true,
		subtree: true,
		characterData: true,
		attributeFilter: [
			'style',
			'class',
			'alt',
			'href',
			'role',
			'tabindex',
			'aria-hidden',
			'aria-label',
			'id',
			'for',
			'value',
			'src',
			'lang',
			'title'
		]
	})
}

function ar_initializeAndRunMerged() {
	console.log('%c Made by Yaron Koresh ', 'background:#4CAF50;color:white;font-size:1em;font-weight:bold;padding:5px 10px;border-radius:3px;');
	if (typeof AR_AccessibilityMenu.init !== 'function') {
		console.error('AR_AccessibilityMenu.init is not defined. Check script loading order for ar_menu_ui.js and ar_menu_actions.js.');
		return
	}
	if (typeof AR_CheckModules.checkDocumentGlobals !== 'function') {
		console.error('AR_CheckModules methods are not defined. Check script loading order for ar_check_modules_part1/2.js.');
		return
	}
	setDeviceOrientation();
	setDeviceType();
	const device = getDevice();
	//if(!device.includes('mobile')){
		AR_AccessibilityMenu.init();
	//}
	ar_runAccessibilityScan();
}

if (document.readyState === 'complete') {
	ar_initializeAndRunMerged();
} else {
	document.addEventListener('readystatechange', () => {
		if (document.readyState === 'complete') {
			ar_initializeAndRunMerged();
		}
	});
}
