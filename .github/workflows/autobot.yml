name: Autobot Manager

on:
  issues:
    types: [opened, closed, reopened]
  pull_request:
    types: [opened, closed, synchronize]
    branches: [main]

permissions:
  contents: write
  issues: write
  pull-requests: write
  models: read

jobs:
  project-manager:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Apply File/Branch Labels
        if: github.event_name == 'pull_request'
        uses: actions/labeler@v6
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
          sync-labels: false

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PHASE 1 â€” Collect raw changes (diff + file metadata)
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Collect PR Changes
        if: >-
          github.event_name == 'pull_request' &&
          github.event.action != 'closed'
        id: collect
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;

            // â”€â”€ Fetch changed files with metadata â”€â”€
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number: pr.number, per_page: 100
            });

            const fileManifest = files.map(f =>
              `[${f.status.toUpperCase()}] ${f.filename} (+${f.additions} -${f.deletions})`
            ).join('\n');

            const totalAdditions = files.reduce((s, f) => s + f.additions, 0);
            const totalDeletions = files.reduce((s, f) => s + f.deletions, 0);
            const fileExtensions = [...new Set(files.map(f => f.filename.includes('.') ? f.filename.split('.').pop() : '(none)'))];
            const topDirs = [...new Set(files.map(f => {
              const parts = f.filename.split('/');
              parts.pop();
              return parts.length > 0 ? parts.slice(0, 2).join('/') : '(root)';
            }))];

            // â”€â”€ Fetch unified diff â”€â”€
            const { data: rawDiff } = await github.rest.pulls.get({
              owner, repo, pull_number: pr.number,
              mediaType: { format: 'diff' }
            });

            // â”€â”€ Smart truncation â€” keep all file headers, trim large hunks â”€â”€
            const MAX_DIFF_CHARS = 48000;
            let diff = rawDiff;
            if (diff.length > MAX_DIFF_CHARS) {
              const segments = diff.split(/^diff --git /m).filter(Boolean);
              const budget = Math.floor(MAX_DIFF_CHARS / segments.length);
              diff = segments.map(seg => {
                const content = 'diff --git ' + seg;
                return content.length > budget
                  ? content.substring(0, budget) + '\n[â€¦truncated â€” file diff too largeâ€¦]\n'
                  : content;
              }).join('');
            }

            // â”€â”€ Compose the summary-generation prompt â”€â”€
            const summaryPrompt = [
              'You are a principal software engineer performing a meticulous technical analysis of a pull request.',
              'You will receive ONLY the raw code diff and a file manifest. Do NOT hallucinate features that are not in the diff.',
              'Do NOT reference any PR title or description â€” they were written by a human and are intentionally excluded.',
              '',
              'Generate a comprehensive, highly-detailed Markdown report using EXACTLY this structure:',
              '',
              '## ğŸ” Pull Request Analysis',
              '',
              '### ğŸ“ Executive Summary',
              'A concise 3â€“5 sentence overview of the purpose and scope of these changes.',
              '',
              '### ğŸ“ Changed Files Breakdown',
              'Group modified files by category (source, tests, config, docs, assets, migrations, CI, etc.).',
              'For each file, state what changed and why it matters. Use a table if more than 5 files.',
              '',
              '### ğŸ”§ Technical Changes â€” Detailed',
              'Walk through every meaningful code change:',
              '- New functions, methods, classes, types, or interfaces introduced',
              '- Modified signatures, return types, or behavioral contracts',
              '- Deleted code and the likely rationale',
              '- Algorithm, data-structure, or logic changes',
              '- New or changed API endpoints / routes / GraphQL resolvers',
              '- State management changes (stores, reducers, context, signals)',
              '- Error handling additions or modifications',
              '- New or modified environment variables, feature flags, or configuration',
              '',
              '### ğŸ—ï¸ Architecture & Design Impact',
              '- Module or package boundary shifts',
              '- Coupling and cohesion observations',
              '- Data flow or control flow changes',
              '- New or removed dependencies (packages, internal modules)',
              '- Design pattern introductions or removals',
              '',
              '### ğŸ”’ Security Observations',
              'Note any security-relevant changes: auth, crypto, input validation, secrets, CSP, CORS, etc.',
              'If none, write "No security-relevant changes detected."',
              '',
              '### âš¡ Performance Observations',
              'Note any perf-relevant changes: caching, lazy loading, query optimization, bundle size, memoization, concurrency, etc.',
              'If none, write "No performance-relevant changes detected."',
              '',
              '### âš ï¸ Risk Assessment',
              '| Dimension | Rating | Details |',
              '|-----------|--------|---------|',
              '| Breaking-change risk | ğŸŸ¢ LOW / ğŸŸ¡ MEDIUM / ğŸ”´ HIGH | â€¦ |',
              '| Regression risk | ğŸŸ¢ LOW / ğŸŸ¡ MEDIUM / ğŸ”´ HIGH | â€¦ |',
              '| Security risk | ğŸŸ¢ LOW / ğŸŸ¡ MEDIUM / ğŸ”´ HIGH | â€¦ |',
              '| Data-loss risk | ğŸŸ¢ LOW / ğŸŸ¡ MEDIUM / ğŸ”´ HIGH | â€¦ |',
              '',
              'List specific edge cases or scenarios that reviewers should test manually.',
              '',
              '### ğŸ§ª Testing Impact',
              '- New or updated test files and what they cover',
              '- Estimated coverage impact',
              '- Recommended additional tests that should be written',
              '',
              '### ğŸ“Š Change Metrics',
              '| Metric | Value |',
              '|--------|-------|',
              '| Complexity | TRIVIAL Â· SIMPLE Â· MODERATE Â· COMPLEX Â· CRITICAL |',
              '| Review effort | QUICK Â· STANDARD Â· THOROUGH Â· DEEP-DIVE |',
              '| Scope | NARROW Â· MODERATE Â· BROAD Â· SWEEPING |',
              '',
              '### ğŸ’¡ Reviewer Tips',
              'Give 2-4 concrete suggestions on what to focus on during review.',
              '',
              '---',
              '',
              'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
              'FILE MANIFEST (' + files.length + ' files, +' + totalAdditions + ' -' + totalDeletions + ')',
              'Extensions: ' + fileExtensions.join(', '),
              'Directories: ' + topDirs.join(', '),
              'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
              fileManifest,
              '',
              'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
              'UNIFIED DIFF',
              'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
              diff
            ].join('\n');

            fs.writeFileSync('/tmp/summary_prompt.txt', summaryPrompt);
            core.setOutput('has_changes', 'true');
            core.setOutput('files_changed', String(files.length));
            core.setOutput('additions', String(totalAdditions));
            core.setOutput('deletions', String(totalDeletions));

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PHASE 2 â€” AI: Generate rich summary from diff only
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: AI â€” Generate Change Summary
        if: steps.collect.outputs.has_changes == 'true'
        id: ai-summary
        uses: actions/ai-inference@v2
        with:
          model: openai/gpt-4o
          prompt-file: /tmp/summary_prompt.txt

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PHASE 3 â€” Build label-classification prompt from AI summary
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Build Label Prompt
        if: steps.collect.outputs.has_changes == 'true'
        id: label-prompt
        env:
          AI_SUMMARY: ${{ steps.ai-summary.outputs.response }}
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const summary = process.env.AI_SUMMARY || '';

            const prompt = [
              'You are an expert issue/PR classifier. You will receive an AI-generated technical summary of code changes.',
              'Based ONLY on the summary below, assign every applicable label from the allowed list.',
              '',
              'RULES:',
              '- Assign ALL labels that genuinely apply â€” do not under-label or over-label.',
              '- Use the descriptions to decide. A label applies when the summary provides clear evidence for it.',
              '- Return ONLY a valid JSON array of label name strings. No markdown, no explanation, no extra text.',
              '- If nothing fits, return an empty array: []',
              '',
              'ALLOWED LABELS (name â†’ when to apply):',
              '',
              'bug              â†’ Fixes incorrect behavior, crashes, regressions, error handling that was wrong',
              'enhancement      â†’ Adds new user-visible features, capabilities, or meaningful improvements',
              'documentation    â†’ Changes docs, READMEs, comments, JSDoc/Javadoc, changelogs, guides',
              'breaking-change  â†’ Removes or changes public API surfaces, drops backward compatibility, major rewrites',
              'ui               â†’ Visual/UI/UX changes: CSS, layouts, themes, design tokens, components styling',
              'performance      â†’ Optimizations: caching, lazy-loading, memoization, query tuning, bundle size',
              'security         â†’ Auth, crypto, secrets, XSS/CSRF fixes, CVE patches, input sanitization',
              'refactor         â†’ Restructures code without changing external behavior: renames, extractions, simplifications',
              'test             â†’ Adds, fixes, or improves tests (unit, integration, e2e, snapshots, mocks)',
              'ci               â†’ CI/CD pipelines, GitHub Actions, Docker, Kubernetes, deployment configs',
              'dependencies     â†’ Bumps, adds, or removes third-party packages or internal dependency changes',
              'database         â†’ Schema migrations, query changes, ORM models, indexes, seeds, DB config',
              'build            â†’ Build tooling: bundlers (webpack/vite/rollup), compilers, tsconfig, babel',
              'accessibility    â†’ A11y improvements: ARIA, screen-reader, focus management, WCAG, contrast',
              'localization     â†’ i18n/l10n: translations, locale files, date/number formatting, RTL support',
              'api              â†’ REST/GraphQL/gRPC endpoint changes, request/response schemas, middleware',
              'infrastructure   â†’ Cloud infra, IaC (Terraform/Pulumi), networking, DNS, load balancing, certs',
              'config           â†’ App configuration changes: env vars, feature flags, settings files',
              'types            â†’ TypeScript types/interfaces, schema definitions, type-only changes',
              'logging          â†’ Logging, monitoring, observability, tracing, error reporting, analytics',
              'deprecation      â†’ Marks features/APIs as deprecated with migration paths',
              '',
              'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
              'AI-GENERATED CHANGE SUMMARY:',
              'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
              summary
            ].join('\n');

            fs.writeFileSync('/tmp/label_prompt.txt', prompt);
            core.setOutput('ready', 'true');

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PHASE 4 â€” AI: Classify labels from the summary only
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: AI â€” Classify Labels
        if: steps.label-prompt.outputs.ready == 'true'
        id: ai-labels
        uses: actions/ai-inference@v2
        with:
          model: openai/gpt-4o
          prompt-file: /tmp/label_prompt.txt

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PHASE 5 â€” Apply labels, post comment, manage milestones
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Manage Project
        env:
          AI_SUMMARY: ${{ steps.ai-summary.outputs.response }}
          AI_LABELS_RAW: ${{ steps.ai-labels.outputs.response }}
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const payload = context.payload;
            const issueNumber = context.issue.number;
            const isPR = context.eventName === 'pull_request';

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CONFIGURATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            const MIN_RELEASE_SIZE = 3;
            const FORCE_RELEASE_TYPES = ['enhancement', 'breaking-change', 'security'];
            const IGNORE_LABELS = ['documentation', 'chore', 'test', 'ci', 'refactor', 'dependencies', 'build', 'types', 'config', 'logging'];
            const BOT_COMMENT_SIGNATURE = '<!-- autobot-ai-summary -->';

            const labelDefinitions = {
              'bug':             { color: 'd73a4a', description: "Something isn't working" },
              'enhancement':     { color: 'a2eeef', description: "New feature or request" },
              'documentation':   { color: '0075ca', description: "Improvements or additions to documentation" },
              'breaking-change': { color: 'b60205', description: "Incompatible API changes" },
              'ui':              { color: 'd4c5f9', description: "Visual or UI/UX improvements" },
              'performance':     { color: '5319e7', description: "Performance improvements" },
              'security':        { color: 'e30c0c', description: "Security fixes and updates" },
              'refactor':        { color: 'f29513', description: "Code change that neither fixes a bug nor adds a feature" },
              'test':            { color: 'cc317c', description: "Adding, missing, or correcting tests" },
              'ci':              { color: '006b75', description: "CI/CD and workflow updates" },
              'dependencies':    { color: '0366d6', description: "Dependency updates" },
              'database':        { color: 'fbca04', description: "Database migrations or schema changes" },
              'build':           { color: '89590b', description: "Build system and tooling updates" },
              'accessibility':   { color: 'c2e0c6', description: "Accessibility (a11y) improvements" },
              'localization':    { color: '91d674', description: "Localization (i18n) and translation" },
              'api':             { color: '1d76db', description: "API endpoint or schema changes" },
              'infrastructure':  { color: '5e4a80', description: "Cloud infrastructure and IaC changes" },
              'config':          { color: 'c5def5', description: "Configuration and environment changes" },
              'types':           { color: '2b67c6', description: "Type definitions and schema changes" },
              'logging':         { color: 'bfdadc', description: "Logging, monitoring, and observability" },
              'deprecation':     { color: 'ffa500', description: "Deprecated features with migration paths" }
            };

            const VALID_LABELS = new Set(Object.keys(labelDefinitions));

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HELPERS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            async function ensureLabelExists(name) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  const def = labelDefinitions[name] || { color: 'ededed', description: '' };
                  await github.rest.issues.createLabel({
                    owner, repo, name, color: def.color, description: def.description
                  });
                }
              }
            }

            async function getOrCreateMilestone() {
              const milestones = await github.rest.issues.listMilestones({
                owner, repo, state: 'open', sort: 'due_on', direction: 'asc'
              });
              if (milestones.data.length > 0) return milestones.data[0];

              let nextVersion = 'v0.0.1';
              try {
                const releases = await github.rest.repos.listReleases({ owner, repo });
                const latest = releases.data[0];
                if (latest) {
                  const parts = latest.tag_name.replace('v', '').split('.').map(Number);
                  parts[2] += 1;
                  nextVersion = `v${parts.join('.')}`;
                }
              } catch (e) {}

              const created = await github.rest.issues.createMilestone({
                owner, repo, title: nextVersion
              });
              return created.data;
            }

            function parseAILabels(raw) {
              if (!raw) return [];
              try {
                // Strip markdown fences if present
                const cleaned = raw.replace(/```json\s*/gi, '').replace(/```\s*/gi, '').trim();
                const parsed = JSON.parse(cleaned);
                if (Array.isArray(parsed)) {
                  return parsed
                    .map(l => String(l).trim().toLowerCase())
                    .filter(l => VALID_LABELS.has(l));
                }
              } catch (e) {
                // Fallback: try line-by-line or comma-separated parsing
                const lines = raw
                  .replace(/[\[\]"'`]/g, '')
                  .split(/[,\n]/)
                  .map(l => l.trim().toLowerCase())
                  .filter(l => VALID_LABELS.has(l));
                return [...new Set(lines)];
              }
              return [];
            }

            async function upsertBotComment(body) {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: issueNumber
              });

              const existing = comments.find(c =>
                c.user.type === 'Bot' && c.body.includes(BOT_COMMENT_SIGNATURE)
              );

              const fullBody = BOT_COMMENT_SIGNATURE + '\n' + body;

              if (existing) {
                await github.rest.issues.updateComment({
                  owner, repo, comment_id: existing.id, body: fullBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner, repo, issue_number: issueNumber, body: fullBody
                });
              }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MAIN â€” OPENED / SYNCHRONIZE / REOPENED
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            if (['opened', 'synchronize', 'reopened'].includes(payload.action)) {
              const aiSummary = process.env.AI_SUMMARY || '';
              const aiLabelsRaw = process.env.AI_LABELS_RAW || '';

              // â”€â”€ Parse & apply AI-classified labels (PRs only) â”€â”€
              let labelsToAdd = [];

              if (isPR && aiLabelsRaw) {
                labelsToAdd = parseAILabels(aiLabelsRaw);
              }

              if (labelsToAdd.length > 0) {
                for (const label of labelsToAdd) {
                  await ensureLabelExists(label);
                }
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: issueNumber, labels: labelsToAdd
                });
                core.info(`âœ… Applied AI labels: ${labelsToAdd.join(', ')}`);
              }

              // â”€â”€ Post / update AI summary comment (PRs only) â”€â”€
              if (isPR && aiSummary) {
                const pr = payload.pull_request;
                const appliedLabels = labelsToAdd.map(l => `\`${l}\``).join(' ') || '_none_';

                const commentBody = [
                  `# Autobot â€” Changes Analysis`,
                  '',
                  `> **PR #${pr.number}** Â· ${pr.head.ref} â†’ ${pr.base.ref} Â· ${new Date().toISOString().split('T')[0]}`,
                  '',
                  '---',
                  '',
                  aiSummary,
                  '',
                  '---',
                  '',
                  '<details>',
                  '<summary><strong>ğŸ·ï¸ AI Label Classification</strong></summary>',
                  '',
                  `**Applied labels:** ${appliedLabels}`,
                  '',
                  'Labels were determined by AI analysis of the code diff â€” not the PR title or description.',
                  '',
                  '</details>',
                  '',
                  '<details>',
                  '<summary><strong>â„¹ï¸ About this analysis</strong></summary>',
                  '',
                  '</details>'
                ].join('\n');

                await upsertBotComment(commentBody);
                core.info('âœ… Posted AI summary comment');
              }

              // â”€â”€ Milestone management â”€â”€
              const freshIssue = await github.rest.issues.get({
                owner, repo, issue_number: issueNumber
              });
              const currentLabelNames = freshIssue.data.labels.map(l => l.name);

              const shouldSkipMilestone = currentLabelNames.some(l => IGNORE_LABELS.includes(l));
              const hasNoLabels = currentLabelNames.length === 0;

              if (shouldSkipMilestone || hasNoLabels) {
                return;
              }

              const milestone = await getOrCreateMilestone();
              const currentMilestone = payload.issue?.milestone || payload.pull_request?.milestone;

              if (!currentMilestone) {
                await github.rest.issues.update({
                  owner, repo, issue_number: issueNumber, milestone: milestone.number
                });
              }

              const items = await github.paginate(github.rest.issues.listForRepo, {
                owner, repo, milestone: milestone.number, state: 'all'
              });

              const hasFeature = items.some(i => i.labels.some(l => l.name === 'enhancement'));
              const isBreaking = items.some(i => i.labels.some(l => l.name === 'breaking-change'));

              if (isBreaking && isPR) {
                const comments = await github.rest.issues.listComments({
                  owner, repo, issue_number: issueNumber
                });
                const alreadyAlerted = comments.data.some(c => c.body.includes('MAJOR RELEASE ALERT'));

                if (!alreadyAlerted) {
                  await github.rest.issues.createComment({
                    owner, repo, issue_number: issueNumber,
                    body: `ğŸš¨ **MAJOR RELEASE ALERT** ğŸš¨\n\n@${owner} This PR triggers a **major** version bump due to breaking changes detected by AI analysis.`
                  });
                }
              }

              // â”€â”€ Semantic version bump logic â”€â”€
              const rawParts = milestone.title.replace('v', '').split('.').map(Number);
              let [major, minor, patch] = [rawParts[0] || 0, rawParts[1] || 0, rawParts[2] || 0];
              let newTitle = milestone.title;

              if (isBreaking) {
                if (milestone.title.split('.')[0] === `v${major}`) {
                  major++; minor = 0; patch = 0;
                  newTitle = `v${major}.${minor}.${patch}`;
                }
              } else if (hasFeature) {
                if (patch > 0 || minor === rawParts[1]) {
                  if (rawParts[2] !== 0) {
                    minor++; patch = 0;
                    newTitle = `v${major}.${minor}.${patch}`;
                  }
                }
              }

              if (newTitle !== milestone.title) {
                await github.rest.issues.updateMilestone({
                  owner, repo, milestone_number: milestone.number, title: newTitle
                });
              }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MAIN â€” CLOSED (release management)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            if (payload.action === 'closed') {
              const mData = payload.issue?.milestone || payload.pull_request?.milestone;
              if (!mData) return;

              const freshMilestone = await github.rest.issues.getMilestone({
                owner, repo, milestone_number: mData.number
              });

              if (freshMilestone.data.open_issues === 0 &&
                  freshMilestone.data.state === 'open' &&
                  freshMilestone.data.closed_issues > 0) {

                const closedItems = await github.paginate(github.rest.issues.listForRepo, {
                  owner, repo, milestone: freshMilestone.data.number, state: 'closed'
                });

                const hasBreaking = closedItems.some(i => i.labels.some(l => l.name === 'breaking-change'));
                const hasForcedType = closedItems.some(i =>
                  i.labels.some(l => FORCE_RELEASE_TYPES.includes(l.name))
                );

                if (freshMilestone.data.closed_issues < MIN_RELEASE_SIZE && !hasForcedType && !hasBreaking) {
                  return;
                }

                let targetVersion = freshMilestone.data.title;
                const releases = await github.rest.repos.listReleases({ owner, repo });
                const latestRelease = releases.data[0];

                if (latestRelease && latestRelease.draft) {
                  const v1 = targetVersion.replace('v', '').split('.').map(Number);
                  const v2 = latestRelease.tag_name.replace('v', '').split('.').map(Number);

                  const isV2Larger = v2[0] > v1[0] ||
                    (v2[0] === v1[0] && v2[1] > v1[1]) ||
                    (v2[0] === v1[0] && v2[1] === v1[1] && v2[2] > v1[2]);

                  if (isV2Larger) targetVersion = latestRelease.tag_name;

                  await github.rest.repos.deleteRelease({ owner, repo, release_id: latestRelease.id });
                  try {
                    await github.rest.git.deleteRef({ owner, repo, ref: `tags/${latestRelease.tag_name}` });
                  } catch (e) {}
                }

                await github.rest.issues.updateMilestone({
                  owner, repo, milestone_number: freshMilestone.data.number, state: 'closed'
                });

                await github.rest.repos.createRelease({
                  owner, repo, tag_name: targetVersion, name: targetVersion,
                  generate_release_notes: true,
                  draft: true
                });

                const parts = targetVersion.replace('v', '').split('.').map(Number);
                parts[2] += 1;
                const nextVersion = `v${parts.join('.')}`;
                await github.rest.issues.createMilestone({ owner, repo, title: nextVersion });
              }
            }